global _mandelbrot_int_nosoi

; This iteration function was generated by GCC from the following code, using
; optimizations -O3 -fomit-frame-pointer
;
;#define multiply_and_shift(input1, input2, output, shift) \
;  asm ("imull %1;" \
;       "shrdl " #shift ", %%edx, %%eax" \
;       :"=a"(output) \
;       :"r"(input1), "0"(input2) \
;       :"%edx")
;
;void iterate(struct MandelData *data)
;{
;    int zx = data->_zx;
;    int zy = data->_zy;
;    int zSx = data->_zSx;
;    int zSy = data->_zSy;
;    int cx = data->_cx;
;    int cy = data->_cy;
;    int maximumIterations = data->_maximumIterations;
;    int delta2 = data->_delta2;
;    int bailoutRadius2 = data->_bailoutRadius2;
;    int i;
;
;    for (i = 0; i < maximumIterations; i += 2) {
;        int zr2, zi2;
;        multiply_and_shift(zx, zx, zr2, 22);
;        multiply_and_shift(zy, zy, zi2, 22);
;        multiply_and_shift(zx, zy, zy, 21);
;        zy += cy;
;        zx = zr2 - zi2 + cx;
;        if (zr2 + zi2 > bailoutRadius2) {
;            data->_result = i + 1;
;            return;
;        }
;
;        multiply_and_shift(zx, zx, zr2, 22);
;        multiply_and_shift(zy, zy, zi2, 22);
;        multiply_and_shift(zx, zy, zy, 21);
;        zy += cy;
;        zx = zr2 - zi2 + cx;
;        if (zr2 + zi2 > bailoutRadius2) {
;            data->_result = i + 2;
;            return;
;        }
;
;        multiply_and_shift(zSx, zSx, zr2, 22);
;        multiply_and_shift(zSy, zSy, zi2, 22);
;        multiply_and_shift(zSx, zSy, zSy, 21);
;        zSy += cy;
;        zSx = zr2 - zi2 + cx;
;        int dx = zx - zSx;
;        int dy = zy - zSy;
;        int dx2;
;        int dy2;
;        multiply_and_shift(dx, dx, dx2, 22);
;        multiply_and_shift(dy, dy, dy2, 22);
;        if (dx2 + dy2 < delta2) {
;            data->_result = 0;
;            return;
;        }
;    }
;
;    data->_zx = zx;
;    data->_zy = zy;
;    data->_zSx = zSx;
;    data->_zSy = zSy;
;    data->_result = -1;
;}
;
; However, because the only signed 32x32->64 multiply in the 32-bit x86 ISA
; always takes eax as input and generates output in edx:eax, with each multiply
; we need to load eax before and stash it afterwards before the next multiply.
; We also lose the use of edx as a general register. All this means that the
; integer routine is actually slower than the floating-point versions! (On my
; 2GHz 2-core Core Duo machine, I get a peak of ~150M iterations per second for
; double-precision and ~100M iterations for second for this routine).
;
;struct MandelData
;{
;    void* _context;         // 0
;    int _delta2;            // 4
;    int _cx;                // 8
;    int _cy;                // 12
;    int _zx;                // 16
;    int _zy;                // 20
;    int _zSx;               // 24
;    int _zSy;               // 28
;    int _maximumIterations; // 32
;    int _bailoutRadius2;    // 36
;    int _result;            // 40
;};
;
;extern "C" void __cdecl mandelbrot_int_nosoi(struct MandelData* data);
;
;    void iterate()
;    {
;        MandelData data;
;        data._delta2 = static_cast<int>(_delta2 * 0x400000);
;        data._cx = static_cast<int>(_c.x * 0x400000);
;        data._cy = static_cast<int>(_c.y * 0x400000);
;        data._zx = static_cast<int>(_z.x * 0x400000);
;        data._zy = static_cast<int>(_z.y * 0x400000);
;        data._zSx = static_cast<int>(_zS.x * 0x400000);
;        data._zSy = static_cast<int>(_zS.y * 0x400000);
;        data._maximumIterations = _maximumIterations;
;        data._bailoutRadius2 = static_cast<int>(_bailoutRadius2 * 0x400000);
;        mandelbrot_int_nosoi(&data);
;        _z.x = static_cast<double>(data._zx) / 0x400000;
;        _z.y = static_cast<double>(data._zy) / 0x400000;
;        _zS.x = static_cast<double>(data._zSx) / 0x400000;
;        _zS.y = static_cast<double>(data._zSy) / 0x400000;
;        _result = data._result;
;    }

_mandelbrot_int_nosoi:
    push ebp
    push edi
    push esi
    push ebx
    sub esp, 32
    mov eax, [esp + 52]           ; eax = data
    mov ecx, [eax + 16]           ; ecx = data->_zx
    mov edi, [eax + 20]           ; edi = data->_zy
    mov edx, [eax + 24]           ; edx = data->_zSx
    mov [esp + 4], edx            ; zSx = data->_zSx
    mov ebp, [eax + 28]           ; ebp = data->_zSy
    mov edx, [eax + 8]            ; eax = data->_cx
    mov [esp + 16], edx           ; cx = data->_cx
    mov edx, [eax + 12]           ; edx = data->_cy
    mov [esp + 12], edx           ; cy = data->_cy
    mov edx, [eax + 32]           ; edx = data->_maximumIterations
    mov [esp + 24], edx           ; maximumIterations = data->_maximumIterations
    mov edx, [eax + 4]            ; edx = data->_delta2
    mov [esp + 28], edx           ; delta2 = data->_delta2
    mov edx, [eax + 36]           ; edx = data->_bailoutRadius2
    mov [esp + 20], edx           ; bailoutRadius2 = data->_bailoutRadius2
    mov eax, ecx                  ; eax = zx
    imul ecx
    shrd eax, edx, 22             ; eax = zx*zx
    mov ebx, eax                  ; ebx = zx*zx
    mov eax, edi                  ; eax = zy
    imul edi
    shrd eax, edx, 22             ; eax = zy*zy
    mov esi, eax                  ; esi = zy*zy
    mov eax, edi                  ; eax = zy
    imul ecx
    shrd eax, edx, 21             ; eax = 2*zx*zy
    mov edi, eax                  ; edi = zy*zy
    lea eax, [esi + ebx]          ; eax = zx*zx + zy*zy
    cmp [esp + 20], eax
    jl bailedout1                 ; zx*zx + zy*zy > bailoutRadius
    add edi, [esp + 12]           ; edi = 2*zx*zy + cy
    mov [esp + 8], edi            ; zy = 2*zx*zy + cy
    mov edi, [esp + 16]           ; edi = cx
    lea edi, [ebx + edi]          ; edi = zx*zx + cx
    sub edi, esi                  ; edi = zx*zx - zy*zy + cx = new zx
    mov eax, edi                  ; eax = zx
    imul edi
    shrd eax, edx, 22             ; eax = zx*zx
    mov ecx, eax                  ; ecx = zx*zx
    mov ebx, [esp + 8]            ; ebx = zy
    mov eax, ebx                  ; eax = zy
    imul ebx
    shrd eax, edx, 22             ; eax = zy*zy
    mov ebx, eax                  ; ebx = zy*zy
    mov eax, [esp + 8]            ; eax = zy
    imul edi
    shrd eax, edx, 21             ; eax = 2*zx*zy
    mov [esp + 8], eax            ; 2*zx*zy
    lea eax, [ebx + ecx]          ; eax = zx*zx* + zy*zy
    cmp [esp + 20], eax
    jl bailedout2                 ; zx*zx + zy*zy > bailoutRadius
    mov edi, [esp + 8]            ; edi = 2*zx*zy
    add edi, [esp + 12]           ; edi = 2*zx*zy + cy = new zy
    add ecx, [esp + 16]           ; ecx = zx*zx + cx
    sub ecx, ebx                  ; ecx = zx*zx - zy*zy + cx
    mov dword[esp + 8], 0         ; i = 0
    mov [esp], ecx                ; zx = zx*zx - zy*zy + cx
    jmp periodicityCheck
nextIteration:
    add dword[esp + 8], 2         ; i += 2
    mov ecx, [esp + 8]            ; ecx = i
    cmp [esp + 24], ecx
    jle timedOut                  ; i >= maximumIterations
    mov esi, [esp]                ; esi = zx
    mov eax, esi                  ; eax = zx
    imul esi
    shrd eax, edx, 22             ; eax = zx*zx
    mov esi, eax                  ; esi = zx*zx
    mov eax, edi                  ; eax = zy
    imul edi
    shrd eax, edx, 22             ; eax = zy*zy
    mov ebx, eax                  ; ebx = zy*zy
    mov eax, edi                  ; eax = zy
    mov ecx, [esp]                ; ecx = zx
    imul ecx
    shrd eax, edx, 21             ; eax = 2*zx*zy
    mov edi, eax                  ; edi = 2*zx*zy
    lea eax, [ebx + esi]          ; eax = zx*zx + zy*zy
    cmp [esp + 20], eax
    jl bailedout3                 ; zx*zx + zy*zy > bailoutRadius
    add edi, [esp + 12]           ; edi = 2*zx*zy + cy = new zy
    add esi, [esp + 16]           ; esi = zx*zx + cx
    sub esi, ebx                  ; esi = zx*zx - zy*zy + cx = new zx
    mov eax, esi                  ; eax = zx
    imul esi
    shrd eax, edx, 22             ; eax = zx*zx
    mov ecx, eax                  ; ecx = zx*zx
    mov eax, edi                  ; eax = zy
    imul edi
    shrd eax, edx, 22             ; eax = zy*zy
    mov ebx, eax                  ; ebx = zy*zy
    mov eax, edi                  ; eax = zy
    imul esi
    shrd eax, edx, 21             ; eax = 2*zx*zy
    mov edi, eax                  ; edi = 2*zx*zy
    lea eax, [ebx + ecx]          ; eax = zx*zx + zy*zy
    cmp [esp + 20], eax
    jl bailedout4                 ; zx*zx + zy*zy > bailoutRadius
    add edi, [esp + 12]           ; edi = 2*zx*zy + cy = new zy
    add ecx, [esp + 16]           ; ecx = zx*zx + cx
    sub ecx, ebx                  ; ecx = zx*zx - zy*zy + cx
    mov [esp], ecx                ; zx = zx*zx - zy*zy + cx
periodicityCheck:
    mov esi, [esp + 4]            ; esi = zSx
    mov eax, esi                  ; eax = zSx
    imul esi
    shrd eax, edx, 22             ; eax = zSx*zSx
    mov esi, eax                  ; esi = zSx*zSx
    mov eax, ebp                  ; eax = zSy
    imul ebp
    shrd eax, edx, 22             ; eax = zSy*zSy
    mov ebx, eax                  ; ebx = zSy*zSy
    mov eax, ebp                  ; eax = zSy
    mov ecx, [esp + 4]            ; ecx = zSx
    imul ecx
    shrd eax, edx, 21             ; eax = 2*zSx*zSy
    mov ebp, [esp + 12]           ; ebp = cy
    add ebp, eax                  ; ebp = 2*zSx*zSy + cy = new zSy
    add esi, [esp + 16]           ; esi = zSx*zSx + cx
    mov [esp + 4], esi            ; zSx = zSx*zSx + cx
    sub [esp + 4], ebx            ; zSx = zSx*zSx - zSy*zSy + cx
    mov ebx, [esp]                ; ebx = zx
    sub ebx, [esp + 4]            ; ebx = zx - zSx
    mov esi, edi                  ; esi = zy
    sub esi, ebp                  ; esi = zy - zSy
    mov eax, ebx                  ; eax = zx - zSx
    imul ebx
    shrd eax, edx, 22             ; eax = (zx - zSx)*(zx - zSx)
    mov ebx, eax                  ; ebx = (zx - zSx)*(zx - zSx)
    mov eax, esi                  ; eax = zy - zSy
    imul esi
    shrd eax, edx, 22             ; eax = (zy - zSy)*(zy - zSy)
    lea ebx, [eax + ebx]          ; ebx = (zx - zSx)*(zx - zSx) + (zy - zSy)*(zy - zSy)
    cmp [esp + 28], ebx
    jle nextIteration             ; (zx - zSx)*(zx - zSx) + (zy - zSy)*(zy - zSy) > delta2
    mov edx, [esp + 52]           ; edx = data
    mov eax, [esp + 8]
    add eax, 2
    neg eax
    mov [edx + 40], eax           ; data->_result = -(i + 2)
    add esp, 32
    pop ebx
    pop esi
    pop edi
    pop ebp
    ret
timedOut:
    mov ecx, [esp]                ; ecx = zx
    mov eax, [esp + 52]           ; eax = data
    mov [eax + 16], ecx           ; data->_zx = zx
    mov [eax + 20], edi           ; data->_zy = zy
    mov edx, [esp + 4]            ; edx = zSx
    mov [eax + 24], edx           ; data->_zSx = zSx
    mov [eax + 28], ebp           ; data->_zSy = zSy
    mov dword [eax + 40], -1      ; data->_result = -1
    add esp, 32
    pop ebx
    pop esi
    pop edi
    pop ebp
    ret
bailedout3:
    mov eax, [esp + 8]            ; eax = i
    add eax, 1                    ; result = i + 1
finished:
    mov edx, [esp + 52]           ; edx = data
    mov [edx + 40], eax           ; data->_result = result
    add esp, 32
    pop ebx
    pop esi
    pop edi
    pop ebp
    ret
bailedout4:
    mov eax, [esp + 8]            ; eax = i
    add eax, 2                    ; eax = i + 2
    jmp finished
bailedout2:
    mov eax, 2                    ; result = 2
    jmp finished
bailedout1:
    mov eax, 1                    ; result = 1
    jmp finished



;_mandelbrot_double_sse2_nosoi_vc:
  ;push ebp
  ;mov ebp,esp
  ;and esp,-8
  ;sub esp,20h
  ;movsd xmm0,mmword ptr [eax+10h]  ; _c.x
  ;mov edx,dword ptr [eax+40h]      ; _maximumIterations
  ;movsd xmm7,mmword ptr [eax+20h]  ; _z.x
  ;movsd xmm1,mmword ptr [eax+28h]  ; _z.y
  ;movsd xmm6,mmword ptr [eax+30h]  ; _zS.x
  ;movsd xmm3,mmword ptr [eax+38h]  ; _zS.y
  ;movsd mmword ptr [esp+10h],xmm0  ; c.x
  ;movsd xmm0,mmword ptr [eax+18h]  ; _c.y
  ;movsd mmword ptr [esp+18h],xmm0  ; c.y
  ;movsd xmm0,mmword ptr [eax+8]    ; _delta2
  ;movsd mmword ptr [esp+8],xmm0    ; delta2
  ;movsd xmm0,mmword ptr [eax+48h]  ; _bailoutRadius2
  ;xor ecx,ecx                      ; i
  ;movsd mmword ptr [esp],xmm0      ; bailoutRadius2
  ;test edx,edx
  ;jle timeOut                      ; maximumIterations <= 0?
;loopTop:
  ;movapd xmm0,xmm1                 ; z.y
  ;mulsd xmm0,xmm1                  ; z.y*z.y
  ;movapd xmm2,xmm7                 ; z.x
  ;mulsd xmm2,xmm7                  ; z.x*z.x
  ;movapd xmm4,xmm2                 ; z.x*z.x
  ;subsd xmm4,xmm0                  ; z.x*z.x - z.y*z.y
  ;addsd xmm4,mmword ptr [esp+10h]  ; z.x*z.x - z.y*z.y + c.x
  ;mulsd xmm1,xmm7                  ; z.y*z.x
  ;mulsd xmm1,mmword ptr [two]      ; 2*z.y*z.x
  ;addsd xmm1,mmword ptr [esp+18h]  ; 2*z.y*z.x + c.y
  ;addsd xmm0,xmm2                  ; z.y*z.y + z.x*z.x
  ;comisd xmm0,mmword ptr [esp]
  ;ja escaped1                      ; z.y*z.y + z.x*z.x > bailoutRadius2
  ;movapd xmm2,xmm1                 ; z.y = 2*z.y*z.x + c.y
  ;mulsd xmm2,xmm1                  ; z.y*z.y
  ;movapd xmm5,xmm4                 ; z.x = z.x*z.x - z.y*z.y + c.x
  ;mulsd xmm5,xmm4                  ; z.x*z.x
  ;mulsd xmm1,xmm4                  ; z.y*z.x
  ;mulsd xmm1,mmword ptr [two]      ; 2*z.y*z.x
  ;addsd xmm1,mmword ptr [esp+18h]  ; 2*z.y*z.x + c.y
  ;movapd xmm0,xmm5                 ; z.x*z.x
  ;subsd xmm0,xmm2                  ; z.x*z.x - z.y*z.y
  ;addsd xmm0,mmword ptr [esp+10h]  ; z.x*z.x - z.y*z.y + c.x
  ;addsd xmm2,xmm5                  ; z.y*z.y + z.x*z.x
  ;comisd xmm2,mmword ptr [esp]
  ;movapd xmm4,xmm1                 ; z.y = 2*z.y*z.x + c.y
  ;movapd xmm7,xmm0                 ; z.x = z.x*z.x - z.y*z.y + c.x
  ;ja escaped2                      ; z.y*z.y + z.x*z.x > bailoutRadius2
  ;movapd xmm5,xmm3                 ; zS.y
  ;mulsd xmm5,xmm3                  ; zS.y*zS.y
  ;movapd xmm2,xmm6                 ; zS.x
  ;mulsd xmm2,xmm6                  ; zS.x*zS.x
  ;subsd xmm2,xmm5                  ; zS.x*zS.x - zS.y*zS.y
  ;addsd xmm2,mmword ptr [esp+10h]  ; zS.x*zS.x - zS.y*zS.y + c.x
  ;mulsd xmm3,xmm6                  ; zS.y*zS.x
  ;mulsd xmm3,mmword ptr [two]      ; 2*zS.y*zS.x
  ;addsd xmm3,mmword ptr [esp+18h]  ; 2*zS.y*zS.x + c.y
  ;subsd xmm0,xmm2                  ; z.x - zS.x
  ;subsd xmm4,xmm3                  ; z.y - zS.y
  ;movapd xmm6,xmm2                 ; z.x - zS.x
  ;movapd xmm2,xmm4                 ; z.y - zS.y
  ;mulsd xmm2,xmm4                  ; (z.y - zS.y)*(z.y - zS.y)
  ;movapd xmm4,xmm0                 ; z.x - zS.x
  ;mulsd xmm4,xmm0                  ; (z.x - zS.x)*(z.x - zS.x)
  ;movsd xmm0,mmword ptr [esp+8]    ; delta2
  ;addsd xmm2,xmm4                  ; (z.y - zS.y)*(z.y - zS.y) + (z.x - zS.x)*(z.x - zS.x)
  ;comisd xmm0,xmm2
  ;ja periodic                      ; delta2 > (z.y - zS.y)*(z.y - zS.y) + (z.x - zS.x)*(z.x - zS.x)
  ;add ecx,2                        ; i += 2
  ;cmp ecx,edx
  ;jl loopTop                       ; i < maximumIterations
;timeOut:
  ;movsd mmword ptr [eax+20h],xmm7  ; z.x
  ;movsd mmword ptr [eax+28h],xmm1  ; z.y
  ;movsd mmword ptr [eax+30h],xmm6  ; zS.x
  ;movsd mmword ptr [eax+38h],xmm3  ; zS.y
  ;mov dword ptr [eax+50h],-1       ; _result
  ;mov esp,ebp
  ;pop ebp
  ;ret
;escaped1:
  ;inc ecx                          ; ++i
  ;mov dword ptr [eax+50h],ecx      ; _result
  ;mov esp,ebp
  ;pop ebp
  ;ret
;escaped2:
  ;add ecx,2                        ; i += 2
  ;mov dword ptr [eax+50h],ecx      ; _result
  ;mov esp,ebp
  ;pop ebp
  ;ret
;periodic:
  ;mov dword ptr [eax+50h],0        ; _result
  ;mov esp,ebp
  ;pop ebp
  ;ret
;
;
;.data
;two:
  ;db 0,0,0,0,0,0,0,040
;
;
;
;
;_mandelbrot_double_sse2_nosoi_gcc:
  ;push %ebp
  ;mov %esp,%ebp
  ;sub $0x10,%esp
  ;mov 0x8(%ebp),%ecx
  ;movsd 0x1c(%ecx),%xmm2
  ;movsd 0x24(%ecx),%xmm1
  ;movsd 0x2c(%ecx),%xmm0
  ;movsd 0x34(%ecx),%xmm4
  ;movsd 0xc(%ecx),%xmm6
  ;movsd 0x14(%ecx),%xmm5
  ;mov 0x3c(%ecx),%edx
  ;movsd 0x4(%ecx),%xmm3
  ;movsd %xmm3,-0x10(%ebp)
  ;movsd 0x40(%ecx),%xmm7
  ;movsd %xmm7,-0x8(%ebp)
  ;test %edx,%edx
  ;jle timeOut
  ;movapd %xmm2,%xmm3
  ;mulsd %xmm2,%xmm3
  ;movapd %xmm1,%xmm7
  ;mulsd %xmm1,%xmm7
  ;movapd %xmm3,%xmm2
  ;addsd %xmm7,%xmm2
  ;ucomisd -0x8(%ebp),%xmm2
  ;ja escape0
  ;movapd %xmm3,%xmm2
  ;subsd %xmm7,%xmm2
  ;addsd %xmm6,%xmm2
  ;movapd %xmm2,%xmm3
  ;addsd %xmm2,%xmm3
  ;mulsd %xmm1,%xmm3
  ;addsd %xmm5,%xmm3
  ;xor %eax,%eax
  ;jmp skip
;continue:
  ;subsd %xmm1,%xmm2
  ;addsd %xmm6,%xmm2
  ;movapd %xmm2,%xmm1
  ;addsd %xmm2,%xmm1
  ;mulsd %xmm3,%xmm1
  ;addsd %xmm5,%xmm1
  ;mulsd %xmm0,%xmm0
  ;movapd %xmm4,%xmm3
  ;mulsd %xmm4,%xmm3
  ;subsd %xmm3,%xmm0
  ;addsd %xmm6,%xmm0
  ;movapd %xmm0,%xmm3
  ;addsd %xmm0,%xmm3
  ;mulsd %xmm3,%xmm4
  ;addsd %xmm5,%xmm4
  ;movapd %xmm2,%xmm3
  ;subsd %xmm0,%xmm3
  ;movapd %xmm1,%xmm7
  ;subsd %xmm4,%xmm7
  ;mulsd %xmm3,%xmm3
  ;mulsd %xmm7,%xmm7
  ;addsd %xmm7,%xmm3
  ;movsd -0x10(%ebp),%xmm7
  ;ucomisd %xmm3,%xmm7
  ;ja periodic
  ;add $0x2,%eax
  ;cmp %eax,%edx
  ;jle timeOut
  ;mulsd %xmm2,%xmm2
  ;movapd %xmm1,%xmm3
  ;mulsd %xmm1,%xmm3
  ;movapd %xmm2,%xmm7
  ;addsd %xmm3,%xmm7
  ;ucomisd -0x8(%ebp),%xmm7
  ;ja escape1
  ;subsd %xmm3,%xmm2
  ;addsd %xmm6,%xmm2
  ;movapd %xmm2,%xmm3
  ;addsd %xmm2,%xmm3
  ;mulsd %xmm1,%xmm3
  ;addsd %xmm5,%xmm3
;skip:
  ;mulsd %xmm2,%xmm2
  ;movapd %xmm3,%xmm1
  ;mulsd %xmm3,%xmm1
  ;movapd %xmm2,%xmm7
  ;addsd %xmm1,%xmm7
  ;ucomisd -0x8(%ebp),%xmm7
  ;jbe continue
  ;add $0x2,%eax
;done:
  ;mov %eax,0x48(%ecx)
  ;leave
  ;ret
;timeOut:
  ;movsd %xmm2,0x1c(%ecx)
  ;movsd %xmm1,0x24(%ecx)
  ;movsd %xmm0,0x2c(%ecx)
  ;movsd %xmm4,0x34(%ecx)
  ;movl $0xffffffff,0x48(%ecx)
  ;leave
  ;ret
;periodic:
  ;movl $0x0,0x48(%ecx)
  ;leave
  ;ret
;escape1:
  ;add $0x1,%eax
  ;jmp done
;escape0:
  ;mov $0x1,%eax
  ;jmp done
;
;
;_mandelbrot_int_nosoi:
  ;push ebp
;
  ;; In: z.x in esi, z.y in ebx
;
  ;mov eax, esi             ; eax = z.x
  ;imul esi
  ;shrd eax, edx, 22        ; eax = z.x*z.x
  ;mov edi, eax             ; edi = z.x*z.x
;
  ;mov eax, ebx             ; eax = z.y
  ;imul ebx
  ;shrd eax, edx, 22        ; eax = z.y*z.y
  ;mov ecx, eax             ; ecx = z.y*z.y
;
  ;mov eax, esi             ; eax = z.x
  ;imul ebx
  ;shrd eax, edx, 21        ; eax = 2*z.x*z.y
  ;mov ebx, eax             ; ebx = 2*z.x*z.y
  ;add ebx, dword ptr [c.x] ; ebx = 2*z.x*z.y + c.x = new z.y
;
  ;mov esi, edi             ; esi = z.x*z.x
  ;sub esi, ecx             ; esi = z.x*z.x - z.y*z.y
  ;add esi, dword ptr [c.y] ; esi = z.x*z.x - z.y*z.y + c.y = new z.x
;
  ;add edi, ecx             ; edi = z.x*z.x + z.y*z.y
  ;cmp edi, dword ptr [bailoutRadius2]
  ;jg escaped1
;
;
  ;mov eax, esi             ; eax = z.x
  ;imul esi
  ;shrd eax, edx, 22        ; eax = z.x*z.x
  ;mov edi, eax             ; edi = z.x*z.x
;
  ;mov eax, ebx             ; eax = z.y
  ;imul ebx
  ;shrd eax, edx, 22        ; eax = z.y*z.y
  ;mov ecx, eax             ; ecx = z.y*z.y
;
  ;mov eax, esi             ; eax = z.x
  ;imul ebx
  ;shrd eax, edx, 21        ; eax = 2*z.x*z.y
  ;mov ebx, eax             ; ebx = 2*z.x*z.y
  ;add ebx, dword ptr [c.x] ; ebx = 2*z.x*z.y + c.x = new z.y
;
  ;mov esi, edi             ; esi = z.x*z.x
  ;sub esi, ecx             ; esi = z.x*z.x - z.y*z.y
  ;add esi, dword ptr [c.y] ; esi = z.x*z.x - z.y*z.y + c.y = new z.x
;
  ;add edi, ecx             ; edi = z.x*z.x + z.y*z.y
  ;cmp edi, dword ptr [bailoutRadius2]
  ;jg escaped2
;
;





  ;mov ebp, edi             ; z.x*z.x
  ;sub ebp, eax             ; z.x*z.x - z.y*z.y
  ;add ebp, dword ptr [c.x] ; z.x*z.x - z.y*z.y + c.x
  ;mov eax, esi             ; z.x
  ;imul ebx
  ;shrd eax, edx, 21        ; 2*z.x*z.y
  ;add eax, dword ptr [c.y] ; 2*z.x*z.y + c.y
  ;mov e
;






    ;void longFixedIterate()
    ;{
        ;int p = _precision;
        ;ensureLengths();
        ;SignedDigit bailoutRadius2 = static_cast<SignedDigit>(
            ;ldexp(_bailoutRadius2, bitsPerDigit - intBits));
        ;fixedFromDouble(_t[3], 1.0, _logDelta, p);
        ;int maximumIterations = _maximumIterations;
        ;for (int i = 0; i < maximumIterations; i += 2) {
            ;multiply(_t[0], _zx, _zx, _t[4], p);
            ;multiply(_t[1], _zy, _zy, _t[4], p);
            ;add(_t[2], _t[0], _t[1], p);
            ;if (static_cast<SignedDigit>(_t[2][p - 1]) > bailoutRadius2) {
                ;_result = i + 1;
                ;return;
            ;}
            ;multiply(_t[2], _zx, _zy, _t[4], p, intBits + 1);
            ;add(_zx, _t[0], _cx, p);
            ;sub(_zx, _zx, _t[1], p);
            ;add(_zy, _t[2], _cy, p);
;
            ;multiply(_t[0], _zx, _zx, _t[4], p);
            ;multiply(_t[1], _zy, _zy, _t[4], p);
            ;add(_t[2], _t[0], _t[1], p);
            ;if (static_cast<SignedDigit>(_t[2][p - 1]) > bailoutRadius2) {
                ;_result = i + 2;
                ;return;
            ;}
            ;multiply(_t[2], _zx, _zy, _t[4], p, intBits + 1);
            ;add(_zx, _t[0], _cx, p);
            ;sub(_zx, _zx, _t[1], p);
            ;add(_zy, _t[2], _cy, p);
;
            ;multiply(_t[0], _zSx, _zSx, _t[4], p);
            ;multiply(_t[1], _zSy, _zSy, _t[4], p);
            ;multiply(_t[2], _zx, _zy, _t[4], p, intBits + 1);
            ;add(_zSx, _t[0], _cx, p);
            ;sub(_zSx, _zSx, _t[1], p);
            ;add(_zSy, _t[2], _cy, p);
            ;sub(_t[0], _zSx, _zx, p);
            ;abs(_t[0], _t[0], p);
            ;if (lessThan(_t[0], _t[3], p)) {
                ;sub(_t[0], _zSy, _zy, p);
                ;abs(_t[0], _t[0], p);
                ;if (lessThan(_t[0], _t[3], p)) {
                    ;_result = -(i + 2);
                    ;return;
                ;}
            ;}
        ;}
        ;_result = -1;
    ;}
;


;// a < b. Aliasing ok.
;bool lessThan(const Digit* a, const Digit* b, int n)
;{
    ;--n;
    ;SignedDigit aHigh = static_cast<SignedDigit>(a[n]);
    ;SignedDigit bHigh = static_cast<SignedDigit>(b[n]);
    ;if (aHigh < bHigh)
        ;return true;
    ;if (aHigh > bHigh)
        ;return false;
    ;while (n-- > 0) {
        ;if (a[n] < b[n])
            ;return true;
        ;if (a[n] > b[n])
            ;return false;
    ;}
    ;return false;
;}

;// r = -v. Aliasing ok.
;void negate(Digit* r, const Digit* v, int n)
;{
    ;Digit c = 1;
    ;while (n-- > 0)
        ;adc(*(r++), ~*(v++), 0, c);
;}

;// r = abs(v). Aliasing ok.
;void abs(Digit* r, const Digit* v, int n)
;{
    ;if (lessThanZero(v, n))
        ;negate(r, v, n);
    ;else
        ;copy(r, v, n);
;}

copy3:
  mov edx,[esp+4]
  mov ebx,[esp+8]
  mov eax,[ebx]
  mov [edx],eax
  mov eax,[ebx+4]
  mov [edx+4],eax
  mov eax,[ebx+8]
  mov [edx+8],eax
  ret

zero3:
  mov edx,[esp+4]
  xor eax,eax
  mov [edx],eax
  mov [edx+4],eax
  mov [edx+8],eax
  ret

add3:
  mov edx,[esp+4]
  mov ebx,[esp+8]
  mov ecx,[esp+12]
  mov eax,[ebx]
  add eax,[ecx]
  mov [edx],eax
  mov eax,[ebx+4]
  adc eax,[ecx+4]
  mov [edx+4],eax
  mov eax,[ebx+4]
  adc eax,[ecx+4]
  mov [edx+4],eax
  ret

sub3:
  mov edx,[esp+4]
  mov ebx,[esp+8]
  mov ecx,[esp+12]
  mov eax,[ebx]
  sub eax,[ecx]
  mov [edx],eax
  mov eax,[ebx+4]
  sbb eax,[ecx+4]
  mov [edx+4],eax
  mov eax,[ebx+4]
  sbb eax,[ecx+4]
  mov [edx+4],eax
  ret

negate3:
  mov edx,[esp+4]
  mov ebx,[esp+8]
  xor eax,eax
  sub eax,[ebx]
  mov [edx],eax
  xor eax,eax
  sbb eax,[ebx+4]
  mov [edx+4],eax
  xor eax,eax
  sbb eax,[ebx+8]
  mov [edx+8],eax
  ret



multiply:
    mov edx,[esp+4]
    mov ebx,[esp+8]
    mov ecx,[esp+12]
    movd mm7,[ecx]

    movd mm6,[ebx]
    pmuludq mm6,mm7
    movd [edx],mm6
    psrlq mm6,32

    movd mm0,[ebx+4]
    pmuludq mm0,mm7
    paddq mm6,mm0
    movd [edx+4],mm6
    psrlq mm6,32

    movd mm0,[ebx+8]
    pmuludq mm0,mm7
    paddq mm6,mm0
    movd [edx+8],mm6
    psrlq mm6,32

    movd eax,mm6
    add [edx+12],eax
    adc [edx+16],0
    adc [edx+20],0

    movd mm7,[ecx+4]

    movd mm0,[eax]
    movd mm6,[edx+4]
    pmuludq mm0,mm7
    paddq mm6,mm0
    movd [edx+4],mm6
    psrlq mm6,32

    movd mm0,[eax+4]
    movd mm4,[edx+8]
    pmuludq mm0,mm7
    paddq mm4,mm0
    paddq mm6,mm4
    movd [edx+8],mm6
    psrlq mm6,32

    movd mm0,[eax+8]
    movd mm4,[edx+12]
    pmuludq mm0,mm7
    paddq mm4,mm0
    paddq mm6,mm4
    movd [edx+12],mm6
    psrlq mm6,32

    movd eax,mm6
    add [edx+16],eax
    adc [edx+20],0

    movd mm7,[ecx+8]

    movd mm0,[eax]
    movd mm6,[edx+8]
    pmuludq mm0,mm7
    paddq mm6,mm0
    movd [edx+8],mm6
    psrlq mm6,32

    movd mm0,[eax+4]
    movd mm4,[edx+12]
    pmuludq mm0,mm7
    paddq mm4,mm0
    paddq mm6,mm4
    movd [edx+12],mm6
    psrlq mm6,32

    movd mm0,[eax+8]
    movd mm4,[edx+16]
    pmuludq mm0,mm7
    paddq mm4,mm0
    paddq mm6,mm4
    movd [edx+16],mm6
    psrlq mm6,32

    paddd mm6,[edx+20]
    movd [edx+20],mm6

    cmp w[ebx+8],0
    jge aPositive
    mov eax,[ecx]
    sub [edx+12],eax
    mov eax,[ecx+4]
    sbb [edx+16],eax
    mov eax,[ecx+8]
    sbb [edx+20],eax
aPositive:
    cmp w[ecx+8],0
    jge bPositive
    mov eax,[ebx]
    sub [edx+12],eax
    mov eax,[ebx+4]
    sbb [edx+16],eax
    mov eax,[ebx+8]
    sbb [edx+20],eax
bPositive:

    mov eax,[edx+8]
    mov ecx,eax
    mov ebx,[edx+12]
    shrd eax,ebx,22  ; 21 for doubled
    mov [edi],eax
    mov eax,[edx+16]
    shrd ebx,eax,22
    mov [edi+4],ebx
    mov ebx,[edx+20]
    shrd eax,ebx,22
    mov [edi+8],eax

    test ecx, 1<<21
    jz noCarry
    inc w[edi]
    adc w[edi+4],0
    adc w[edi+8],0

    ret





;l*l l*m l*h m*m m*h h*h
;
;L(l*l) H(l*l) L(m*m) H(m*m) L(h*h) H(h*h)
       ;L(l*m) H(l*m) L(m*h) H(m*h)
;
       ;L(l*m) H(l*m) L(m*h) H(m*h)
              ;L(l*h) H(l*h)
;
              ;L(l*h) H(l*h)
;
;
;square:
    ;mov edx,[esp+4]
    ;mov ebx,[esp+8]
                     ;; mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7
    ;movd mm0,[ebx]   ;  l
    ;movq mm1,mm0     ;  l   l
    ;pmuludq mm0,mm0  ; l*l  l
    ;movd [edx],mm0
    ;psrlq mm0,32     ;  c   l
;
    ;movd mm2,[ebx+4] ;  c   l   m
    ;movq mm3,mm2     ;  c   l   m   m
    ;pmuludq mm2,mm1  ;  c   l  l*m  m
    ;paddq mm0,mm2
    ;movd [edx+4],mm0
    ;psrlq mm0,32
;
    ;movd mm4,mm3     ;  c   l  l*m  m   m
    ;pmuludq mm3,mm3  ;  c   l  l*m m*m  m
    ;paddq mm0,mm3
    ;movd [edx+8],mm0
    ;psrlq mm0,32
;
    ;movd mm5,[ebx+4] ;  c   l  l*m m*m  m   h
    ;pmuludq mm4,mm5  ;  c   l  l*m m*m m*h  h
    ;paddq mm0,mm4
    ;movd [edx+12],mm0
    ;psrlq mm0,32
;
    ;movq mm3,mm5     ;  c   l  l*m  h  m*h  h
    ;pmuludq mm5,mm5  ;  c   l  l*m  h  m*h h*h
    ;paddq mm0,mm5
    ;movd [edx+16],mm0
    ;psrlq mm0,32
    ;movd [edx+20],mm0
;
;
    ;movd mm0,[edx+4]
    ;paddq mm0,mm2
    ;movd [edx+4],mm0
    ;psrlq mm0,32
;
    ;movd mm7,[edx+8]
    ;pmuludq mm1,mm3  ;  c  l*h l*m     m*h
    ;paddq mm7,mm1
    ;paddq mm0,mm7
    ;movd [edx+8],mm0
    ;psrlq mm0,32
;
    ;movd mm7,[edx+12]
    ;paddq mm7,mm4
    ;paddq mm0,mm7
    ;movd [edx+12],mm0
    ;psrlq mm0,32
;
    ;movd mm7,[edx+16]
    ;paddq mm0,mm7
    ;movd [edx+16],mm0
    ;psrlq mm0,32
;
    ;movd mm7,[edx+20]
    ;paddq mm0,mm7
    ;movd [edx+20],mm0
;
;
    ;movd mm0,[edx+8]
    ;paddq mm0,mm1
    ;movd [edx+8],mm0
    ;psrlq mm0,32
;
    ;movd mm7,[edx+12]
    ;paddq mm0,mm7
    ;movd [edx+12],mm0
    ;psrlq mm0,32
;
    ;movd mm7,[edx+16]
    ;paddq mm0,mm7
    ;movd [edx+16],mm0
    ;psrlq mm0,32
;
    ;movd mm7,[edx+20]
    ;paddq mm0,mm7
    ;movd [edx+20],mm0
;



; TODO: Combine mm6 and mm3, mm2 and mm1.
; Avoid reading from [edx+n]? 
; Input:
;   eax: source (3 dwords)
;   edx: destination (6 dwords)
; Clobbers ebx, ecx, esi, edi
square:
    mov edx,[esp+4]
    mov eax,[esp+8]
                      ; mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7
    movd mm5,[eax]    ;                      l        
    movd mm6,[eax+4]  ;                      l   m    
    movq mm0,mm6      ;  m                   l   m    
    pmuludq mm6,mm5   ;  m                   l   lm   
    movd mm2,[eax+8]  ;  m       h           l   lm   
    movq mm4,mm2      ;  m       h       h   l   lm   
    pmuludq mm2,mm5   ;  m       lh      h   l   lm   
    movd [edx+4],mm6  ;  m       lh      h   l   lm      eliminate B write?
    psrlq mm6,32      ;  m       lh      h   l   c    
    paddq mm6,mm2     ;  m               h   l   c    
    movd [edx+8],mm6  ;  m               h   l   c       eliminate C write?
    psrlq mm6,32      ;  m               h   l   c    
    movd [edx+12],mm6 ;  m               h   l           eliminate D write?
    movq mm2,mm4      ;  m       h       h   l        
    movd mm3,[edx+12] ;  m       h   ?   h   l           eliminate D read?
    pmuludq mm2,mm0   ;  m       mh  ?   h   l        
    paddq mm3,mm2     ;  m       mh  ?   h   l        
    movd [edx+12],mm3 ;  m           ?   h   l           eliminate D write?
    psrlq mm3,32      ;  m           ?   h   l        
    movd [edx+16],mm3 ;  m               h   l           eliminate E write?
    pmuludq mm5,mm5   ;  m               h   ll
    pcmpeqd mm7,mm7   ;  m               h   ll     -1
    psrlq mm7,32      ;  m               h   ll     fff
    movd mm3,[edx+4]  ;  m           ?   h   ll     fff  eliminate B read?
    movd [edx],mm5    ;  m           ?   h   ll     fff  final A
    psrlq mm5,32      ;  m           ?   h  Hll     fff
    psllq mm3,1       ;  m           ?   h  Hll     fff
    paddq mm5,mm3     ;  m               h   B      fff
    movd [edx+4],mm5  ;  m               h   B      fff  final B
    psrlq mm5,32      ;  m               h   ?      fff
    pmuludq mm0,mm0   ;  mm              h   ?      fff
    movq mm1,mm7      ;  mm fff          h   ?      fff
    pand mm1,mm0      ;  mm Lmm          h   ?      fff
    psrlq mm0,32      ; Hmm  ?           h   ?      fff
    movd mm3,[edx+8]  ; Hmm  ?       ?   h   ?      fff  eliminate C read?
    psllq mm3,1       ; Hmm  ?       ?   h   ?      fff
    paddq mm1,mm3     ; Hmm  ?           h   ?      fff
    paddq mm5,mm1     ; Hmm              h   C      fff
    movd [edx+8],mm5  ; Hmm              h   C      fff  final C
    psrlq mm5,32      ; Hmm              h   ?      fff
    movd mm3,[edx+12] ; Hmm          ?   h   ?      fff  eliminate D read?
    psllq mm3,1       ; Hmm          ?   h   ?      fff
    paddq mm0,mm3     ;  ?               h   ?      fff
    paddq mm5,mm0     ;                  h   D      fff
    movd [edx+12],mm5 ;                  h   D      fff  final D
    psrlq mm5,32      ;                  h   ?      fff
    pmuludq mm4,mm4   ;                  hh  ?      fff
    pand mm7,mm4      ;                  hh  ?      Lhh
    psrlq mm4,32      ;                 Hhh  ?      Lhh
    movd mm3,[edx+16] ;              ?  Hhh  ?      Lhh  eliminate E read?
    psllq mm3,1       ;              ?  Hhh  ?      Lhh
    paddq mm7,mm3     ;                 Hhh  ?      Lhh
    paddq mm5,mm7     ;                 Hhh  E
    movd [edx+16],mm5 ;                 Hhh  E           final E
    psrlq mm5,32      ;                 Hhh HE
    paddq mm5,mm4     ;                      F
    movd [edx+20],mm5 ;                                  final F
    cmp w[ebx+8],0
    jge positive
    mov eax,[ebx]
    sub [edx+12],eax
    mov ecx,[ebx+4]
    sbb [edx+16],ecx
    mov ebx,[ebx+8]
    sbb [edx+20],ebx
    sub [edx+12],eax
    sbb [edx+16],ecx
    sbb [edx+20],ebx
positive:

    mov eax,[edx+8]
    mov ecx,eax
    mov ebx,[edx+12]
    shrd eax,ebx,22  ; 21 for doubled
    mov [edi],eax
    mov eax,[edx+16]
    shrd ebx,eax,22  ; 21 for doubled
    mov [edi+4],ebx
    mov ebx,[edx+20]
    shrd eax,ebx,22  ; 21 for doubled
    mov [edi+8],eax

    test ecx, 1<<21  ; 20 for doubled
    jz noCarry
    inc w[edi]
    adc w[edi+4],0
    adc w[edi+8],0

    ret


;(x+y)*(x+y) = x*x + 2*x*y + y*y
