#include "alfe/main.h"
#include "alfe/complex.h"
#include "alfe/fix.h"
#include "alfe/fcolour.h"
#include "alfe/directx.h"
#include "alfe/fractal.h"
#include "alfe/linked_list.h"
#include "alfe/allocator.h"
#include <vector>
#include <list>
#include <algorithm>
#include <map>

#include "resource.h"

#include "long_fixed.cpp"

// Forward declarations
class FractalProcessor;
template<class FractalProcessor> class Matrix;
template<class FractalProcessor> class WorkQueueList;
template<class FractalProcessor> class Screen;
template<class FractalProcessor> class Evaluator;

class MColour : public FColour
{
public:
    MColour() { }
    MColour(unsigned int iterations)
    {
        if (iterations == 0) {
            _r = 0;
            _g = 0;
            _b = 0;
        }
        else {
            static float f = 4096/log(256.0f); //1024/log(256.0f);
            int i = static_cast<int>(log(static_cast<float>(iterations))*f);
            _r = gammaSinewave[i&1023];
            _g = gammaSinewave[(i + 341)&1023];
            _b = gammaSinewave[(i + 683)&1023];
        }
    }
};

#include "matrix.cpp"

// This handles the various coordinate systems:
// * Pixel coordinates (pixels)
// * Texel coordinates (texels)
// * Matrix coordinates (points)
// * Complex numbers (units)
// and transformations between them.
//
// Invariants:
// * All transformations are orthogonal, i.e. we assume square pixels and don't
//   allow stretching by different amounts in different directions (though such
//   images could be generated by transformations of c before evaluation).
// * Texel coordinates, matrix coordinates and complex numbers cannot be
//   rotated with respect to each other - the texel x axis and matrix x axis
//   both correspond to the real axis and rotation is accomplished by rotating
//   the pixel coordinates with respect to these.
// * Matrix coordinates are texel coordinates translated and scaled up by a
//   power of 2 such that the entire matrix coordinate space is in the range
//   ([0, 2^30), [0, 2^30)).
// * Complex numbers are related to texel coordinates by a translation and a
//   scaling by a factor of 2 (so the distance from 0 to 1 corresponds to 2^m
//   point coordinates and 2^n texel coordinates for some integers m and n.
// * When we transform between any two of complex numbers, pixel coordinates
//   and matrix coordinates, we go via texel coordinates.
// * The screen covered by the tower grid, but would not be by a grid of
//   fewer towers.
// * The left edge of the leftmost tower has horizontal texel coordinate 0 and
//   the top edge of the topmost tower has vertical texel coordinate 0.
// * The matrix covers all the towers, but a matrix of 1/4 the size would
//   not.
// * log_2(_texelsPerPixel) is between _logTilesPerTower and
//   _logTilesPerTower + 1.
// * _originUnit is a multiple of pow(2, _logUnitsPerTexel).
// * _matrixOrigin is on a tower corner (or would be, if the tower grid
//   extended that far).
template<class FractalProcessor> class Screen : Uncopyable
{
    typedef Matrix<FractalProcessor> Matrix;
public:
    // Initialization
    Screen()
      : _pixelsPerScreen(320, 240),
        _logPointsPerTexel(30),
        _matrixOrigin(0, 0),
        _angle(0),
        _logScreensPerUnit(0),
        _precision(0),
        _logUnitsPerTexel(0)
    { }

    void setProcessor(FractalProcessor* processor)
    {
        _processor = processor;
        _towerGrid = processor->towerGrid();
        _matrix = processor->matrix();
        _logTexelsPerTile = _towerGrid->logTexelsPerTile();
        _logTilesPerTower = _towerGrid->logTilesPerTower();
        _logTexelsPerTower = _logTexelsPerTile + _logTilesPerTower;
        _logPointsPerTexel -= _logTexelsPerTower;
    }

    void setInitial(Complex<double> centre, double logScreensPerUnit)
    {
        _logScreensPerUnit = Fix16p16(logScreensPerUnit);
        Vector2<double> pixelsPerScreen(_pixelsPerScreen);
        _zoomPixel = Vector2Cast<float>(pixelsPerScreen / 2.0);
        double unitsPerPixel = exp(-(_logScreensPerUnit).toDouble()*log(2.0))/
            sqrt(pixelsPerScreen.modulus2());
        int logUnitsPerPixel;
        frexp(unitsPerPixel, &logUnitsPerPixel);
        _logUnitsPerTexel = logUnitsPerPixel - (_logTilesPerTower + 1);
        double unitsPerTexel = ldexp(1.0, _logUnitsPerTexel);
        _texelsPerPixel = static_cast<float>(unitsPerPixel/unitsPerTexel);
        Vector2<double> zoomTexel = centre/unitsPerTexel;
        ensureLengths();
        fixedFromDouble(_zoomUnitX, zoomTexel.x, _logUnitsPerTexel, 1);
        fixedFromDouble(_zoomUnitY, zoomTexel.y, _logUnitsPerTexel, 1);
        update(true);
    }

    // Called by the window to set the size of screen in pixel coordinates
    void resize(Vector pixelsPerScreen)
    {
        if (pixelsPerScreen.zeroArea() || pixelsPerScreen == _pixelsPerScreen)
            return;
        setZoomUnitToPixel(Vector2Cast<float>(_pixelsPerScreen)/2);
        _zoomPixel = Vector2Cast<float>(pixelsPerScreen)/2;
        _pixelsPerScreen = pixelsPerScreen;
        update(false);
    }

    // Zoom function for ZoomingRotatingWindow (position and magnification)
    // angle is in units of 2*pi radians (i.e. a number between 0 and 1, the
    // fraction of a full rotation that we have rotated anticlockwise).
    // zoomPixel is the pixel into which we are zooming and/or around which we
    // are rotating. If it stays the same, or if panning is true, the
    // complex number corresponding to this pixel should not change.

    void zoomRotate(Fix16p16 logScreensPerUnit, Fix16p16 angle,
        Vector zoomPixel, bool panning, bool initializing)
    {
        if (angle == _angle && logScreensPerUnit == _logScreensPerUnit &&
            zoomPixel == Vector2Cast<int>(_zoomPixel)) {
            // Nothing's changed - nothing to do.
            return;
        }

        if (!panning && zoomPixel != Vector2Cast<int>(_zoomPixel))
            setZoomUnitToPixel(Vector2Cast<float>(zoomPixel));
        _angle = angle;
        _zoomPixel = Vector2Cast<float>(zoomPixel);
        _logScreensPerUnit = logScreensPerUnit;
        update(false);
    }

    void setInterrupt() { _matrix->setInterrupt(); }
    void clearInterrupt() { _matrix->clearInterrupt(); }
    void resume() { _processor->resume(); }

    // Determines if any part of a particular block is on screen.
    bool blockVisible(BlockLocation location) const
    {
        return texelAreaVisible(texelFromPoint(location._topLeft),
            texelsFromLogPoints(location._logPoints));
    }

    // Determines if a particular block is entirely on screen.
    bool blockEntirelyVisible(BlockLocation location) const
    {
        Vector texel = texelFromPoint(location._topLeft);
        int size = texelsFromLogPoints(location._logPoints);
        if (!texelVisible(texel))
            return false;
        texel.x += size;
        if (!texelVisible(texel))
            return false;
        texel.y += size;
        if (!texelVisible(texel))
            return false;
        texel.x -= size;
        if (!texelVisible(texel))
            return false;
        return true;
    }

    // Returns the minimum block size (used to determine if a block is
    // splittable)
    int logPointsPerTexel() const { return _logPointsPerTexel; }

    // Converts matrix coordinates to complex numbers
    void initEvaluatorWithPoint(Evaluator<FractalProcessor>* evaluator,
        Vector point)
    {
        cFromTexel(Vector2Cast<float>(texelFromPoint(point)),
            evaluator->cx(), evaluator->cy(), evaluator->precision());
        evaluator->setLogDelta(_logUnitsPerTexel);
    }

    // The pixel corresponding to a particular texel
    Vector2<float> pixelFromTexel(Vector texel) const
    {
        return (Vector2Cast<float>(texel) / _rotor) / _texelsPerPixel
            + _originPixel;
    }

    // Called by TowerGrid to re-plot a tile.
    void plotTile(Vector tilePosition)
    {
        _matrix->plot(BlockLocation(
            pointFromTexel(tilePosition << _logTexelsPerTile),
            _logPointsPerTexel + _logTexelsPerTile));
    }

    // Called by Manipulator during post-iteration plotting to plot a block
    // which may not be in a tile.
    void checkedPlot(BlockLocation location, int colour)
    {
        if (plottable(location))
            _towerGrid->plot(texelFromPoint(location._topLeft),
                texelsFromLogPoints(location._logPoints),
                MColour(colour).asDWord());
    }

    // Called by Manipulator to plot a block without checking - used in tile
    // plotting.
    void plotBlock(BlockLocation location, int colour)
    {
        if (plottable(location))
            _towerGrid->tilePlot(texelFromPoint(location._topLeft),
                texelsFromLogPoints(location._logPoints),
                MColour(colour).asDWord());
    }

    // We don't allow any point blocks in the matrix to be larger than this.
    int logPointsPerTile() const
    {
        return _logPointsPerTexel + _logTexelsPerTile;
    }

    // Determines if any part of a particular block is on screen. The block in
    // question has its top-left corner at texel and is size texels wide and
    // high.
    bool texelAreaVisible(Vector texel, int size) const
    {
        // Most blocks are visible, so do a quick crude visibility check first.
        // See if any part of the block is inside the inner bounding box.
        if (texel.x + size > _innerTopLeft.x &&
            texel.y + size > _innerTopLeft.y &&
            texel.x < _innerBottomRight.x &&
            texel.y < _innerBottomRight.y)
            return true;

        // See if any of the corners of the block are on the screen.
        if (texelVisible(texel))
            return true;
        texel.x += size;
        if (texelVisible(texel))
            return true;
        texel.y += size;
        if (texelVisible(texel))
            return true;
        texel.x -= size;
        if (texelVisible(texel))
            return true;
        texel.y -= size;

        // See if any of the corners of the screen are in the block.
        Vector pixel(0, 0);
        if (pixelInBlock(pixel, texel, size))
            return true;
        pixel.x += _pixelsPerScreen.x;
        if (pixelInBlock(pixel, texel, size))
            return true;
        pixel.y += _pixelsPerScreen.y;
        if (pixelInBlock(pixel, texel, size))
            return true;
        pixel.x -= _pixelsPerScreen.x;
        if (pixelInBlock(pixel, texel, size))
            return true;

        return false;
    }

    int precisionForLeaf(int logPointsPerLeaf)
    {
        int logUnitsPerLeaf = logPointsPerLeaf + _logUnitsPerTexel
            - _logPointsPerTexel;
        return ((intBits - logUnitsPerLeaf) + bitsPerDigit - 1) >>
            logBitsPerDigit;
    }

private:
    // Sometimes we'll try to plot a block that is smaller than a texel. This
    // should be a nop unless the block is in the top-left corner of the texel.
    bool plottable(BlockLocation location)
    {
        return (location._logPoints >= _logPointsPerTexel ||
            (location._topLeft&((1<<(_logPointsPerTexel)) - 1)) ==
            Vector(0, 0));
    }

    int texelsFromLogPoints(int logPoints) const
    {
        return 1<<max(logPoints - _logPointsPerTexel, 0);
    }

    // The point corresponding to a particular texel
    Vector pointFromTexel(Vector texel) const
    {
        return (texel - _matrixOrigin)<<_logPointsPerTexel;
    }

    // The texel corresponding to a particular matrix point (for plotting
    // purposes).
    Vector texelFromPoint(Vector point) const
    {
        return _matrixOrigin + (point>>_logPointsPerTexel);
    }

    void cFromTexel(Vector2<float> texel, Digit* x, Digit* y, int precision)
    {
        fixedFromDouble(_temp, texel.x, _logUnitsPerTexel, _precision);
        add(_temp, _temp, _originUnitX, _precision);
        copy(x, precision, _temp, _precision);
        fixedFromDouble(_temp, texel.y, _logUnitsPerTexel, _precision);
        add(_temp, _temp, _originUnitY, _precision);
        copy(y, precision, _temp, _precision);
    }

    // The texel corresponding to a particular pixel
    Vector2<float> texelFromPixel(Vector2<float> pixel) const
    {
        return (pixel - _originPixel)*_rotor*_texelsPerPixel;
    }

    // Returns the complex number corresponding to a particular pixel. This is
    // used for finding the point to zoom into based on the mouse position.
    void setZoomUnitToPixel(Vector2<float> pixel)
    {
        cFromTexel(texelFromPixel(pixel), _zoomUnitX, _zoomUnitY, _precision);
    }

    // Whether or not a particular texel is on the screen
    bool texelVisible(Vector texel) const
    {
        return Vector2Cast<int>(pixelFromTexel(texel)).
            inside(_pixelsPerScreen);
    }

    // Perform matrix expansion on zoom out
    void expandMatrix(Vector towerBottomRight)
    {
        // Bottom-right texel of the tile grid.
        do {
            // See if we need to expand in any direction
            bool expandLeft = -_matrixOrigin.x <
                0x00000000>>_logPointsPerTexel;
            bool expandUp = -_matrixOrigin.y < 0x00000000>>_logPointsPerTexel;
            bool expandRight = towerBottomRight.x - _matrixOrigin.x >
                (0x40000000>>_logPointsPerTexel);
            bool expandDown = towerBottomRight.y - _matrixOrigin.y >
                (0x40000000>>_logPointsPerTexel);

            if (expandUp && !expandLeft)
                expandRight = true;
            if (expandDown && !expandRight)
                expandLeft = true;
            if (!expandLeft && !expandRight)
                break;
            Vector quadrant(0, 0);
            if (expandLeft)
                quadrant.x = 1;
            if (expandUp)
                quadrant.y = 1;
            _matrixOrigin -= quadrant<<(30 - _logPointsPerTexel);
            --_logPointsPerTexel;
            _processor->queue()->growMatrix();
            _processor->dispatcher()->growMatrix(quadrant);
            _matrix->grow(quadrant);
        } while (true);
    }

    void update(bool initializing)
    {
        // Compute scale factors.
        double logUnitsPerScreen = -_logScreensPerUnit.toDouble();
        double logPixelsPerScreen =
            log(sqrt(static_cast<double>(_pixelsPerScreen.modulus2())))/
            log(2.0);
        double logUnitsPerPixel = logUnitsPerScreen - logPixelsPerScreen;

        // Update pixel conversion factors to convert between pixels and
        // texels.
        _texelsPerPixel = static_cast<float>(
            exp((logUnitsPerPixel - _logUnitsPerTexel)*log(2.0)));
        _rotor = Rotor2<float>(static_cast<float>(_angle.toDouble()));

        Vector2<double> zoomTexel;
        sub(_temp, _originUnitX, _zoomUnitX, _precision);
        zoomTexel.x = doubleFromFixed(_temp, _logUnitsPerTexel, _precision);
        sub(_temp, _originUnitY, _zoomUnitY, _precision);
        zoomTexel.y = doubleFromFixed(_temp, _logUnitsPerTexel, _precision);

        _originPixel = Vector2Cast<float>(_zoomPixel) +
            Vector2Cast<float>(zoomTexel/_texelsPerPixel)/_rotor;

        // Find the corners of the new window in old texels.
        Vector a = Vector2Cast<int>(texelFromPixel(
            Vector2Cast<float>(0, 0)));
        Vector b = Vector2Cast<int>(texelFromPixel(
            Vector2Cast<float>(_pixelsPerScreen.x, 0)));
        Vector c = Vector2Cast<int>(texelFromPixel(
            Vector2Cast<float>(_pixelsPerScreen)));
        Vector d = Vector2Cast<int>(texelFromPixel(
            Vector2Cast<float>(0, _pixelsPerScreen.y)));
        // From these, compute the bounding boxes in old texels.
        int x[4]; x[0] = a.x; x[1] = b.x; x[2] = c.x; x[3] = d.x;
        int y[4]; y[0] = a.y; y[1] = b.y; y[2] = c.y; y[3] = d.y;
        std::sort(&x[0], &x[4]);
        std::sort(&y[0], &y[4]);
        Vector towerTopLeft = Vector(x[0], y[0]);
        _innerTopLeft = Vector2<int>(x[1], y[1]);
        _innerBottomRight = Vector2<int>(x[2], y[2]);
        Vector towerBottomRight = Vector(x[3], y[3]);

        // Do zoom-ins. These do not affect the texel origin but do change the
        // scale factors.
        while (_texelsPerPixel < (1<<_logTilesPerTower)) {
            --_logPointsPerTexel;
            _matrix->splitMultiTileLeaves();
            _towerGrid->split();
            towerTopLeft <<= 1;
            _innerTopLeft <<= 1;
            _innerBottomRight <<= 1;
            towerBottomRight <<= 1;
            _matrixOrigin <<= 1;
            --_logUnitsPerTexel;
            ensureLengths();
            _texelsPerPixel *= 2.0;
        }

        int texelsPerTower = 1 << _logTexelsPerTower;
        int mask = texelsPerTower - 1;

        // Do zoom-outs. These do affect the texel origin as well as the scale
        // factors, because we need to keep the matrix origin at a tower
        // boundary.
        while (_texelsPerPixel >= (1<<(_logTilesPerTower + 1))) {
            // Amount by which we shift in order to keep the matrix origin at
            // a tower corner.
            Vector offset = (_matrixOrigin >> _logTexelsPerTower)&1;
            _towerGrid->combine(offset);
            ++_logPointsPerTexel;
            _matrix->scheduleConsolidateSmallLeaves();
            _processor->setInterrupted();
            offset <<= _logTexelsPerTower;
            _matrixOrigin = (_matrixOrigin + offset) >> 1;
            towerTopLeft = (towerTopLeft + offset)>>1;
            _innerTopLeft = (_innerTopLeft + offset)>>1;
            _innerBottomRight = (_innerBottomRight + offset)>>1;
            towerBottomRight = (towerBottomRight + offset)>>1;
            fixedFromDouble(_temp, static_cast<double>(offset.x),
                _logUnitsPerTexel, _precision);
            sub(_originUnitX, _originUnitX, _temp, _precision);
            fixedFromDouble(_temp, static_cast<double>(offset.y),
                _logUnitsPerTexel, _precision);
            sub(_originUnitY, _originUnitY, _temp, _precision);
            _originPixel -= Vector2Cast<float>(offset)/_texelsPerPixel/_rotor;
            ++_logUnitsPerTexel;
            ensureLengths();
            _texelsPerPixel /= 2.0;
            if (_texelsPerPixel >= (1<<(_logTilesPerTower + 1)))
                expandMatrix(_towerGrid->size()<<_logTexelsPerTower);  // TODO: Is this correct?
        }

        // Extend the grid boundaries to tower corners.
        towerTopLeft &= ~mask;
        towerBottomRight = (towerBottomRight + mask)&~mask;

        // Adjust for changed top-left tower.
        _towerGrid->move(towerTopLeft>>_logTexelsPerTower,
            towerBottomRight>>_logTexelsPerTower);

        _matrixOrigin -= towerTopLeft;
        _originPixel +=
            Vector2Cast<float>(towerTopLeft)/_texelsPerPixel/_rotor;
        towerBottomRight -= towerTopLeft;
        _innerTopLeft -= towerTopLeft;
        _innerBottomRight -= towerTopLeft;
        fixedFromDouble(_temp, static_cast<double>(towerTopLeft.x),
            _logUnitsPerTexel, _precision);
        add(_originUnitX, _originUnitX, _temp, _precision);
        fixedFromDouble(_temp, static_cast<double>(towerTopLeft.y),
            _logUnitsPerTexel, _precision);
        add(_originUnitY, _originUnitY, _temp, _precision);

        // Make the matrix cover an extra tower width down and right. Leaves in
        // this region won't be plotted but their existence prevents lines of
        // very small tiles on the bottom and right edges of the matrix if
        // these edges are close to the edges of the screen.
        towerBottomRight += Vector(texelsPerTower, texelsPerTower);

        expandMatrix(towerBottomRight);

        // Perform matrix shrinking on zoom in
        do {
            Vector tl = pointFromTexel(Vector(0, 0)) >> 28;
            Vector br = pointFromTexel(towerBottomRight) >> 28;
            br.x = min(br.x, 3);
            br.y = min(br.y, 3);
            if (tl.x == br.x)
                if (br.x == 3)
                    --tl.x;
                else
                    ++br.x;
            if (tl.y == br.y)
                if (br.y == 3)
                    --tl.y;
                else
                    ++br.y;
            if (br-tl == Vector(1, 1)) {
                _matrixOrigin += tl<<(28 - _logPointsPerTexel);
                ++_logPointsPerTexel;
                _matrix->shrink(tl);
                _processor->dispatcher()->shrinkMatrix(tl);
                _processor->queue()->shrinkMatrix();
            }
            else
                break;
        } while (true);

        if (!initializing) {
            // Update the tile grid.
            _towerGrid->update();
            _matrix->scheduleConsolidateOffScreenLeaves();
            _processor->setInterrupted();

            // Even a tiny change may cause some more blocks to become visible
            // and therefore split, so we need to be sure that we check. Call
            // setProgressed() in order to attempt to split if there's nothing
            // else to do.
            _processor->splitNeeded();
        }
    }

    void ensureLengths()
    {
        int precision = ((intBits - _logUnitsPerTexel) + bitsPerDigit - 1)
            >> logBitsPerDigit;
        if (precision == _precision)
            return;
        _originUnitX.ensureLength(precision);
        _originUnitY.ensureLength(precision);
        _zoomUnitX.ensureLength(precision);
        _zoomUnitY.ensureLength(precision);
        _temp.ensureLength(precision);
        copy(_originUnitX, precision, _originUnitX, _precision);
        copy(_originUnitY, precision, _originUnitY, _precision);
        copy(_zoomUnitX, precision, _zoomUnitX, _precision);
        copy(_zoomUnitY, precision, _zoomUnitY, _precision);
        _precision = precision;
    }

    // Determines if a pixel is inside a square, given the texel coordinates of
    // the top left of the square and the size of the square in texels.
    bool pixelInBlock(Vector pixel, Vector topLeft, int size) const
    {
        return (Vector2Cast<int>(texelFromPixel(Vector2Cast<float>(pixel))) -
            topLeft).inside(Vector(size, size));
    }

    FractalProcessor* _processor;
    TowerGrid<Screen>* _towerGrid;
    Matrix* _matrix;

    int _logTexelsPerTile;
    int _logTilesPerTower;
    int _logTexelsPerTower;

    // Screen size in pixels
    Vector _pixelsPerScreen;

    // Rotation angle (from window).
    Fix16p16 _angle;

    // Zoom level (from window). Increasing this by one is equivalent to
    // zooming in by a factor of two.
    Fix16p16 _logScreensPerUnit;

    // Zoom pixel (from window).
    Vector2<float> _zoomPixel;

    // Complex number corresponding to _zoomPixel.
    DigitBuffer _zoomUnitX;
    DigitBuffer _zoomUnitY;

    // Conversion between texel coordinates and complex numbers
    DigitBuffer _originUnitX;
    DigitBuffer _originUnitY; // complex number at the origin texel
    int _logUnitsPerTexel;

    // Conversion between matrix coordinates and texel coordinates
    int _logPointsPerTexel;
    Vector _matrixOrigin;  // texel coordinates of the matrix origin

    // Conversion between texel coordinates and pixel coordinates
    float _texelsPerPixel;
    Vector2<float> _originPixel;  // Pixel coordinates of the origin texel
    Rotor2<float> _rotor;

    // Texel coordinates of the inner bounding box of the screen.
    Vector _innerTopLeft;
    Vector _innerBottomRight;

    int _precision;
    DigitBuffer _temp;
};


// Window mixin that gives a window the capability to zoom in and out and pan
// using the mouse and rotate using the Z and X keys.
template<class Base, class FractalProcessor> class ZoomingRotatingWindow
  : public Base, Uncopyable
{
public:
    class Params
    {
        friend class ZoomingRotatingWindow;
    public:
        Params(typename Base::Params bp, double minLogScreensPerUnit)
          : _bp(bp), _minLogScreensPerUnit(minLogScreensPerUnit) { }
    private:
        typename Base::Params _bp;
        double _minLogScreensPerUnit;
    };

    ZoomingRotatingWindow(Params p, FractalProcessor* processor)
      : Base(p._bp),
        _zoomPosition(0,0),
        _lButton(false),
        _rButton(false),
        _mButton(false),
        _zButton(false),
        _xButton(false),
        _logScreensPerUnit(processor->logScreensPerUnit()),
        _minLogScreensPerUnit(p._minLogScreensPerUnit),
        _zoomVelocity(0),
        _maxZoomVelocity(1024/65536.0),
        _zoomAcceleration(64/65536.0),
        _angle(0),
        _angularVelocity(0),
        _maxAngularVelocity(256/65536.0),
        _angularAcceleration(16/65536.0),
        _processor(processor)
    { }

protected:
    virtual void doPaint(PaintHandle* paint)
    {
        _image->setInterrupt();
        Lock lock(_processor);
        _image->clearInterrupt();
        _image->beginScene();
        // Update the coordinates for the next frame.
        recalculateZoomRotate();
        Base::doPaint(paint);
        _image->endScene();
        _image->resume();
    }

    virtual LRESULT handleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        LRESULT result;
        switch (uMsg) {
            case WM_LBUTTONDOWN:
                {
                    _image->setInterrupt();
                    Lock lock(_processor);
                    _image->clearInterrupt();
                    buttonDown(&_lButton, lParam);
                    _image->resume();
                }
                break;
            case WM_LBUTTONUP:
                buttonUp(&_lButton);
                break;
            case WM_RBUTTONDOWN:
                {
                    _image->setInterrupt();
                    Lock lock(_processor);
                    _image->clearInterrupt();
                    buttonDown(&_rButton, lParam);
                    _image->resume();
                }
                break;
            case WM_RBUTTONUP:
                buttonUp(&_rButton);
                break;
            case WM_MBUTTONDOWN:
                {
                    _image->setInterrupt();
                    Lock lock(_processor);
                    _image->clearInterrupt();
                    recalculateRegion(); // Get a fresh _zoomUnit.
                    buttonDown(&_mButton, lParam);
                    _image->resume();
                }
                break;
            case WM_MBUTTONUP:
                buttonUp(&_mButton);
                break;
            case WM_MOUSEMOVE:
                {
                    _image->setInterrupt();
                    Lock lock(_processor);
                    _image->clearInterrupt();
                    zoomPos(VectorFromLParam(lParam));
                    _image->resume();
                }
                break;
            case WM_KILLFOCUS:
                _lButton = _rButton = _mButton = _zButton = _xButton = false;
                ReleaseCapture();
                break;
            case WM_KEYUP:
                if (wParam == 'Z')
                    _zButton = false;
                if (wParam == 'X')
                    _xButton = false;
                break;
            case WM_KEYDOWN:
                if (wParam == 'Z')
                    _zButton = true;
                if (wParam == 'X')
                    _xButton = true;
                break;
            case WM_SIZE:
                {
                    _image->setInterrupt();
                    Lock lock(_processor);
                    _image->clearInterrupt();
                    _image->beginScene();
                    result = Base::handleMessage(uMsg, wParam, lParam);
                    _image->endScene();
                    _image->resume();
                }
                return result;
        }

        return Base::handleMessage(uMsg, wParam, lParam);
    }

private:
    void buttonDown(bool* button, LPARAM lParam)
    {
        if (_lButton || _rButton || _mButton)
            zoomPos(VectorFromLParam(lParam));
        *button = true;
        if (_lButton || _rButton || _mButton)
            SetCapture(_hWnd);
    }
    void buttonUp(bool* button)
    {
        *button = false;
        if (!_lButton && !_rButton && !_mButton)
            ReleaseCapture();
    }

    // Recalculate the region - called whenever we zoom or pan.
    void recalculateRegion()
    {
        _image->
            zoomRotate(_logScreensPerUnit, _angle, _zoomPosition, _mButton);
    }

    // Recalculate the zoom level and (if necessary) the region
    void recalculateZoomRotate()
    {
        // Recalculate zoom
        if (!_lButton)
            if (!_rButton) {
                // No buttons pressed - slow to a stop
                if (_zoomVelocity > static_cast<Fix16p16>(0)) {
                    // Decelerate from zooming in
                    _zoomVelocity -= _zoomAcceleration;
                }
                if (_zoomVelocity < static_cast<Fix16p16>(0)) {
                    // Decelerate from zooming out
                    _zoomVelocity += _zoomAcceleration;
                }
            }
            else {
                // Right button pressed only - zoom out
                if (_zoomVelocity > -_maxZoomVelocity) {
                    // Accelerate to zoom out
                    _zoomVelocity -= _zoomAcceleration;
                }
            }
        else
            if (!_rButton) {
                // Left button pressed only - zoom in
                if (_zoomVelocity < _maxZoomVelocity) {
                    // Accelerate to zoom in
                    _zoomVelocity += _zoomAcceleration;
                }
            }
            else {
                // Both buttons pressed, keep same velocity
            }
        _logScreensPerUnit += _zoomVelocity;
        _logScreensPerUnit = max(_logScreensPerUnit, _minLogScreensPerUnit);
        wchar_t buffer[100];
        swprintf(buffer, 99, L"%lf", _logScreensPerUnit.toDouble());
        setText(buffer);

        // Recalculate rotation
        if (!_xButton)
            if (!_zButton) {
                // No buttons pressed - slow to a stop
                if (_angularVelocity > static_cast<Fix16p16>(0)) {
                    // Decelerate from rotating anticlockwise
                    _angularVelocity -= _angularAcceleration;
                }
                if (_angularVelocity < static_cast<Fix16p16>(0)) {
                    // Decelerate from rotating clockwise
                    _angularVelocity += _angularAcceleration;
                }
            }
            else {
                // Z button pressed only - rotate clockwise
                if (_angularVelocity > -_maxAngularVelocity) {
                    // Accelerate clockwise
                    _angularVelocity -= _angularAcceleration;
                }
            }
        else
            if (!_zButton) {
                // X button pressed only - rotate anticlockwise
                if (_angularVelocity < _maxAngularVelocity) {
                    // Accelerate anticlockwise
                    _angularVelocity += _angularAcceleration;
                }
            }
            else {
                // Both buttons pressed, keep same angular velocity
            }
        _angle += _angularVelocity;
        _angle &= _angle.frac();

        if (_angularVelocity != 0 || _zoomVelocity != 0 || _mButton)
            recalculateRegion();
    }

    // Change the zoom position. Called whenever the mouse is moved.
    void zoomPos(Vector s)
    {
        if (s == _zoomPosition)
            return;
        _zoomPosition = s;

        if (_mButton) {
            recalculateRegion();
            IF_ZERO_THROW(InvalidateRect(_hWnd, NULL, FALSE));
        }
    }

    Vector _zoomPosition;
    bool _lButton, _rButton, _mButton, _zButton, _xButton;
    Fix16p16 _logScreensPerUnit;
    Fix16p16 _minLogScreensPerUnit;
    Fix16p16 _zoomVelocity;
    Fix16p16 _maxZoomVelocity;
    Fix16p16 _zoomAcceleration;
    Fix16p16 _angle;
    Fix16p16 _angularVelocity;
    Fix16p16 _maxAngularVelocity;
    Fix16p16 _angularAcceleration;
    FractalProcessor* _processor;
};


template<class FractalProcessor> class Evaluator : Uncopyable
{
    typedef IncompleteLeaf<FractalProcessor> IncompleteLeaf;
public:
    Evaluator(FractalProcessor* processor)
      : _processor(processor)
    {
        _bailoutRadius2 = processor->getBailoutRadius2();
        _maximumIterations = _processor->maximumIterations();
    }

    // Updates the IncompleteLeaf after evaluation
    void updateLeaf(IncompleteLeaf* leaf) const
    {
        copy(leaf->number(0), _zx, _precision);
        copy(leaf->number(1), _zy, _precision);
        copy(leaf->number(2), _zSx, _precision);
        copy(leaf->number(3), _zSy, _precision);
        leaf->_iterations += _maximumIterations;
    }

    void initFromLeaf(IncompleteLeaf* leaf)
    {
        _precision = leaf->precision() + 1;
        _cx.ensureLength(_precision);
        _cy.ensureLength(_precision);
        _zx.ensureLength(_precision);
        _zy.ensureLength(_precision);
        _zSx.ensureLength(_precision);
        _zSy.ensureLength(_precision);
        copy(_zx, leaf->number(0), _precision);
        copy(_zy, leaf->number(1), _precision);
        copy(_zSx, leaf->number(2), _precision);
        copy(_zSy, leaf->number(3), _precision);
    }

    void setLogDelta(int logDelta) { _logDelta = logDelta; }

    int result() const { return _result; }

    Digit* cx() { return _cx; }
    Digit* cy() { return _cy; }
    int precision() const { return _precision; }

protected:
    FractalProcessor* _processor;

    int _logDelta;
    DigitBuffer _cx;
    DigitBuffer _cy;
    DigitBuffer _zx;
    DigitBuffer _zy;
    DigitBuffer _zSx;
    DigitBuffer _zSy;
    int _precision;
    int _maximumIterations;
    double _bailoutRadius2;
    int _result;
};

template<class FractalProcessor> class MandelbrotEvaluator
  : public Evaluator<FractalProcessor>
{
public:
    MandelbrotEvaluator(FractalProcessor* processor)
      : Evaluator(processor)
    { }

    void iterate()
    {
        if (_precision <= 2)
            doubleIterate();
        else
            longFixedIterate();
    }

    bool inSet()
    {
        if (_precision <= 2)
            return doubleInSet();
        return longFixedInSet();
    }

    void doubleIterate()
    {
        Complex<double> z;
        z.x = doubleFromFixed(_zx, 0, _precision);
        z.y = doubleFromFixed(_zy, 0, _precision);
        Complex<double> zS;
        zS.x = doubleFromFixed(_zSx, 0, _precision);
        zS.y = doubleFromFixed(_zSy, 0, _precision);
        Complex<double> c;
        c.x = doubleFromFixed(_cx, 0, _precision);
        c.y = doubleFromFixed(_cy, 0, _precision);
        int maximumIterations = _maximumIterations;
        double delta = ldexp(1.0, _logDelta);
        double bailoutRadius2 = _bailoutRadius2;
        for (int i = 0; i < maximumIterations; i += 2) {
            double zr2 = z.x*z.x;
            double zi2 = z.y*z.y;
            z = Complex<double>(zr2 - zi2 + c.x, 2*z.x*z.y + c.y);
            if (zr2 + zi2 > bailoutRadius2) {
                _result = i + 1;
                return;
            }

            zr2 = z.x*z.x;
            zi2 = z.y*z.y;
            z = Complex<double>(zr2 - zi2 + c.x, 2*z.x*z.y + c.y);
            if (zr2 + zi2 > bailoutRadius2) {
                _result = i + 2;
                return;
            }

            zr2 = zS.x*zS.x;
            zi2 = zS.y*zS.y;
            zS = Complex<double>(zr2 - zi2 + c.x, 2*zS.x*zS.y + c.y);
            Complex<double> d = z - zS;
            if (abs(d.x) < delta && abs(d.y) < delta) {
                _result = -(i + 2);
                return;
            }
        }
        fixedFromDouble(_zx, z.x, 0, _precision);
        fixedFromDouble(_zy, z.y, 0, _precision);
        fixedFromDouble(_zSx, zS.x, 0, _precision);
        fixedFromDouble(_zSy, zS.y, 0, _precision);
        _result = -1;
    }

    bool doubleInSet()
    {
        Complex<double> c;
        c.x = doubleFromFixed(_cx, 0, _precision);
        c.y = doubleFromFixed(_cy, 0, _precision);
        double r2 = c.modulus2();
        double x = c.x;
        // In the following two tests, equality also means that the point is in
        // the set given infinite precision, however the finite precision of
        // doubles gives some false positives around the cusp area.
        if (r2*(8*r2 - 3) < 3.0/32 - x)
            return true;
        return r2 + 2*x + 1 < 1.0/16;
    }

    void longFixedIterate()
    {
        int p = _precision;
        ensureLengths();
        SignedDigit bailoutRadius2 = static_cast<SignedDigit>(
            ldexp(_bailoutRadius2, bitsPerDigit - intBits));
        fixedFromDouble(_t[3], 1.0, _logDelta, p);
        int maximumIterations = _maximumIterations;
        for (int i = 0; i < maximumIterations; i += 2) {
            multiply(_t[0], _zx, _zx, _t[4], p);
            multiply(_t[1], _zy, _zy, _t[4], p);
            add(_t[2], _t[0], _t[1], p);
            if (static_cast<SignedDigit>(_t[2][p - 1]) > bailoutRadius2) {
                _result = i + 1;
                return;
            }
            multiply(_t[2], _zx, _zy, _t[4], p, intBits + 1);
            add(_zx, _t[0], _cx, p);
            sub(_zx, _zx, _t[1], p);
            add(_zy, _t[2], _cy, p);

            multiply(_t[0], _zx, _zx, _t[4], p);
            multiply(_t[1], _zy, _zy, _t[4], p);
            add(_t[2], _t[0], _t[1], p);
            if (static_cast<SignedDigit>(_t[2][p - 1]) > bailoutRadius2) {
                _result = i + 2;
                return;
            }
            multiply(_t[2], _zx, _zy, _t[4], p, intBits + 1);
            add(_zx, _t[0], _cx, p);
            sub(_zx, _zx, _t[1], p);
            add(_zy, _t[2], _cy, p);

            multiply(_t[0], _zSx, _zSx, _t[4], p);
            multiply(_t[1], _zSy, _zSy, _t[4], p);
            multiply(_t[2], _zSx, _zSy, _t[4], p, intBits + 1);
            add(_zSx, _t[0], _cx, p);
            sub(_zSx, _zSx, _t[1], p);
            add(_zSy, _t[2], _cy, p);
            sub(_t[0], _zSx, _zx, p);
            abs(_t[0], _t[0], p);
            if (lessThan(_t[0], _t[3], p)) {
                sub(_t[0], _zSy, _zy, p);
                abs(_t[0], _t[0], p);
                if (lessThan(_t[0], _t[3], p)) {
                    _result = -(i + 2);
                    return;
                }
            }
        }
        _result = -1;
    }

    bool longFixedInSet()
    {
        int p = _precision;
        ensureLengths();
        multiply(_t[0], _cx, _cx, _t[4], p);       // _cx*_cx
        multiply(_t[1], _cy, _cy, _t[4], p);       // _cy*_cy
        add(_t[0], _t[0], _t[1], p);               // r2
        if (static_cast<SignedDigit>(_t[0][p - 1]) >
            4<<(bitsPerDigit - intBits))
            return false;
        shiftLeft(_t[1], _t[0], p, 3);             // 8*r2
        _t[1][p - 1] -= 3<<(bitsPerDigit - intBits); // 8*r2 - 3
        multiply(_t[2], _t[1], _t[0], _t[4], p);   // r2*(8*r2 - 3)
        _t[2][p - 1] -= 3<<(bitsPerDigit - intBits - 5);
                                                   // r2*(8*r2 - 3) - 3.0/32
        add(_t[2], _t[2], _cx, p);                // r2*(8*r2 - 3) + x - 3.0/32
        if (lessThanZero(_t[2], p))
            return true;
        shiftLeft(_t[1], _cx, p, 1);               // 2*x
        _t[1][p - 1] += 15<<(bitsPerDigit - intBits - 4); // 2*x + 15/16.0
        add(_t[0], _t[0], _t[1], p);               // r2 + 2*x + 15/16.0
        if (lessThanZero(_t[0], p))
            return true;
        return false;
    }
private:
    void ensureLengths()
    {
        _buffer.ensureLength(8*_precision);
        Digit* t = _buffer;
        for (int i = 0; i < 5; ++i) {
            _t[i] = t;
            t += _precision;
        }
    }

    DigitBuffer _buffer;
    Digit* _t[5];
};


template<class FractalProcessor, class Evaluator> class FractalThread
  : public Thread
{
    typedef IncompleteLeaf<FractalProcessor> IncompleteLeaf;
    typedef Manipulator<FractalProcessor> Manipulator;
    typedef WorkQueueList<FractalProcessor> WorkQueueList;
public:
    FractalThread(FractalProcessor* processor)
      : _ending(false),
        _failed(false),
        _processor(processor),
        _evaluator(processor),
        _running(false)
    {
        _screen = processor->screen();
        _matrix = processor->matrix();
        _queue = processor->queue();
    }

    // Signals the thread to come to an end.
    void end() { _ending = true; _ready.signal(); }

    // Rethrow the exception on the main thread if it failed.
    void check()
    {
        if (_failed)
            throw _exception;
    }

    // Start the thread.
    void go()
    {
        _ready.signal();
    }

    HANDLE finishedHandle() { return _finished; }

    void growMatrix(Vector quadrant)
    {
        Vector point(int(_point.x), int(_point.y));
        if ((point& 1) != Vector(0, 0))
            _pointValid = false;
        point = (point>>1) | (quadrant<<29);
        _point.x = point.x;
        _point.y = point.y;
    }

    void shrinkMatrix(Vector semiQuadrant)
    {
        Vector point(int(_point.x), int(_point.y));
        point = (point<<1) + (semiQuadrant<<28);
        if ((point & 0xc0000000) != Vector(0, 0))
            _pointValid = false;
        _point.x = point.x;
        _point.y = point.y;
    }

    bool running() const { return _running; }

private:
    void postEvaluationProcessing()
    {
        int result = _evaluator.result();
        _processor->addIterations(
            result == -1 ? _processor->maximumIterations() : abs(result));

        // The block may have moved elsewhere while we were iterating due
        // to another thread completing an adjacent block. So, re-find the
        // block by point coordinates again and make sure it's still
        // incomplete.
        if (!_pointValid) {
            // Matrix was grown or shrunk and this point didn't make the
            // cut (or we haven't done anything yet).
            return;
        }
        _pointValid = false;
        Vector point(int(_point.x), int(_point.y));
        Manipulator* manipulator = _matrix->manipulator(point);
        if (manipulator->isComplete()) {
            // This point got moved to a new IncompletePoint* and the other
            // thread got to it first.
            return;
        }
        if (manipulator->topLeft() != point) {
            // This point was consolidated away.
            return;
        }
        IncompleteLeaf* leaf = manipulator->incompleteLeaf();
        if (leaf->_iterations != _iterations) {
            // Some other thread got to it before us.
            return;
        }
        if (result < -1) {
            // Point was found to be periodic.
            manipulator->complete(0);
            return;
        }
        if (result == -1) {
            // Leaf is still undecided after the maximum number of iterations
            // were completed.
            _evaluator.updateLeaf(leaf);
            if (leaf->_iterations > leaf->_colour)
                manipulator->plot(0);
            return;
        }
        // Point escaped.
        manipulator->complete(result + _iterations);
    }

    // Returns true if we ran out of work to do.
    bool preEvaluationProcessing()
    {
        if (_processor->interrupted()) {
            _processor->clearInterrupted();
            if (!_matrix->resume()) {
                _processor->setInterrupted();
                return true;
            }
        }

        IncompleteLeaf* leaf = _processor->getNextLeaf();
        if (leaf == 0)
            return true;
        Manipulator* manipulator = _matrix->manipulator(leaf);
        if (manipulator->isDeleted())
            return false;
        _processor->splitNeeded();
        Vector point = manipulator->topLeft();
        _point.x = point.x;
        _point.y = point.y;
        _evaluator.initFromLeaf(leaf);
        _screen->initEvaluatorWithPoint(&_evaluator, point);
        _iterations = leaf->_iterations;
        if (_iterations == 0 && _evaluator.inSet()) {
            manipulator->complete(0);
            return false;
        }
        _pointValid = true;
        return false;
    }

    void threadProc()
    {
        BEGIN_CHECKED {
            do {
                _pointValid = false;
                _ready.wait();
                do {
                    {
                        Lock lock(_processor);
                        _running = true;
                        postEvaluationProcessing();
                        if (_ending) {
                            _running = false;
                            break;
                        }
                        if (preEvaluationProcessing()) {
                            _running = false;
                            break;
                        }
                    }
                    _evaluator.iterate();
                } while (true);
                _finished.signal();
            } while (!_ending);
        } END_CHECKED(Exception& e) {
            _exception = e;
            _failed = true;
            _finished.signal();
        }
    }

    Exception _exception;
    volatile bool _failed;
    volatile bool _ending;
    volatile bool _running;
    Event _ready;    // Set by UI thread to trigger this thread to start.
    Event _finished; // Set by this thread to tell the UI thread we're done.
    Evaluator _evaluator;

    volatile Vector _point;
    volatile bool _pointValid;
    FractalProcessor* _processor;
    Screen<FractalProcessor>* _screen;
    Matrix<FractalProcessor>* _matrix;
    WorkQueueList* _queue;

    unsigned int _iterations;
};


template<class FractalProcessor> class WorkQueueList : Uncopyable
{
    typedef IncompleteLeaf<FractalProcessor> IncompleteLeaf;

    class WorkQueue : Uncopyable
    {
    public:
        WorkQueue()
          : _next(0)
        { }

        void add(IncompleteLeaf* leaf)
        {
            _list.add(leaf);
            if (_next == 0)
                _next = leaf;
        }

        void remove(IncompleteLeaf* leaf)
        {
            if (leaf == _next)
                increment();
            leaf->remove();
        }

        IncompleteLeaf* get()
        {
            IncompleteLeaf* leaf = _next;
            if (_next != 0)
                increment();
            return leaf;
        }

        void reseatLeaf(IncompleteLeaf* oldLeaf, IncompleteLeaf* newLeaf)
        {
            if (_next == oldLeaf)
                _next = newLeaf;
        }

        void reset() { _next = _list.getNext(); }
        bool empty() const { return _list.empty(); }

    private:
        void increment() { _next = _list.getNext(_next); }

        LinkedList<IncompleteLeaf> _list;
        IncompleteLeaf* _next;
    };

public:
    WorkQueueList()
      : _n(0), _current(0), _offset(0)
    { }

    void setProcessor(FractalProcessor* processor)
    {
        _processor = processor;
        reset();
    }

    void add(IncompleteLeaf* leaf, int logPointsPerLeaf)
    {
        if (_n == 0)
            _offset = logPointsPerLeaf;
        int queue = logPointsPerLeaf - _offset;
        while (queue < 0) {
            _queues.insert(_queues.begin(), static_cast<WorkQueue*>(0));
            _queues[0] = new WorkQueue();
            ++queue;
            ++_n;
            --_offset;
            ++_current;
        }
        while (queue >= _n) {
            _queues.push_back(new WorkQueue());
            ++_n;
        }
        _queues[queue]->add(leaf);
        if (queue > _current)
            _current = queue;
    }

    void remove(IncompleteLeaf* leaf, int logPointsPerLeaf)
    {
        int queue = logPointsPerLeaf - _offset;
        _queues[queue]->remove(leaf);
        if (queue == 0)
            while (_n > 0 && _queues[queue]->empty()) {
                delete _queues[0];
                _queues.erase(_queues.begin());
                ++_offset;
                --_n;
                --_current;
            }
        else
            if (queue == _n - 1)
                while (_n > 0 && _queues[_n - 1]->empty()) {
                    delete _queues[_n - 1];
                    _queues.pop_back();
                    --_n;
                    if (_current == _n)
                        --_current;
                }
    }

    void reseatLeaf(IncompleteLeaf* oldLeaf, IncompleteLeaf* newLeaf,
        int logPointsPerLeaf)
    {
        _queues[logPointsPerLeaf - _offset]->reseatLeaf(oldLeaf, newLeaf);
    }

    IncompleteLeaf* get()
    {
        while (!atEnd()) {
            IncompleteLeaf* leaf = _queues[_current]->get();
            if (leaf != 0)
                return leaf;
            _queues[_current]->reset();
            --_current;
        }
        return 0;
    }

    void reset() { _current = _n - 1; }
    bool atEnd() const { return _current < 0; }
    void growMatrix() { --_offset; }
    void shrinkMatrix() { ++_offset; }

    ~WorkQueueList()
    {
        for (int i = 0; i < _n; ++i) {
            WorkQueue* queue = _queues[i];
            if (queue != 0)
                delete queue;
        }
    }
private:
    int _n;
    FractalProcessor* _processor;
    std::vector<WorkQueue*> _queues;
    int _current;
    int _offset;
};


template<class FractalProcessor, class Thread> class Dispatcher
  : public IdleProcessor, Uncopyable
{
public:
    Dispatcher() : _nThreads(0) { }

    void setProcessor(FractalProcessor* processor)
    {
        _processor = processor;

        // Count available threads
        DWORD_PTR pam, sam;
        IF_ZERO_THROW(GetProcessAffinityMask(GetCurrentProcess(), &pam, &sam));
        for (DWORD_PTR p = 1; p != 0; p <<= 1)
            if ((pam&p) != 0)
                ++_nThreads;

        _threads.resize(_nThreads, 0);
        _threadHandles.resize(_nThreads);
        for (int i = 0; i < _nThreads; ++i) {
            Thread* thread = new Thread(_processor);
            thread->setPriority(THREAD_PRIORITY_BELOW_NORMAL);
            _threads[i] = thread;
            _threadHandles[i] = thread->finishedHandle();
            thread->start();
        }
    }

    ~Dispatcher()
    {
        // Tell the threads to stop what they're doing.
        for (int i = 0; i < _nThreads; ++i) {
            Thread* thread = _threads[i];
            if (thread != 0)
                thread->end();
        }
        // Wait for them all to actually stop and delete them. Don't rethrow
        // any exceptions here.
        for (int i = 0; i < _nThreads; ++i) {
            Thread* thread = _threads[i];
            if (thread != 0) {
                thread->join();
                delete thread;
            }
        }
    }

    void resume()
    {
        for (int i = 0; i < _nThreads; ++i) {
            Thread* thread = _threads[i];
            if (!thread->running())
                thread->go();
        }
    }

    // IdleProcessor function - called in the message loop when there are no
    // more messages to process.
    void idle()
    {
        bool gotMessage = false;

        do {
            // Wait until either one of the threads stops or we get a message.
            DWORD raisedEvent = MsgWaitForMultipleObjects(_nThreads,
                &_threadHandles[0], FALSE, INFINITE, QS_ALLINPUT);
            if (raisedEvent < WAIT_OBJECT_0 + _nThreads) {
                int thread = raisedEvent - WAIT_OBJECT_0;
                _threads[thread]->check();
                // A thread stopped because it had nothing to do.
            }
            else
                gotMessage = true;
        } while (!gotMessage);
    }

    void growMatrix(Vector semiQuadrant)
    {
        for (int i = 0; i < _nThreads; ++i)
            _threads[i]->growMatrix(semiQuadrant);
    }

    void shrinkMatrix(Vector semiQuadrant)
    {
        for (int i = 0; i < _nThreads; ++i)
            _threads[i]->shrinkMatrix(semiQuadrant);
    }

private:
    FractalProcessor* _processor;
    std::vector<HANDLE> _threadHandles;
    int _nThreads;
    std::vector<Thread*> _threads;
};


template<class FractalProcessor> class MemoryTracker
{
    typedef Allocator<FractalProcessor> Allocator;
    typedef Grid<FractalProcessor> Grid;
    typedef IncompleteLeaf<FractalProcessor> IncompleteLeaf;
    typedef GridType<FractalProcessor> GridType;
public:
    MemoryTracker()
    {
        // Set a limit on how much memory we allocate (80% of physical RAM).
        // Because we're continually touching all our memory, allocating too
        // much causes everything else to get swapped out, and Windows becomes
        // unbearably slow.
        MEMORYSTATUSEX ms;
        ms.dwLength = sizeof(MEMORYSTATUSEX);
        GlobalMemoryStatusEx(&ms);
        if (ms.ullTotalPhys >= 0xa0000000ull)
            _memoryLimit = 0x80000000;
        else
            _memoryLimit = static_cast<size_t>((ms.ullTotalPhys / 5) * 4);
        _memoryUsed = 0;
    }

    void setProcessor(FractalProcessor* processor)
    {
        _processor = processor;
        _allocator.setProcessor(processor);
        for (BlockType t = gridBlockType; t != lastBlockType;
            t = static_cast<BlockType>(static_cast<int>(t) + 1))
            for (int i = 0; i < 16; ++i)
                for (int p = 0; p < 3; ++p)
                    _heap[t][i][p] =
                        _allocator.heapForSize(GridType(i, t, p, 0).bytes());
    }

    bool canAllocate() const { return _memoryUsed < _memoryLimit; }
    void adjustMemory(int bytes) { _memoryUsed += bytes; }

    typename Allocator::Heap* heapForType(GridType gridType)
    {
        if (gridType._precision < 4)
            return _heap[gridType._blockType][gridType._logBlocks]
                [gridType._precision];
        return _allocator.heapForSize(gridType.bytes());
    }


    Grid* allocateGrid(GridType gridType)
    {
        Grid* grid = heapForType(gridType)->allocate<Grid>();
        if (grid == 0)
            throw std::bad_alloc();
        return grid;
    }

    void deallocateGrid(Grid* grid)
    {
        heapForType(grid->_gridType)->deallocate(grid);
    }

    void reseatLeaf(IncompleteLeaf* oldLeaf, IncompleteLeaf* newLeaf,
        int logPointsPerLeaf)
    {
        _processor->queue()->reseatLeaf(oldLeaf, newLeaf, logPointsPerLeaf);
    }

private:
    FractalProcessor* _processor;
    Allocator _allocator;
    typename Allocator::Heap* _heap[lastBlockType][16][3];
    size_t _memoryLimit;
    size_t _memoryUsed;
};


class FractalProcessor : public Mutex
{
    typedef MandelbrotEvaluator<FractalProcessor> MandelbrotEvaluator;
    typedef FractalThread<FractalProcessor, MandelbrotEvaluator> FractalThread;
    typedef IncompleteLeaf<FractalProcessor> IncompleteLeaf;
    typedef Matrix<FractalProcessor> Matrix;
    typedef Screen<FractalProcessor> Screen;
    typedef WorkQueueList<FractalProcessor> WorkQueueList;
    typedef Dispatcher<FractalProcessor, FractalThread> Dispatcher;
    typedef MemoryTracker<FractalProcessor> MemoryTracker;
    typedef TowerGrid<Screen> TowerGrid;
    typedef GridRenderer<Screen> GridRenderer;
public:
    FractalProcessor(Complex<double> centre, float logScreensPerUnit,
        GridRenderer* renderer)
      : _towerGrid(renderer, &_screen),
        _renderer(renderer),
        _logScreensPerUnit(logScreensPerUnit),
        _iterations(0),
        _iterationsPerSecond(0.0f),
        _splitNeeded(false),
        _leavesInQueue(false),
        _interrupted(false)
    {
        // Link up objects
        _screen.setProcessor(this);
        _tracker.setProcessor(this);
        _matrix.setProcessor(this);
        _queue.setProcessor(this);
        _dispatcher.setProcessor(this);
        _screen.setInitial(centre, logScreensPerUnit);
    }

    // Resume all the threads if there might be anything for them to do.
    void resume()
    {
        if (_splitNeeded || _leavesInQueue || _interrupted) {
            if (_leavesInQueue && _queue.atEnd()) {
                _queue.reset();
                _leavesInQueue = false;
            }
            _dispatcher.resume();
        }
    }

    void splitNeeded() { _splitNeeded = true; }
    void leavesInQueue() { _leavesInQueue = true; _splitNeeded = true; }
    void setInterrupted() { _interrupted = true; }
    void clearInterrupted() { _interrupted = false; }
    bool interrupted() { return _interrupted; }

    // Called by the worker threads to get data to work on.
    IncompleteLeaf* getNextLeaf()
    {
        if (_queue.atEnd()) {
            if (_leavesInQueue) {
                // We still have incomplete points. Do some more processing.
                resume();
            }
            else
                if (_splitNeeded) {
                    _splitNeeded = false;
                    _matrix.scheduleSplitLargeLeaves();
                    if (!_matrix.resume()) {
                        _interrupted = true;
                        return 0;
                    }
                    if (_leavesInQueue) {
                        // Some new incomplete points were created. Do some more
                        // processing.
                        resume();
                    }
                }
        }
        return _queue.get();
    }

    int maximumIterations() const { return 0x4000; }
    double getBailoutRadius2() const { return 16; }

    Matrix* matrix() { return &_matrix; }
    Screen* screen() { return &_screen; }
    TowerGrid* towerGrid() { return &_towerGrid; }
    WorkQueueList* queue() { return &_queue; }
    MemoryTracker* tracker() { return &_tracker; }
    Dispatcher* dispatcher() { return &_dispatcher; }
    float logScreensPerUnit() const { return _logScreensPerUnit; }
    void addIterations(int iterations) { _iterations += iterations; }

    float getIterationsPerSecond()
    {
        DWORD tickCount = GetTickCount();
        if (tickCount != _lastTickCount) {
            float ticks = static_cast<float>(tickCount - _lastTickCount);
            _lastTickCount = tickCount;
            static const float decayFactor = 0.0001f; // decay by e in 10 seconds.
            float decay = exp(-ticks*decayFactor);
            _iterationsPerSecond = _iterationsPerSecond*decay +
                1000.0f*_iterations*(1 - decay)/ticks;
            _iterations = 0;
        }
        return _iterationsPerSecond;
    }

private:
    float _logScreensPerUnit;
    WorkQueueList _queue;
    Screen _screen;
    TowerGrid _towerGrid;
    int _precision;
    int _derivatives;
    MemoryTracker _tracker;
    Matrix _matrix;
    Dispatcher _dispatcher;
    bool _leavesInQueue;
    bool _splitNeeded;
    bool _interrupted;
    GridRenderer* _renderer;

    // Statistics
    int _iterations;
    float _iterationsPerSecond;
    DWORD _lastTickCount;
};

class Program : public ProgramBase
{
public:
    void run()
    {
        COMInitializer ci;
        Direct3D direct3D;

        Device device;

        typedef Screen<FractalProcessor> Screen;
        GridRenderer<Screen> renderer(
            1,  // log(tiles per tower)
            8   // 256x256 is the optimal texture size
        );
        FractalProcessor processor(-0.5, -2.3, &renderer);

        Menu menu(IDR_MENU1);

        Window::Params wp(&_windows,
            L"Mandelbrot Set with grid tree - click to zoom",
            Vector(320, 240), &menu);
        typedef RootWindow<Window> RootWindow;
        RootWindow::Params rwp(wp);
        typedef TowerGrid<Screen> TowerGrid;
        typedef ImageWindow<RootWindow, TowerGrid> ImageWindow;
        ImageWindow::Params iwp(rwp, processor.towerGrid());
        typedef AnimatedWindow<ImageWindow> AnimatedWindow;
        AnimatedWindow::Params awp(iwp, 60);
        typedef ZoomingRotatingWindow<AnimatedWindow, FractalProcessor>
            ZoomingRotatingWindow;
        ZoomingRotatingWindow::Params zwp(awp, -2.3);
        ZoomingRotatingWindow window(zwp, &processor);

        device.create(&direct3D, &window);
        renderer.setDevice(&device);

        window.show(_nCmdShow);
        pumpMessages(processor.dispatcher());
    }
};


//int __cdecl main()
//{
//    setvbuf(stdout, 0, _IONBF, 0);
//    return WinMain(GetModuleHandle(NULL), NULL, "", SW_SHOWNORMAL);
//}
