Two similar ways of creating objects:

Structure { ... }
Class { ... }

Structure is the equivalent of a C++ struct or class
  Inherit from Object, which has no members
  Passed by value
  Can be allocated on stack, heap or inside another object

Class is the equivalent of a Java or C# class
  Inherit from Reference, which is a pointer
  Implementation is heap allocated and reference counted
  Any Class can also be written as a Structure.
    T = Class : Base { ... } is equivalent to:
      T = Structure : Base
      {
          ...
          operator=<@U>(U other) { _implementation = other._implementation; if (!valid()) throw; }
          constructor<@U>(U other) { *this = other; }
      private:
          Implementation = Structure : Base::Structure { ... };
          Implementation* implementation() { return dynamic_cast<Implementation*>(_implementation); }
      };
  Compiler generates a Structure method for each Implementation method
  Casting from one Class type to another does the appropriate Implementation dynamic cast
  Excess dynamic casting is optimized away


Also have Immutable which inherits from ConstReference?



alfe\expression.cpp:    ConstReference<Implementation> _implementation;
alfe\identifier.cpp:        static ConstReference<Implementation> _implementation;
alfe\identifier.cpp:        static ConstReference<Implementation> implementation()
alfe\identifier.cpp:    ConstReference<Implementation> _implementation;
alfe\identifier.cpp:ConstReference<Operator::Base<OperatorEqualTo>::Implementation>
alfe\identifier.cpp:ConstReference<Operator::Base<OperatorAssignment>::Implementation>
alfe\identifier.cpp:ConstReference<Operator::Base<OperatorAddAssignment>::Implementation>
alfe\identifier.cpp:ConstReference<Operator::Base<OperatorSubtractAssignment>::Implementation>
alfe\identifier.cpp:ConstReference<Operator::Base<OperatorMultiplyAssignment>::Implementation>
alfe\identifier.cpp:ConstReference<Operator::Base<OperatorDivideAssignment>::Implementation>
alfe\identifier.cpp:ConstReference<Operator::Base<OperatorModuloAssignment>::Implementation>
alfe\identifier.cpp:ConstReference<Operator::Base<OperatorShiftLeftAssignment>::Implementation>
alfe\identifier.cpp:        return ConstReference<Implementation>(_implementation);
alfe\type.cpp:    ConstReference<Implementation> _implementation;
alfe\type.cpp:        return ConstReference<Implementation>(_implementation);
include\alfe\any.h:        return Reference<Implementation<T> >(_implementation)->value();
include\alfe\any.h:    Reference<ImplementationBase> _implementation;
include\alfe\array.h:    Reference<Implementation> _implementation;
include\alfe\bitmap.h:    Reference<Implementation> _implementation;
include\alfe\bitmap.h:    Bitmap(const Reference<Data>& data, Byte* topLeft, Vector size, int stride)
include\alfe\bitmap.h:    Reference<Data> _data;
include\alfe\convolution_pipe.h:    Reference<Implementation> _implementation;
include\alfe\exception.h:    Reference<Implementation> _implementation;
include\alfe\file.h:    Reference<Implementation> _implementation;
include\alfe\file.h:    FileSystemObjectTemplate(Reference<Implementation> implementation)
include\alfe\file.h:        Reference<FileSystemObject::Implementation> implementation)
include\alfe\file.h:    static Reference<FileSystemObject::Implementation> _implementation;
include\alfe\file.h:    static Reference<FileSystemObject::Implementation> implementation()
include\alfe\file.h:    static Reference<FileSystemObject::Implementation> currentDirectory()
include\alfe\file.h:template<class T> Reference<FileSystemObject::Implementation>
include\alfe\file.h:    static Reference<FileSystemObject::Implementation> _implementations[26];
include\alfe\file.h:    static Reference<FileSystemObject::Implementation> implementation(
include\alfe\file.h:template<class T> Reference<FileSystemObject::Implementation>
include\alfe\file.h:    static Reference<Implementation> _implementation;
include\alfe\file.h:    static Reference<Implementation> implementation()
include\alfe\file.h:template<class T> Reference<RootDirectory::Implementation>
include\alfe\file.h:    static Reference<FileSystemObject::Implementation> _implementations[26];
include\alfe\file.h:    static Reference<FileSystemObject::Implementation> implementation(
include\alfe\file.h:template<class T> Reference<FileSystemObject::Implementation>
include\alfe\handle.h:    Reference<Implementation> _implementation;
include\alfe\reference_counted.h:    template<class U> Reference(const Reference<U>& other) { set(other._t); }
include\alfe\reference_counted.h:    template<class U> const Reference& operator=(const Reference<U>& other)
include\alfe\reference_counted.h:    template<class U> ConstReference(const ConstReference<U>& other)
include\alfe\reference_counted.h:    template<class U> ConstReference(const Reference<U>& other)
include\alfe\reference_counted.h:        const ConstReference<U>& other)
include\alfe\reference_counted.h:        const Reference<U>& other)
include\alfe\string.h:        Reference<Implementation> _implementation;
include\alfe\symbol.h:    Reference<Implementation> _implementation;
include\alfe\symbol.h:    Reference<SymbolTail> _tail;
include\alfe\symbol.h:        void setCache(Reference<ReferenceCounted> cache) { _cache = cache; }
include\alfe\symbol.h:        Reference<SymbolTail> _tail;
include\alfe\symbol.h:        Reference<SymbolCache> _cache;
include\alfe\symbol.h:        Implementation(Symbol symbol, Reference<Implementation> next)
include\alfe\symbol.h:        Reference<Implementation> next() const { return _next; }
include\alfe\symbol.h:        Reference<Implementation> _next;
include\alfe\symbol.h:    Reference<Implementation> _first;
include\alfe\symbol.h:    Reference<Implementation> _last;
include\alfe\symbol.h:        Reference<Implementation> implementation = _first;
include\alfe\symbol.h:    static Reference<Implementation> _empty;
include\alfe\symbol.h:Reference<SymbolArray::Implementation> SymbolArray::_empty =
include\alfe\type.h:    ConstReference<Implementation> _implementation;
include\alfe\type.h:      : Kind(ConstReference<Implementation>(kind._implementation)) { }
include\alfe\type.h:        return ConstReference<Implementation>(_implementation);
include\alfe\type.h:    ConstReference<Implementation> _implementation;
include\alfe\type.h:            ConstReference<Implementation> ti(t._implementation);
include\alfe\type.h:      : Type(ConstReference<Implementation>(other._implementation)) { }
include\alfe\type.h:        return ConstReference<Implementation>(_implementation)->values();
include\alfe\type.h:      : Type(ConstReference<Implementation>(other._implementation)) { }
include\alfe\type.h:        return ConstReference<Implementation>(_implementation)->names();
include\alfe\type.h:        return ConstReference<Implementation>(_implementation)->members();
include\alfe\type.h:    ConstReference<Implementation> _implementation;
include\alfe\type.h:    ConstReference<Implementation> _implementation;
include\alfe\type.h:            Reference<StructuredConversionImplementation>
include\alfe\type.h:            ConstReference<ConversionFailureImplementation> i =
include\alfe\type.h:            ConstReference<ConversionFailureImplementation> i =
include\alfe\value.h:    Reference<Implementation> _implementation;
intervals\simulator\simulator.cpp:            Reference<Bar> bar;
intervals\simulator\simulator.cpp:                for (std::vector<Reference<Bar> >::iterator i = _bars.begin(); i != _bars.end(); ++i)
intervals\simulator\simulator.cpp:                for (std::vector<Reference<Bar> >::iterator i = _bars.begin(); i != _bars.end(); ++i)
intervals\simulator\simulator.cpp:                for (std::vector<Reference<Bar> >::iterator i = _bars.begin(); i != _bars.end(); ++i)
intervals\simulator\simulator.cpp:                for (std::vector<Reference<Bar> >::iterator i = _bars.begin(); i != _bars.end(); ++i)
intervals\simulator\simulator.cpp:    std::vector<Reference<Bar> > _bars;
intervals\simulator\simulator2.cpp:    Reference<Bar> _bar;
