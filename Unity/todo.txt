compileFunction
  Need to keep track of:
    function's stack adjustment
    function's return type (for "return" statements)?
    current break and continue addresses (and whether each are valid)

Figure out how to do break and continue

Implement compile()
  When compiling break/continue statement, make sure we are inside a suitable loop/switch

Add classes
  Implement resolveSize
  Call resolveSize
  Class contents:
    public/private/protected
    friend declaration
    member variable
    method definition
    include
      Or have a 'Class X from y' form instead?

Allow implicit type conversions
  Need to know about all the overloads, the types of the arguments, the available conversion functions and their costs

Algorithm for resolving names in the presence of overloading
  Make a list of all the targets with matching names and potential number of arguments
  Choose the one which fits best.
  Use dynamic programming to figure out a "cost" associated with converting any type to any other type
    Allow conversion operators to specify a cost?

Implement assignment statements
  push(address) dup dereference op store

More detail in switch type mismatch error
Allow overloads over operator== for switch comparison

Add Int32, UInt32 and NInt32 types
Add 8-bit and 16-bit types
Add 64-bit types
Add behaviors for types Bit, Byte, Character, Word, UInt
Add hexadecimal constants
Add character literals
Add array/structure literals #{1,2,3}
Add truncateCast
Add operator  2 .                 LtR
  Argument dependent lookup: need to pass a TypeList to resolveTypes() so that we can figure out which function overload is being called?
Add operator  2 ->                LtR
Add operator  2 []                LtR  LValue
Add operator  4 sizeof            RtL
Add template classes
  Add type Fixed<N,B>
    Add fixed-point decimal and hexadecimal constants (0x0000.0001)
  Add type Complex<R>
  Add type Rational<I>
Add template functions
Compile to executable code
  Implement calling external functions
  Need to evaluate dll expression at compile time
Add statement `assembly` AssemblyStatement
Make Identifier and TypeIdentifier disallow keywords
Make include statement work
  Problem: the include statement could change the meaning of the expression in it's argument, if (for example) it redefined a function that was called to construct the argument.
  Solution: to evaluate the expression, pretend that the included file is empty and evaluate the filename on that assumption.
Add operator  1 ::                LtR
Add operator  2 typeid            LtR
Add const_cast, dynamic_cast, reinterpret_cast and static_cast (LtR, precedence 2)
Add operator  4 ()(type cast)     RtL
Add operator  5 .*                LtR
Add operator  5 ->*               LtR
Add operator 16 ?:                RtL
Need a better error message when statement isn't recognized as such
For String::throwUnexpected(), print name (or hex) of found character to avoid putting unprintable characters in error messages.
  Need a way to convert any codepoint into an ASCII printable string
    Use U+xxxx
Make sure we have a sensible error message when no memory can be allocated at all
Add 1-bit, 2-bit, 4-bit, 128-bit, 256-bit and 512-bit types
Add "fastest at least n bit" integral and floating-point types
Add half/double/quad Word/Int/UInt types
Implement constructors and destructors
  Add operator  4 new               RtL
  Add operator  4 new[]             RtL
  Add statement `delete` ["[" "]"] Expression ";"
  Implement malloc/free
Implement exceptions
  throw statement
  try/catch/finally statement
  catch block determination
    Want to catch by run-time type, not compile-time type, so need a table for each catch block and each subtype of a thrown type
  unwinding
  return ThrowStatement* from FunctionDeclaration
Floating point:
  Add Float32 and Float64 types
  Add Float16 and Float128 types
  Add type Float
  Add floating-point constants
Add arbitrary precision WordString, Integer, Unsigned and Floating types
  Add compile-time evaluation of arbitrary precision Integers and arbitrary precision constants
Add coroutines
Detect pure functions
Add statement `for` "(" Type ValueIdentifer `in` Expression ")" LoopBody
Add goto and label statements
Optimization: Add a LabelledSymbol class deriving from Symbol so that Symbol doesn't need a _label member
Optimization: Shrink Symbol::_labelled if the second half is all empty to avoid pooling memory.
  To do this, need to remove elements from the list when they're at the end of the array.
Optimization: switch SymbolArray to am AVL tree
Change semicolon parsing on increment/decrement/expression statements so that "for (i = 0; i < n; ++i)" is valid.

Rewrite (e.g.) "x += y" as "t = &x; *t = *t + y;" so that operator overloading works properly?

Measure stack size and allocate frames for unbounded recursive functions on heap

Advanced types
  null: "Null" - only one value: "null"
  sequence: "[T]" or "Reference<ISequence<T>>" or "Empty | (T, [T])"
  tuple: "(U, V)" or "Tuple<U, V>"
  union: "U | V" or "Reference<Union<U, V>>" - get U out with "w.U" or "w as U" or "cast<U>(w)", find out if it is U with "w is U"
  option: "Maybe<T>" or "T?" or "T | Null"
  function: "U -> V"

Have a run-time type operator typeOf()?
  And "Type" - the type of the value that it returns
  The Type object of type T is T::type.
  print("Compile-time type is ${TypeOf(x)::type}, run-time type is ${typeOf(x)}\n");
    Type has a toString() method, but the strings are not linked in unless used.
  
Allow parameters to have type Auto which creates a template function?

Have a Symbol-like type built in - the atoms are Type objects (or pointers to them)

Need to thing about what Type::toString() returns for class types
  keep track of first name assigned to type if it's defined with an alias

Optimization: If g is only ever called by f, we can do the stack correction for g at the same time we do the stack correction for f.

// Adjust before after
//        [sp]   [sp+adj]    contains the last value pushed - the return address
//        [sp+4] [sp+adj+4]  contains the (first word of the) first argument
//        [sp-4] [sp+adj-4]  contains the (first word of the) first variable
// Need an algorithm to compute offsets of parameters and arguments and the stack adjustment
//   Treat parameters as an object, round up to stack alignment (4 bytes for 32-bit)
//     Need an algorithm to compute offsets for an object

// sp increasing ^
//   last incoming argument word
//   ...
//   first incoming argument word     
//   return address                   
//   [optional alignment word]        
//   last variable word               
//   ...                              
//   first variable word              
//   [optional alignment word]
//   last outgoing argument word
//   ...
//   first outgoing argument word
//   [optional alignment word]
//   return address

// => The calling function has the responsibility of aligning the stack.
//   What happens if f doesn't need the stack aligned, but g (called by f) does?
//     f needs to decide in its prologue whether to add the alignment word or not
//     Or, it can specify that its caller needs to align the stack

Should functions be able to use PUSH and POP?
  They might be slower (depending on the CPU) but often take up less space. We
   should allow the compiler the possibility of generating them when they are
   preferred.
  Two styles of code generation:
    1) PUSH/POP
      * put everything on the stack
      * easy compilation
      * don't reserve stack space for outgoing arguments
      * shouldn't have two arguments in a single stack slot
    2) no PUSH/POP
      * may need to create extra variables for temporaries
      * arguments are laid out as in a class
      * probably faster on modern machines
    Can these styles interact in a single function?
      If we PUSH something under the outgoing arguments area (storing a
       temporary variable across a function call), then we need to PUSH the
       arguments too.
Plan:
  First implementation:
    Use PUSH/POP

  Reserve stack space for outgoing arguments
   Use this space if PUSH/POP are not preferred
     
An ABI is a property of a function, not an architecture. It encompasses:
  How are the arguments passed to the function?
    In registers or on the stack?
    If in registers, which ones?
    If on the stack, how is the stack arranged?
  How are is the return value returned?
    In registers or on the stack or in a location pointed to by an argument?
  How must the caller align the stack?
    Alignment and offset
  Which registers can the callee stomp?
  What name should the function have for linking purposes?
  Other architecture specific information:
    Flags that must be preserved?
    Other global state (e.g. FPU state)
    CPU features that can be assumed?

atomExit is not currently used
