Test conditional statements

Add statement (`switch` ParentheticalExpression "{" ((`case` Expression \ "," | `default`) ":" Statement)* "}"
Add statement [`do` Statement] (`while` | `until`) ParentheticalExpression LoopBody
Add statement `for` "(" (Statement | ";") [Expression] ";" [Statement] ")" LoopBody

Refactor to avoid repetition
  Type and TypeSpecifier classes for built in types
  Make all the operators functions so we don't have to have AddExpression etc. classes

In break/continue statement's compile(), make sure we are inside a suitable loop/switch

Use an intermediate language instead of current data structures?

Add Int32, UInt32 and NInt32 types
Add 8-bit and 16-bit types
Add 64-bit types
Add behaviors for types Bit, Byte, Character, Word, UInt
Add classes
Add hexadecimal constants
Add character literals
Add array/structure literals #{1,2,3}
Add truncateCast
Add operator  2 .                 LtR
  Argument dependent lookup: need to pass a TypeList to resolveTypes() so that we can figure out which function overload is being called?
Add operator  2 ->                LtR
Add operator  2 []                LtR  LValue
Add operator  4 sizeof            RtL
Add template classes
  Add type Fixed<N,B>
    Add fixed-point decimal and hexadecimal constants (0x0000.0001)
  Add type Complex<R>
  Add type Rational<I>
Add template functions
Compile to executable code
  Implement calling external functions
  Need to evaluate dll expression at compile time
Add statement `assembly` AssemblyStatement
Make Identifier and TypeIdentifier disallow keywords
Make include statement work
  Problem: the include statement could change the meaning of the expression in it's argument, if (for example) it redefined a function that was called to construct the argument.
  Solution: to evaluate the expression, pretend that the included file is empty and evaluate the filename on that assumption.
Add operator  1 ::                LtR
Add operator  2 typeid            LtR
Add const_cast, dynamic_cast, reinterpret_cast and static_cast (LtR, precedence 2)
Add operator  4 ()(type cast)     RtL
Add operator  5 .*                LtR
Add operator  5 ->*               LtR
Add operator 16 ?:                RtL  
Use operator[] instead of lookUp and add in HashTable?
Need a better error message when statement isn't recognized as such
For String::throwUnexpected(), print name (or hex) of found character to avoid putting unprintable characters in error messages.
  Need a way to convert any codepoint into an ASCII printable string
    Use U+xxxx
Make sure we have a sensible error message when no memory can be allocated at all
Add 1-bit, 2-bit, 4-bit, 128-bit, 256-bit and 512-bit types
Add "fastest at least n bit" integral and floating-point types
Add half/double/quad Word/Int/UInt types
Implement constructors and destructors
  Add operator  4 new               RtL
  Add operator  4 new[]             RtL
  Add statement `delete` ["[" "]"] Expression ";"
  Implement malloc/free
Implement exceptions
  throw statement
  try/catch/finally statement
  catch block determination
    Want to catch by run-time type, not compile-time type, so need a table for each catch block and each subtype of a thrown type
  unwinding
  return ThrowStatement* from FunctionDeclaration
Floating point:
  Add Float32 and Float64 types
  Add Float16 and Float128 types
  Add type Float
  Add floating-point constants
Add arbitrary precision WordString, Integer, Unsigned and Floating types
  Add compile-time evaluation of arbitrary precision Integers and arbitrary precision constants
Add coroutines
Detect pure functions
Add statement `for` "(" Type ValueIdentifer `in` Expression ")" LoopBody
