How to do Scope with immutable Symbol and no ReferenceSymbol?
  Step 1 - walk tree and build up local (single level) scope tables
  Step 2 - walk tree and link in parent tables
  Optimization: To do O(1) lookup, need SymbolArray : SymbolEntry. Create by converting SymbolList to SymbolArray

Add Symbol labels:
  When we remove a labelled Symbol, remove it from the labelled table
    Thread a heap through the labelled array so we can reuse old labels
      Create a class SymbolLabelTarget to put in the array
        void* that is converted to Symbol* or SymbolLabelTarget*
        Compute index from SymbolLabelTarget* by subtraction and division.
  Optimization: Shrink the array if the second half is all empty to avoid pooling memory. To do this, need to remove elements from the list when they're at the end of the array
  When creating a Symbol, can give it a label, then it will be added to the table
    What's the syntax for creating a TupleSymbol with a label?
      Have the label be a specific Symbol type? In a known position in the Tuple?
    int Symbol::label()  // Get the next unused label number
    Symbol(int n)  // Get the symbol from label n
    Initially, give all symbols a label slot
      Optimization: Later add LabelledSymbol : Symbol

Convert to use Symbol
  Statement
  Expression
  Case

Test conditional statements
Test switch statement

More detail in switch type mismatch error
Allow overloads over operator== for switch comparison

Add statement [`do` Statement] (`while` | `until`) ParentheticalExpression LoopBody
Add statement `for` "(" (Statement | ";") [Expression] ";" [Statement] ")" LoopBody

Refactor to avoid repetition
  Type and TypeSpecifier classes for built in types
  Make all the operators functions so we don't have to have AddExpression etc. classes

In break/continue statement's compile(), make sure we are inside a suitable loop/switch

Use operator[] instead of add in HashTable?

Add Int32, UInt32 and NInt32 types
Add 8-bit and 16-bit types
Add 64-bit types
Add behaviors for types Bit, Byte, Character, Word, UInt
Add classes
Add hexadecimal constants
Add character literals
Add array/structure literals #{1,2,3}
Add truncateCast
Add operator  2 .                 LtR
  Argument dependent lookup: need to pass a TypeList to resolveTypes() so that we can figure out which function overload is being called?
Add operator  2 ->                LtR
Add operator  2 []                LtR  LValue
Add operator  4 sizeof            RtL
Add template classes
  Add type Fixed<N,B>
    Add fixed-point decimal and hexadecimal constants (0x0000.0001)
  Add type Complex<R>
  Add type Rational<I>
Add template functions
Compile to executable code
  Implement calling external functions
  Need to evaluate dll expression at compile time
Add statement `assembly` AssemblyStatement
Make Identifier and TypeIdentifier disallow keywords
Make include statement work
  Problem: the include statement could change the meaning of the expression in it's argument, if (for example) it redefined a function that was called to construct the argument.
  Solution: to evaluate the expression, pretend that the included file is empty and evaluate the filename on that assumption.
Add operator  1 ::                LtR
Add operator  2 typeid            LtR
Add const_cast, dynamic_cast, reinterpret_cast and static_cast (LtR, precedence 2)
Add operator  4 ()(type cast)     RtL
Add operator  5 .*                LtR
Add operator  5 ->*               LtR
Add operator 16 ?:                RtL  
Need a better error message when statement isn't recognized as such
For String::throwUnexpected(), print name (or hex) of found character to avoid putting unprintable characters in error messages.
  Need a way to convert any codepoint into an ASCII printable string
    Use U+xxxx
Make sure we have a sensible error message when no memory can be allocated at all
Add 1-bit, 2-bit, 4-bit, 128-bit, 256-bit and 512-bit types
Add "fastest at least n bit" integral and floating-point types
Add half/double/quad Word/Int/UInt types
Implement constructors and destructors
  Add operator  4 new               RtL
  Add operator  4 new[]             RtL
  Add statement `delete` ["[" "]"] Expression ";"
  Implement malloc/free
Implement exceptions
  throw statement
  try/catch/finally statement
  catch block determination
    Want to catch by run-time type, not compile-time type, so need a table for each catch block and each subtype of a thrown type
  unwinding
  return ThrowStatement* from FunctionDeclaration
Floating point:
  Add Float32 and Float64 types
  Add Float16 and Float128 types
  Add type Float
  Add floating-point constants
Add arbitrary precision WordString, Integer, Unsigned and Floating types
  Add compile-time evaluation of arbitrary precision Integers and arbitrary precision constants
Add coroutines
Detect pure functions
Add statement `for` "(" Type ValueIdentifer `in` Expression ")" LoopBody
Add goto and label statements