
Bar 89 read marker C from 0, expected rB        ok (settling)
Bar 89 read marker C from 0, expected r.*BHJ+   ok (settling)
Bar 66 read marker J from 58, expected r.A      ok (loop)
Bar 58 read marker J from 66, expected r.A      ok (loop)
Bar 11 read marker J from 94, expected r.A      ok (loop)
Bar 25 read marker J from 18, expected r.A      ok (loop)
Bar 71 read marker J from 32, expected r.A      ok (loop)
Bar 32 read marker J from 71, expected r.A      ok (loop)
Bar 94 read marker J from 11, expected r.A      ok (loop)
Bar 18 read marker J from 25, expected r.A      ok (loop)
Bar 47 read marker + from 79, expected r0





Bar 66 read marker J from 58, expected r.     ok (loop)
Bar 58 read marker J from 66, expected r.A    ok (loop)
Bar 36 read marker . from -1, expected rAI    ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected r0     ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected r1     ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected r2     ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected r3     ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected r4     ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected r5     ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected r6     ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected r7     ok (disconnected during waitForPrimeComplete)
Bar 36 read marker . from -1, expected rM     ok (disconnected during waitForPrimeComplete)



Debugging helpers:
  Make simulator.cpp output diagrams like timings.txt

Use integers instead of doubles for time
  4MHz +/- 1% in 256 steps:
    measure time in units of cycle/(100*256):
      102.4GHz
    time step = 0.009765625 ns
  if time gets too high, simulate everything up to current t and then rebase so that t=0 again.
    1) avoid having to wait ages for a component that is a long way behind to catch up
    2) avoid incorrect results due to timers wrapping

vary the clock speed according to a normal distribution - gradually increase the standard deviation and see when it breaks
  Are the clock speeds of real PIC12F508s normal or uniform?
    Write code for the programmer code and speed tester (ideal speed should be 1/3 MHz)
  Might need to rearrange simulateCycle() as simulateToTime()

Simulate clock drift, jitter, output settling time

When the hardware doesn't work:
  Check that MOVWL OSCCAL works correctly when it isn't the first (second) instruction executed
  Get something simpler working
  Run timing tests (make sure MOVWF PCL takes one cycle)

