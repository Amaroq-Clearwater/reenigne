
0 data bit 0 (length low)
1 data bit 1 (length middle)
2 data bit 2 (length high)
3 data bit 3 (parent axis)
4 data bit 4 (switch)
5 data bit 5 (child B present)
6 data bit 6 (child C present)
7 data bit 7 (child D present)
M more data to come if low
* initialized (high)
. disconnected (high)
A "prime pending" (low)
B "prime" (low)
C "clear prime" (high)
D "data request" (high)
E "U Sync falling" (low)
F "U Sync rising" (high)
G "V Sync falling" (low)
H "V Sync rising" (high) or complete
I "prime complete" (high)
J "wait for data request" (low) or "child absent or untried" (high)

P set parent to
C set child to
c write child bit
p write parent bit
o write other bits
r read bit

Debugging helpers:
  Add value markers to annotation (possible read values, parent write value, child write value, all pins write value)
    Add to Bar a char[4]. Init to * on startup
    When reading annotations, set
    When we execute an
  Make simulator.cpp output diagrams like timings.txt

Use integers instead of doubles for time
  4MHz +/- 1% in 256 steps:
    measure time in units of cycle/(100*256):
      102.4GHz
    time step = 0.009765625 ns
  if time gets too high, simulate everything up to current t and then rebase so that t=0 again.
    1) avoid having to wait ages for a component that is a long way behind to catch up
    2) avoid incorrect results due to timers wrapping

vary the clock speed according to a normal distribution - gradually increase the standard deviation and see when it breaks
  Are the clock speeds of real PIC12F508s normal or uniform?
    Write code for the programmer code and speed tester (ideal speed should be 1/3 MHz)
  Might need to rearrange simulateCycle() as simulateToTime()

Simulate clock drift, jitter, output settling time

When the hardware doesn't work:
  Check that MOVWL OSCCAL works correctly when it isn't the first (second) instruction executed
  Get something simpler working
  Run timing tests (make sure MOVWF PCL takes one cycle)

