Component Type classes need to have Simulator pointers because they're used to construct Component objects.

Connector classes are not reference counted because Connector objects are expected to be members of Component objects (and hence owned by them).

How are Component objects owned? ROM::Type just creates a ROM* with new
  Owned by Simulator


Input/Output/Bidirectional connectors:
  It would be nice to be able to have components choose whether data is pushed or pulled depending on whether reads or writes happen more often
  Connectors can negotiate what protocol they will use to talk to each other
    The push protocol is the default and must always be available
    Periodic protocol will also be useful - that way for PC speaker emulation a virtual function call will only be needed when a port is written


What does speculative execution actually mean
  "Unless some other signal comes in, my outputs won't change until time T"
  A component supporting speculative execution has two time values:
    _tick: All component state has been computed to this point. Outputs that changed at _tick may be in the process of being set.
    _speculativeTick: The outputs won't change before this point unless the inputs change
      This is similar to MAME's timer facility

Allow discontiguous ranges without separate tree entries?
  This would be useful for using 8-bit ROM chips on a 16-bit bus (one ROM for even addresses, one for odd addresses)
    But on the other hand we might prefer a single 16-bit ROM with two files for that
      Let's not implement this unless we need it


Wait state design:
  From the point of view of the CPU, is there any difference between a DMA between bus accesses and a DMA during a bus access?
    No. S0 is delayed if it would start oon T3, Tw or T4, and wait states are introduced so that T4 happens no sooner than 4 cycles after S4.
  What should the wait state interface between CPU and bus be?
    It's a single line, so the default inteface (if we didn't have all the address and data lines) would be InputConnector<bool>/OutputConnector<bool> and the default protocol would be push:
     set(Tick t, bool v) { ... }

Components (including CPU) can end up in a state where none of the outputs will change unless an input changes.
  Is there any significance to this?
    Probably not - it just means that runTo() can return immediately
      Except for calling bus's runTo()
        but bus's runTo() needs to call CPU's runTo(). How do we resolve the potentially infinite recursion?


Suppose we want to use an enhanced protocol (e.g. interrupt input on CPU wants to be notified of number of cycles until change)
  How can we take advantage of that but fall back to the default protocol when an enhanced one is not available?
    A component can specify multiple Connector objects for a single connector name? Or just have a enhanced connectors derive from base ones
    The tricky part is that the component needs to decide which protocol to use
      1) Use "if"
      2) Use a virtual function call
      3) Instantiate different versions of components depending on protocol
      4) Component has a preferred protocol which it talks "natively" and something else to talk other protocols
         4a) A conversion component instantiated by the simulator
         4b) A conversion pseudo-component that is built into the component


