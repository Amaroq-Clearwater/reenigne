// Input files

inputPicture = arguments[1];
cgaROM = "5788005.u33";


// CGA mode configuration

// CGA mode register values:
// Basic modes:
//   0x08 = 40-column text
//   0x09 = 80-column text
//   0x0a = 2bpp graphics
//   0x1a = 1bpp graphics
// Improper modes
//   0x0b = high-res 2bpp graphics
//   0x18 = 40-column text with 1bpp graphics
//   0x19 = 80-column text with 1bpp graphics
//   0x1b = 1bpp graphics, odd bits ignored
// Add 4 to any of these for to disable colour burst and carrier and use
// red/cyan palette for 2bpp modes.
// Add 0x20 in text modes to enable blinking and disable bright backgrounds.
// cga2ntsc will not use the blink bit - this just prevents it from using
// bright backgrounds.
// The improper modes latch bytes at incorrect times, so have strange bit
// patterns and require multiple passes to get optimal results.
// Use 0x80 for auto -HRES and 0x81 for auto +HRES (tries all combinations).
mode = 0x1a;

// Low 4 bits of palette register are
//   overscan in text mode and 2bpp graphics mode
//   colour 1 in 1bpp graphics mode
//   colour 0 in 2bpp graphics mode
// Bits 4 and 5 are significant in 2bpp graphics mode:
//   0x00..0x0f = background/green/red/brown
//   0x10..0x1f = background/light green/light red/yellow
//   0x20..0x2f = background/cyan/magenta/light grey
//   0x30..0x3f = background/light cyan/light magenta/white
// Use 0xff for auto palette (tries all combinations appropriate for mode).
palette = 0x0f;

// In graphics modes, only the lowest bit of the scanline counter (CRTC "row
// address") is used. It is used to select between the two 8kB regions of VRAM,
// so for cga2ntsc purposes 1 and 2 are equivalent for graphics modes (except
// for the way that data is laid out in RAM), and 3+ give repeated scanlines.
// In text modes, the lowest 3 bits of the scanline counter give the scanline
// within the character to look up in ROM, so 1 to 8 are useful (9+ give
// repeated scanlines).
scanlinesPerRow = 2;

// Number of times to display each scanline. There are various hacks for
// repeating scanlines, but not all repeat counts are possible in every
// combination of mode and CRTC variant. cga2ntsc allows you to repeat each
// scanline any number of times even though that may not be possible on a
// real CGA card.
scanlinesRepeat = 1;

// CRTC interlace mode register value:
// No interlace sync (scanlines in same position on both fields)
//   0 = None (non-interlaced, like standard CGA modes)
//   1 = Flicker (alternate between two VRAM regions)
//   4 = Even scanlines within row only
//   5 = Odd scanlines within row only
//   6 = Video (alternate between even and odd scanlines)
//   7 = Video and flicker
//  10 = Even flicker
//  11 = Odd flicker
// Interlace sync (scanlines on odd field half a scanline lower)
//   2 = Sync (same data in both fields, inter-scanline gaps "filled in")
//   3 = Sync and video (480i equivalent, e.g. 400 active scanlines)
//   8 = Sync flicker
//   9 = Sync video and flicker
//  12 = Sync even
//  13 = Sync odd
//  14 = Sync even flicker
//  15 = Sync odd flicker
//  16 = Sync and video swapped
//  17 = Sync video and flicker swapped
// On a real MC6845 interlace mode 3 is the same as interlace mode 6, and the
// IBM CGA card delays the vsync pulse to the next hsync so that interlace mode
// 3 behaves as interlace video without interlace sync (and an extra scanline
// every other frame). It's possible to add or remove interlace sync in
// software, though, so we allow all 4 possible combinations in cga2ntsc.
interlaceMode = 0;

// Phase is relevant for improper +HRES modes (0x0b, 0x19 and 0x1b).
// Phase 0 starts is 8 hdots further left and has different bit patterns.
phase = 1;


// Matching options

// Set to true to try to match the input picture as closely as possible
// Set to false to show how an existing CGA RGBI image would look on the
// composite output.
matchMode = !bitmapIsRGBI(inputPicture);

// Character set to use for matching in text modes:
//   0 = 0xdd                 160x100x16
//   1 = 0x13/0x55             80x100x512  composite
//   2 = 0x13/0x55/0xb0/0xb1   80x100x1024 composite
//   3 = all
//   4 = 0xb1                  80x100x256
//   5 = 0xb0/0xb1             80x100x512
//   6 = 0x06/0x13/0x19/0x22/0x27/0x55/0x57/0x60/0xb6/0xdd
// Set 6 is all the characters with the same data on scanlines 0 and 1,
// allowing us to do 200 1-scanline rows with no CPU time, or 100
// duplicated-scanline rows with no CPU time
characterSet = 3;

// Quality for matching in text modes. 0 = fastest, 1 = best quality
quality = 0.5;

// Parameters for error diffusion in match mode.
horizontalDiffusion = 0.5;
verticalDiffusion = 0.5;
temporalDiffusion = 0;


// CGA composite encoding options

// Newer CGA cards have a lower chroma amplitude and the text mode colours show
// up as more different shades of grey on a monochrome monitor.
newCGA = false;


// NTSC decoding options

contrast = 1;
brightness = 0;
saturation = 1;
hue = 0;
chromaBandwidth = 1;  // units of colour carrier frequency /8
lumaBandwidth = 1;  // units of colour carrier frequency
ntscPrimaries = false;
// Comb filter settings:
//   0 = no filter
//   1 = (1, 1) kernel
//   2 = (1, 2, 1) kernel
combFilterVertical = 0;
combFilterTemporal = 0;


// Scaling and scanline options

aspectRatio = 5/6;  // Pixel aspect ratio of one ldot
scanlineWidth = 0.5;  // Width of a scanline in units of "zoom" pixels

// Scanline profiles
//   0 = rectangular
//   1 = triangle
//   2 = semicircle
//   3 = gaussian
scanlineProfile = 0;

scanlineBleeding = true;  // False to just saturate instead
scanlineOffset = 0;  // Number of scanlines to offset image by
zoom = 2;  // Output pixels per scanline vertically


// Set to false to convert and immediately exit without showing UI, for batch
// processing.
interactive = true;


// Location of wisdom file for FFTW. This caches data which is used to speed up
// subsequent runs of the program. The data it contains may be sub-optimal for
// machines other than the machine it was created on, so it should not be
// copied to other machines.
fftWisdom = "wisdom";
