class Particle
{
public:
    void plot(Bitmap<DWORD> bitmap, Vector rPosition)
    {
        Vector size = bitmap.size();
        Byte* buffer = bitmap.data();
        int byteWidth = bitmap.stride();
        double zOffset = rPosition.x*0.01;
        double scale = rPosition.y*0.01;
        double x = _position.x/(_position.z + zOffset)*scale;
        double y = _position.y/(_position.z + zOffset)*scale;
        int x0 = static_cast<int>(size.x*x/5.0 + size.x/2);
        int y0 = static_cast<int>(size.x*y/5.0 + size.y/2);
        int r = byteClamp(_colour.x);
        int g = byteClamp(_colour.y);
        int b = byteClamp(_colour.z);
        DWord c = (r << 16) | (g << 8) | b;
        plot(bitmap, Vector(x0,     y0    ), c);
        if (!_big) {
            if (r < 16 && g < 16 && b < 16) {
                c = 0xffffff;
                plot(bitmap, Vector(x0 - 1, y0 - 1), c);
                plot(bitmap, Vector(x0 + 1, y0 - 1), c);
                plot(bitmap, Vector(x0 - 1, y0 + 1), c);
                plot(bitmap, Vector(x0 + 1, y0 + 1), c);
            }
            return;
        }
        plot(bitmap, Vector(x0 - 1, y0 - 2), c);
        plot(bitmap, Vector(x0,     y0 - 2), c);
        plot(bitmap, Vector(x0 + 1, y0 - 2), c);
        plot(bitmap, Vector(x0 - 2, y0 - 1), c);
        plot(bitmap, Vector(x0 - 1, y0 - 1), c);
        plot(bitmap, Vector(x0,     y0 - 1), c);
        plot(bitmap, Vector(x0 + 1, y0 - 1), c);
        plot(bitmap, Vector(x0 + 2, y0 - 1), c);
        plot(bitmap, Vector(x0 - 2, y0    ), c);
        plot(bitmap, Vector(x0 - 1, y0    ), c);
        plot(bitmap, Vector(x0 + 1, y0    ), c);
        plot(bitmap, Vector(x0 + 2, y0    ), c);
        plot(bitmap, Vector(x0 - 2, y0 + 1), c);
        plot(bitmap, Vector(x0 - 1, y0 + 1), c);
        plot(bitmap, Vector(x0,     y0 + 1), c);
        plot(bitmap, Vector(x0 + 1, y0 + 1), c);
        plot(bitmap, Vector(x0 + 2, y0 + 1), c);
        plot(bitmap, Vector(x0 - 1, y0 + 2), c);
        plot(bitmap, Vector(x0,     y0 + 2), c);
        plot(bitmap, Vector(x0 + 1, y0 + 2), c);
        if (r < 16 && g < 16 && b < 16) {
            c = 0xffffff;
            plot(bitmap, Vector(x0 - 1, y0 - 3), c);
            plot(bitmap, Vector(x0,     y0 - 3), c);
            plot(bitmap, Vector(x0 + 1, y0 - 3), c);
            plot(bitmap, Vector(x0 - 1, y0 + 3), c);
            plot(bitmap, Vector(x0,     y0 + 3), c);
            plot(bitmap, Vector(x0 + 1, y0 + 3), c);
            plot(bitmap, Vector(x0 - 2, y0 - 2), c);
            plot(bitmap, Vector(x0 + 2, y0 - 2), c);
            plot(bitmap, Vector(x0 - 3, y0 - 1), c);
            plot(bitmap, Vector(x0 + 3, y0 - 1), c);
            plot(bitmap, Vector(x0 - 3, y0    ), c);
            plot(bitmap, Vector(x0 + 3, y0    ), c);
            plot(bitmap, Vector(x0 - 3, y0 + 1), c);
            plot(bitmap, Vector(x0 + 3, y0 + 1), c);
            plot(bitmap, Vector(x0 - 2, y0 + 2), c);
            plot(bitmap, Vector(x0 + 2, y0 + 2), c);
        }
    }
    void plot(Bitmap<DWORD> bitmap, Vector p, DWord c)
    {
        if (p.inside(bitmap.size()))
            bitmap[p] = c;
    }
    bool operator<(const Particle& other) const { return _position.z > other._position.z; }
    void transform(double* matrix)
    {
        Vector3<double> c = (_colour - Vector3<double>(128.0, 128.0, 128.0))/128.0;
        _position.x = c.x*matrix[0] + c.y*matrix[1] + c.z*matrix[2];
        _position.y = c.x*matrix[3] + c.y*matrix[4] + c.z*matrix[5];
        _position.z = c.x*matrix[6] + c.y*matrix[7] + c.z*matrix[8];
    }

    Colour _colour;
    Vector3<double> _position;
    bool _big;
};

class GamutWindow : public BitmapWindow
{
public:
    GamutWindow()
      : _lButton(false), _rButton(false), _rPosition(1000, 1000), _particle(0),
        _delta(0, 0)
    {
        _matrix[0] = 1; _matrix[1] = 0; _matrix[2] = 0;
        _matrix[3] = 0; _matrix[4] = 1; _matrix[5] = 0;
        _matrix[6] = 0; _matrix[7] = 0; _matrix[8] = 1;
        setInnerSize(Vector(640, 480));
    }
    void create()
    {
        BitmapWindow::create();
        reset();
        draw();
        invalidate();
    }
    void setAnimated(AnimatedWindow* animated) { _animated = animated; }
    void paint()
    {
        _animated->restart();
    }
    void draw()
    {
        if (_delta.modulus2() >= 0.000001)
            animate();
        else
            _animated->stop();
        if (!_bitmap.valid())
            _bitmap = Bitmap<DWORD>(Vector(640, 480));
        _bitmap.fill(0);
        for (int i = 0; i < _particle; ++i)
            _particles[i].transform(_matrix);
        std::sort(&_particles[0], &_particles[_particle]);
        for (int i = 0; i < _particle; ++i)
            _particles[i].plot(_bitmap, _rPosition);
        _bitmap = setNextBitmap(_bitmap);
    }
    void line(Colour c1, Colour c2)
    {
        for (int i = 0; i < 101; ++i)
            add(c1*(i*0.01) + c2*((100-i)*0.01), false);
    }
    void reset()
    {
        _particle = 0;
        line(Colour(0, 0, 0), Colour(255, 0, 0));
        line(Colour(0, 0, 0), Colour(0, 255, 0));
        line(Colour(0, 0, 0), Colour(0, 0, 255));
        line(Colour(255, 0, 0), Colour(255, 255, 0));
        line(Colour(255, 0, 0), Colour(255, 0, 255));
        line(Colour(0, 255, 0), Colour(255, 255, 0));
        line(Colour(0, 255, 0), Colour(0, 255, 255));
        line(Colour(0, 0, 255), Colour(0, 255, 255));
        line(Colour(0, 0, 255), Colour(255, 0, 255));
        line(Colour(255, 255, 0), Colour(255, 255, 255));
        line(Colour(255, 0, 255), Colour(255, 255, 255));
        line(Colour(0, 255, 255), Colour(255, 255, 255));
    }
    void add(Colour c, bool big = true)
    {
        Particle p;
        p._colour = c;
        p._big = big;
        if (_particle >= _particles.count())
            _particles.append(p);
        else
            _particles[_particle] = p;
        ++_particle;
    }
    bool mouseInput(Vector position, int buttons)
    {
        bool oldLButton = _lButton;
        bool mouseDown = false;
        if ((buttons & MK_LBUTTON) != 0 && !_lButton) {
            _lButton = true;
            mouseDown = true;
            _lastPosition = position;
        }
        if ((buttons & MK_LBUTTON) == 0)
            _lButton = false;
        if ((buttons & MK_RBUTTON) != 0 && !_rButton) {
            _rButton = true;
            mouseDown = true;
            _lastPosition = position;
        }
        if ((buttons & MK_RBUTTON) == 0)
            _rButton = false;
        if (_lButton) {
            _delta = Vector2Cast<double>(position - _lastPosition)*0.01;
            if (position != _lastPosition)
                update();
            _lastPosition = position;
        }
        else
            if (oldLButton && _delta.modulus2() >= 0.000001)
                _animated->start();
        if (_rButton && position != _lastPosition) {
            _rPosition += (position - _lastPosition);
            _lastPosition = position;
        }

        return mouseDown;
    }
    void animate()
    {
        _rotor =
            Rotor3<double>::yz(-_delta.y)*Rotor3<double>::zx(_delta.x)*_rotor;
        _rotor.toMatrix(_matrix);
        _delta *= 0.95;
    }
    void update()
    {
        animate();
        invalidate();
    }

    Rotor3<double> _rotor;
    double _matrix[9];
    AppendableArray<Particle> _particles;
    Vector _lastPosition;
    Vector _rPosition;
    bool _lButton;
    bool _rButton;
    Vector2<double> _delta;
    AnimatedWindow* _animated;
    Bitmap<DWORD> _bitmap;

    int _particle;
};

//template<class T> class AutoBrightnessButtonWindowT
//  : public ToggleButton
//{
//public:
//    void setHost(CGAArtWindow* host) { _host = host; }
//    void clicked() { _host->autoBrightnessPressed(); }
//    void create()
//    {
//        setText("Auto");
//        ToggleButton::create();
//    }
//private:
//    CGAArtWindow* _host;
//};
//typedef AutoBrightnessButtonWindowT<void> AutoBrightnessButtonWindow;
//
//template<class T> class AutoContrastClipButtonWindowT
//  : public ToggleButton
//{
//public:
//    void setHost(CGAArtWindow* host) { _host = host; }
//    void clicked() { _host->autoContrastClipPressed(); }
//    void create()
//    {
//        setText("No clipping");
//        ToggleButton::create();
//    }
//private:
//    CGAArtWindow* _host;
//};
//typedef AutoContrastClipButtonWindowT<void>
//    AutoContrastClipButtonWindow;
//
//template<class T> class AutoSaturationButtonWindowT
//  : public ToggleButton
//{
//public:
//    void setHost(CGAArtWindow* host) { _host = host; }
//    void clicked() { _host->autoSaturationPressed(); }
//    void create()
//    {
//        setText("Auto");
//        ToggleButton::create();
//    }
//private:
//    CGAArtWindow* _host;
//};
//typedef AutoSaturationButtonWindowT<void> AutoSaturationButtonWindow;
//
//template<class T> class AutoContrastMonoButtonWindowT
//  : public ToggleButton
//{
//public:
//    void setHost(CGAArtWindow* host) { _host = host; }
//    void clicked() { _host->autoContrastMonoPressed(); }
//    void create()
//    {
//        setText("Fix black and white");
//        ToggleButton::create();
//    }
//private:
//    CGAArtWindow* _host;
//};
//typedef AutoContrastMonoButtonWindowT<void>
//    AutoContrastMonoButtonWindow;
//

      //: _autoBrightnessFlag(false), _autoSaturationFlag(false),
      //  _autoContrastClipFlag(false), _autoContrastMonoFlag(false),
      //  _updating(true)

        //add2(&_autoBrightness);
        //add2(&_autoSaturation);
        //add2(&_autoContrastClip);
        //add2(&_autoContrastMono);
        //add(&_blackText);
        //add(&_whiteText);
        //add(&_mostSaturatedText);
        //add(&_clippedColoursText);
        //add(&_gamut);
        //add(&_animated);

        //_animated.setDrawWindow(&_gamut);
        //_gamut.setAnimated(&_animated);

        //setInnerSize(Vector(_brightness.right() + 20, _gamut.bottom() + 20));

        //_updating = false;
        //update();
        //uiUpdate();

        //int w = max(_outputWindow.right(), _gamut.right()) + 20;
        //_gamut.setPosition(Vector(20, _outputWindow.bottom() + 20));
        //_autoBrightness.setPosition(_brightness.bottomLeft() + vSpace);
        //_saturation.setPositionAndSize(_autoBrightness.bottomLeft() + 2*vSpace,
        //    Vector(301, 24));
        //_autoSaturation.setPosition(_saturation.bottomLeft() + vSpace);
        //_contrast.setPositionAndSize(_autoSaturation.bottomLeft() + 2*vSpace,
        //    Vector(301, 24));
        //_autoContrastClip.setPosition(_contrast.bottomLeft() + vSpace);
        //_autoContrastMono.setPosition(_autoContrastClip.topRight() +
        //    Vector(20, 0));
        //_hue.setPositionAndSize(_autoContrastClip.bottomLeft() + 2*vSpace,
        //    Vector(301, 24));
        //_blackText.setPosition(_newCGA.bottomLeft() + 2*vSpace);
        //_whiteText.setPosition(_blackText.bottomLeft());
        //_mostSaturatedText.setPosition(_whiteText.bottomLeft());
        //_clippedColoursText.setPosition(_mostSaturatedText.bottomLeft());
        //_matchMode.setPosition(_clippedColoursText.bottomLeft() + 2*vSpace);
    //void uiUpdate()
    //{
    //    _updating = true;
    //    _whiteText.setText(format("White level: %f", _white));
    //    _whiteText.layout();
    //    _blackText.setText(format("Black level: %f", _black));
    //    _blackText.layout();
        //_blackText.setPosition(_newCGA.bottomLeft() + 2*vSpace);
        //_whiteText.setPosition(_blackText.bottomLeft());
        //_mostSaturatedText.setPosition(_whiteText.bottomLeft());
        //_clippedColoursText.setPosition(_mostSaturatedText.bottomLeft());

    //    _mostSaturatedText.setText(
    //        format("Most saturated: %f", _maxSaturation));
    //    _mostSaturatedText.layout();
    //    _clippedColoursText.setText(format("%i colours clipped", _clips));
    //    _clippedColoursText.layout();
    //    _outputWindow.draw();
    //    _outputWindow.invalidate();
    //    _gamut.invalidate();
    //    _updating = false;
    //}
    //Colour colourFromSeq(UInt64 seq)
    //{
    //    Byte ntsc[7];
    //    int phase = (seq >> 32) & 3;
    //    for (int x = 0; x < 7; ++x) {
    //        ntsc[x] = _composite.simulateCGA(seq & 15, (seq >> 4) & 15,
    //            (x + phase) & 3);
    //        seq >>= 4;
    //    }
    //    return _decoder->decode(ntsc, phase);
    //}
    //void update()
    //{
    //    if (_updating)
    //        return;
    //    _composite.initChroma();
    //    Byte burst[4];
    //    for (int i = 0; i < 4; ++i)
    //        burst[i] = _composite.simulateCGA(6, 6, i);
    //    _decoder->calculateBurst(burst);
    //    int s[4];
    //    _composite.decode(0, s);
    //    Colour black = _decoder->decode(s);
    //    _black = 0.299*black.x + 0.587*black.y + 0.114*black.z;
    //    _composite.decode(0xffff, s);
    //    Colour white = _decoder->decode(s);
    //    _white = 0.299*white.x + 0.587*white.y + 0.114*white.z;
    //    _clips = 0;
    //    _maxSaturation = 0;
    //    _gamut.reset();
    //    for (auto i : _colours) {
    //        Colour c = colourFromSeq(i);
    //        double r = c.x;
    //        double g = c.y;
    //        double b = c.z;
    //        if (r < 0 || r >= 256 || g < 0 || g >= 256 || b < 0 || b >= 256) {
    //            ++_clips;
    //            _clipped = i;
    //        }
    //        double y = 0.299*r + 0.587*g + 0.114*b;
    //        _maxSaturation =
    //            max(_maxSaturation, (c - Colour(y, y, y)).modulus());
    //        _gamut.add(c);
    //    }
    //    _gamut.draw();
    //    _gamut.invalidate();
    //}
        //if (!_updating) {
        //    update();
        //    uiUpdate();
        //}
        //if (!_updating) {
        //    update();
        //    autoContrastClip();
        //    uiUpdate();
        //}
        //if (!_updating) {
        //    update();
        //    autoBrightness();
        //    autoSaturation();
        //    uiUpdate();
        //}
        //if (!_updating) {
        //    update();
        //    allAutos();
        //    uiUpdate();
        //}
        //if (!_updating) {
        //    update();
        //    uiUpdate();
        //}
        //if (!_updating) {
        //    update();
        //    uiUpdate();
        //}
        //_composite.setNewCGA(newCGA);
        //update();
        //allAutos();
        //uiUpdate();
    //void autoContrastClipPressed()
    //{
    //    _autoContrastClipFlag = _autoContrastClip.checked();
    //    if (_autoContrastClipFlag) {
    //        _autoContrastMono.uncheck();
    //        _autoContrastMonoFlag = false;
    //    }
    //    autoContrastClip();
    //    uiUpdate();
    //}
    //void autoContrastMonoPressed()
    //{
    //    _autoContrastMonoFlag = _autoContrastMono.checked();
    //    if (_autoContrastMonoFlag) {
    //        _autoContrastClip.uncheck();
    //        _autoContrastClipFlag = false;
    //    }
    //    autoContrastMono();
    //    autoBrightness();
    //    uiUpdate();
    //}
    //void autoBrightnessPressed()
    //{
    //    _autoBrightnessFlag = _autoBrightness.checked();
    //    autoContrastMono();
    //    autoBrightness();
    //    uiUpdate();
    //}
    //void autoSaturationPressed()
    //{
    //    _autoSaturationFlag = _autoSaturation.checked();
    //    autoSaturation();
    //    uiUpdate();
    //}
        //update();
        //allAutos();
        //uiUpdate();
    //void allAutos()
    //{
    //    autoSaturation();
    //    autoContrastClip();
    //    autoContrastMono();
    //    autoBrightness();
    //}
    //void autoBrightness(bool force = false)
    //{
    //    if (!false && !_autoBrightnessFlag)
    //        return;
    //    _brightness.setValue(_brightness.getValue() +
    //        (256 - (_black + _white))/512);
    //    update();
    //}
    //void autoSaturation()
    //{
    //    if (!_autoSaturationFlag)
    //        return;
    //    _saturation.setValue(_output->getSaturation()*sqrt(3.0)*
    //        (_white - _black)/(2*_maxSaturation));
    //    update();
    //}
    //void autoContrastClip()
    //{
    //    if (!_autoContrastClipFlag)
    //        return;
    //    double minContrast = 0;
    //    double maxContrast = 2;
    //    double contrast;
    //    do {
    //        contrast = (maxContrast + minContrast)/2;
    //        setContrast(contrast);
    //        update();
    //        autoBrightness();
    //        if (_clips == 1 || (maxContrast - minContrast) < 0.000001)
    //            break;
    //        else
    //            if (_clips == 0)
    //                minContrast = contrast;
    //            else
    //                maxContrast = contrast;
    //    } while (true);
    //    double midPoint = (_white + _black)/2;
    //    double fudge = 0.99999;
    //    for (int i = 0; i < 3; ++i) {
    //        Colour c = colourFromSeq(_clipped);
    //        double r = c.x;
    //        double g = c.y;
    //        double b = c.z;
    //        bool found = false;
    //        if (r < 0) {
    //            contrast *= fudge*midPoint/(midPoint - r);
    //            found = true;
    //        }
    //        if (!found && r >= 256) {
    //            contrast *= fudge*midPoint/(r - midPoint);
    //            found = true;
    //        }
    //        if (!found && g < 0) {
    //            contrast *= fudge*midPoint/(midPoint - g);
    //            found = true;
    //        }
    //        if (!found && g >= 256) {
    //            contrast *= fudge*midPoint/(g - midPoint);
    //            found = true;
    //        }
    //        if (!found && b < 0) {
    //            contrast *= fudge*midPoint/(midPoint - b);
    //            found = true;
    //        }
    //        if (!found && b >= 256)
    //            contrast *= fudge*midPoint/(b - midPoint);
    //        setContrast(contrast);
    //        update();
    //        autoBrightness();
    //        autoSaturation();
    //        if (_clips == 0)
    //            break;
    //    }
    //}
    //void autoContrastMono()
    //{
    //    if (!_autoContrastMonoFlag)
    //        return;
    //    _contrast.setValue(_output->getContrast() * 256/(_white - _black));
    //    update();
    //}
    //void resetColours() { _colours = Set<UInt64>(); }
    //void addColour(UInt64 seq) { _colours.add(seq); }

    //AnimatedWindow _animated;
    //AutoBrightnessButtonWindow _autoBrightness;
    //AutoSaturationButtonWindow _autoSaturation;
    //AutoContrastClipButtonWindow _autoContrastClip;
    //AutoContrastMonoButtonWindow _autoContrastMono;
    //TextWindow _blackText;
    //TextWindow _whiteText;
    //TextWindow _mostSaturatedText;
    //TextWindow _clippedColoursText;
    //GamutWindow _gamut;
    //CGAComposite _composite;
    //double _black;
    //double _white;
    //Set<UInt64> _colours;
    //int _clips;
    //double _maxSaturation;
    //UInt64 _clipped;
    //bool _autoBrightnessFlag;
    //bool _autoSaturationFlag;
    //bool _autoContrastClipFlag;
    //bool _autoContrastMonoFlag;
    //bool _updating;


template<class T> class CGAOldMatcherT : public ThreadTask
{
public:
    CGAOldMatcherT() : _skip(256), _active(false)
    {
        _patterns.allocate(0x10000*8*17 + 0x100*80*5);
    }
    void setInput(Bitmap<SRGB> input, Vector activeSize)
    {
        _input = input;
        _size = input.size();
        _input2 = Bitmap<SRGB>(_size + Vector(11, 0));
        _input2.fill(SRGB(0, 0, 0));
        _input2.subBitmap(Vector(5, 0), _size).copyFrom(_input);
        _configs.allocate(_size.y);
        _active = true;
        initData();
    }
    void setSize(Vector size)
    {
        _size = size;
        initData();
    }
    void setProgram(Program* program) { _program = program; }
    void setSequencer(CGASequencer* sequencer) { _sequencer = sequencer; }
    void setData(CGAData* data) { _data = data; }
    static void filterHF(const Byte* input, SInt16* output, int n)
    {
        for (int x = 0; x < n; ++x)
            output[x] = (-input[x] + input[x+1]*2 + input[x+2]*6 + input[x+3]*2
                -input[x+4]);
    }
    void run()
    {
        _composite.setBW((_mode & 4) != 0);
        bool newCGA = _connector == 2;
        _composite.setNewCGA(newCGA);
        _composite.initChroma();
        double black = _composite.black();
        double white = _composite.white();
        _decoder.setHue(_hue + ((_mode & 1) != 0 ? 14 : 4));
        _decoder.setSaturation(_saturation*1.45*(newCGA ? 1.5 : 1.0)/200);
        double c = _contrast*256*(newCGA ? 1.2 : 1)/(white - black)/100;
        _decoder.setContrast(c);
        _decoder.setBrightness((-black*c +
            _brightness*5 + (newCGA ? -50 : 0))/256.0);

        Byte burst[4];
        for (int i = 0; i < 4; ++i)
            burst[i] = _composite.simulateCGA(6, 6, i);
        _decoder.calculateBurst(burst);
        _block.y = _scanlinesPerRow * _scanlinesRepeat;
        if ((_mode & 2) != 0) {
            // In graphics modes, the data for the second scanline of the row
            // is independent of the data for the first scanline, so we can
            // pretend there's one scanline per row for matching purposes.
            if (_scanlinesPerRow == 2)
                _block.y = _scanlinesRepeat;
            for (int i = 0; i < 256; ++i)
                _skip[i] = false;
        }
        else {
            auto cgaROM = _sequencer->romData();
            int lines = _scanlinesPerRow;
            for (int i = 0; i < 256; ++i) {
                _skip[i] = false;
                if (_characterSet == 0) {
                    _skip[i] = (i != 0xdd);
                    continue;
                }
                if (_characterSet == 1) {
                    _skip[i] = (i != 0x13 && i != 0x55);
                    continue;
                }
                if (_characterSet == 2) {
                    _skip[i] =
                        (i != 0x13 && i != 0x55 && i != 0xb0 && i != 0xb1);
                    continue;
                }
                if (_characterSet == 4) {
                    _skip[i] = (i != 0xb1);
                    continue;
                }
                if (_characterSet == 5) {
                    _skip[i] = (i != 0xb0 && i != 0xb1);
                    continue;
                }
                if (_characterSet == 6) {
                    _skip[i] = (i != 0x06 && i != 0x13 && i != 0x19 &&
                        i != 0x22 && i != 0x27 && i != 0x55 && i != 0x57 &&
                        i != 0x60 && i != 0xb6 && i != 0xdd);
                }
                bool isBackground = true;
                bool isForeground = true;
                for (int y = 0; y < lines; ++y) {
                    Byte b = cgaROM[i*8 + y];
                    if (b != 0x00)
                        isBackground = false;
                    if (b != 0xff)
                        isForeground = false;
                }
                if (isBackground || isForeground) {
                    _skip[i] = true;
                    continue;
                }
                int j;
                for (j = 0; j < i; ++j) {
                    int y;
                    for (y = 0; y < lines; ++y)
                        if (cgaROM[i*8 + y] != cgaROM[j*8 + y])
                            break;
                    if (y == lines)
                        break;
                }
                if (j != i)
                    _skip[i] = true;
                for (j = 0; j < i; ++j) {
                    int y;
                    for (y = 0; y < lines; ++y)
                        if (cgaROM[i*8 + y] != (cgaROM[j*8 + y]^0xff))
                            break;
                    if (y == lines)
                        break;
                }
                if (j != i)
                    _skip[i] = true;
            }
        }

        _ntscInput = Bitmap<SInt16>(_size + Vector(1, 0));
        Byte* ntscRow = _ntscInput.data();
        const Byte* srgbRow = _input2.data();
        Array<Byte> ntscTemp(_size.x + 5);
        for (int y = 0; y < _size.y; ++y) {
            _decoder.encodeLine(&ntscTemp[0],
                reinterpret_cast<const SRGB*>(srgbRow), _size.x + 5, 2);
            filterHF(&ntscTemp[0], reinterpret_cast<SInt16*>(ntscRow),
                _size.x + 1);
            ntscRow += _ntscInput.stride();
            srgbRow += _input2.stride();
        }

        // Convert from _mode/_palette to config
        switch (_mode & 0x13) {
            case 0:
                _startConfig = 0x50;
                break;
            case 1:
                _startConfig = 0xd0;
                break;
            case 0x12:
                _startConfig = 0x40 + (_palette & 0x0f);
                break;
            case 2:
                _startConfig = _palette;
                break;
            case 0x10:
                _startConfig = 0x51;
                break;
            case 0x11:
                _startConfig = 0xd1;
                break;
            case 0x13:
                _startConfig = 0xc0 + (_palette & 0x0f);
                break;
            case 3:
                _startConfig = 0x80 + _palette;
                break;
        }
        _endConfig = _startConfig + 1;
        if (_palette == 0xff) {
            switch (_mode & 0x13) {
                case 0x12:
                    _startConfig = 0x40;
                    _endConfig = 0x50;
                    break;
                case 2:
                    _startConfig = 0x00;
                    _endConfig = 0x40;
                    break;
                case 0x13:
                    _startConfig = 0xc0;
                    _endConfig = 0xd0;
                    break;
                case 3:
                    _startConfig = 0x80;
                    _endConfig = 0xc0;
                    break;
            }
        }
        if ((_mode & 0x80) != 0) {
            _startConfig = (_mode & 1) == 0 ? 0 : 0x80;
            _endConfig = _startConfig + 0x51;
        }

        for (_config = _startConfig; _config < _endConfig; ++_config) {
            SInt16* p = &_patterns[(_config & 0x7f)*5*256];
            config();
            Array<Byte> rgbi(_block.x + 6);
            ntscTemp.allocate(_block.x + 5);
            int w = _block.x + 1;
            for (int pattern = 0; pattern < _patternCount; ++pattern) {
                for (int line = 0; line < _block.y; ++line) {
                    plotPattern(&rgbi[3], pattern, line);
                    rgbi[0] = rgbi[_block.x];
                    rgbi[1] = rgbi[1 + _block.x];
                    rgbi[2] = rgbi[2 + _block.x];
                    rgbi[3 + _block.x] = rgbi[3];
                    rgbi[4 + _block.x] = rgbi[4];
                    rgbi[5 + _block.x] = rgbi[5];
                    _composite.simulateLine(&rgbi[0], &ntscTemp[0],
                        _block.x + 5, 0);
                    filterHF(&ntscTemp[0], &p[(pattern*_block.y + line)*w], w);
                }
            }
        }

        int overscan = (_mode & 0x10) == 0 ? _palette & 0x0f : 0;
        int y = 0;
        _inputRow = _ntscInput.data();
        _error = Bitmap<int>(_size + Vector(4, 1));
        _error.fill(0);
        _errorRow = _error.data();
        _testError = Bitmap<int>(_block + Vector(4, 1));
        _config = _startConfig;
        _testConfig = (_startConfig + 1 != _endConfig);
        _configScore = 0x7fffffffffffffffUL;
        _rowData.ensure(2*_horizontalDisplayed);
        while (true) {
            int w = _block.x + 1;
            Vector errorLineSize(_size.x + 4, 1);
            Bitmap<int> savedError(errorLineSize);
            if (_testConfig)
                savedError.copyFrom(_error.subBitmap(Vector(0, y),
                    errorLineSize));
            config();
            SInt16* p = &_patterns[(_config & 0x7f)*5*256];
            UInt64 lineScore = 0;

            for (int x = 0; x < (_size.x & -_hdotsPerChar); x += _block.x) {
                int bestPattern = 0;
                int bestScore = 0x7fffffff;
                int skipSolidColour = 0xf00;
                for (int pattern = 0; pattern < _patternCount; ++pattern) {
                    if ((_mode & 2) == 0) {
                        if (_skip[pattern & 0xff])
                            continue;
                        if ((pattern & 0x0f00) == ((pattern >> 4) & 0x0f00)) {
                            if ((pattern & 0xf00) == skipSolidColour)
                                continue;
                            skipSolidColour = (pattern & 0xf00);
                        }
                    }
                    int score = 0;
                    const Byte* inputRow2 = _inputRow;
                    Byte* errorRow2 = _errorRow;
                    _testError.fill(0);
                    for (int yy = 0; yy < _block.y; ++yy) {
                        const SInt16* inputPixel =
                            reinterpret_cast<const SInt16*>(inputRow2) + x;
                        const int* errorPixel =
                            reinterpret_cast<const int*>(errorRow2) + x;
                        for (int xx = 0; xx < w; ++xx) {
                            int test = p[(pattern*_block.y + yy)*w + xx];
                            Vector p(xx, yy);
                            int target = inputPixel[xx] +
                                (errorPixel[xx] + _testError[p])/4;
                            int d = target - test;
                            int weight = (xx == 0 || xx == _block.x ? 1 : 2);
                            score += weight*d*d;
                            int error = weight*d;
                            _testError[p + Vector(4, 0)] +=
                                (error*_diffusionHorizontal)/256;
                            _testError[p + Vector(0, 1)] +=
                                (error*_diffusionVertical)/256;
                        }
                        inputRow2 += _ntscInput.stride();
                        errorRow2 += _error.stride();
                    }
                    if (score < bestScore) {
                        bestScore = score;
                        bestPattern = pattern;
                    }
                }

                if ((_mode & 2) == 0) {
                    int address = 2*(x/_hdotsPerChar);
                    _rowData[address] = bestPattern & 0xff;
                    _rowData[address + 1] = bestPattern >> 8;
                }
                else {
                    int address = x/8;
                    int bit = (x & 4) ^ 4;
                    _rowData[address] = (_rowData[address] & ~(15 << bit)) |
                        (bestPattern << bit);
                }

                const Byte* inputRow2 = _inputRow;
                Byte* errorRow2 = _errorRow;
                for (int yy = 0; yy < _block.y; ++yy) {
                    const SInt16* inputPixel =
                        reinterpret_cast<const SInt16*>(inputRow2) + x;
                    int* errorPixel = reinterpret_cast<int*>(errorRow2) + x;
                    for (int xx = 0; xx < w; ++xx) {
                        int test = p[(bestPattern*_block.y + yy)*w + xx];
                        int target = inputPixel[xx] + errorPixel[xx]/4;
                        int d = target - test;
                        int weight = (xx == 0 || xx == _block.x ? 1 : 2);
                        lineScore += weight*d*d;
                        int error = weight*d;
                        errorPixel[xx + 4] += (error*_diffusionHorizontal)/256;
                        reinterpret_cast<int*>(errorRow2 + _error.stride())[
                            x + xx] += (error*_diffusionVertical/256);
                    }
                    inputRow2 += _ntscInput.stride();
                    errorRow2 += _error.stride();
                }
            }
            int address;
            if ((_mode & 2) != 0 && _scanlinesPerRow == 2) {
                address = ((y & 1) << (_logCharactersPerBank + 1)) +
                    (y >> 1)*_horizontalDisplayed*2;
            }
            else
                address = (y/_block.y)*_horizontalDisplayed*2;
            _data->change(0, address, _horizontalDisplayed*2, &_rowData[0]);
            _program->updateOutput();
            bool advance = false;
            if (_testConfig) {
                if (lineScore < _configScore) {
                    _configScore = lineScore;
                    _bestConfig = _config;
                }
                ++_config;
                if (_config == _endConfig) {
                    _config = _bestConfig;
                    _configs[y] = _bestConfig;
                    _testConfig = false;
                    _configScore = 0x7fffffffffffffffUL;
                }
                else {
                    savedError.copyTo(_error.subBitmap(Vector(0, y),
                        errorLineSize));
                    _error.subBitmap(Vector(0, y + 1), errorLineSize).fill(0);
                }
            }
            else {
                advance = true;
                _testConfig = (_startConfig + 1 != _endConfig);
                _config = _startConfig;
            }
            if (advance) {
                _inputRow += _ntscInput.stride() * _block.y;
                _errorRow += _error.stride() * _block.y;
                y += _block.y;
                if (y >= _size.y + 1 - _block.y)
                    return;
            }
            if (cancelling())
                return;
        }
    }
    void config()
    {
        switch (_config) {
            case 0x50:
            case 0x51:
                _block.x = 16;
                _patternCount = 0x10000;
                break;
            case 0xd0:
            case 0xd1:
                _block.x = 8;
                _patternCount = 0x10000;
                break;
            default:
                _block.x = 4;
                _patternCount = 16;
                break;
        }
        if ((_config & 0x80) == 0)
            _hdotsPerChar = 16;
        else
            _hdotsPerChar = 8;
    }
    void savePalettes(String outputFileName)
    {
        if (_startConfig + 1 == _endConfig)
            return;
        FileStream stream = File(outputFileName, true).openWrite();
        for (int y = 0; y < _size.y; ++y) {
            int c = _configs[y];
            if ((_mode & 0x80) != 0)
                stream.write<Byte>(c == 80 ? 0x08 : (c < 64 ? 0x0a : 0x1a));
            if (c == 80)
                stream.write<Byte>(0);
            else
                if (c >= 64)
                    stream.write<Byte>(c & 0x0f);
                else
                    if (c >= 16 && c < 48)
                        stream.write<Byte>(c ^ 0x30);
                    else
                        stream.write<Byte>(c);
        }
    }
    void plotPattern(Byte* rgbi, int pattern, int line)
    {
        int modeAndPalette = modeAndPaletteFromConfig(_config);
        if ((modeAndPalette & 3) == 2)
            pattern <<= 4;
        UInt64 r = _sequencer->process(pattern, modeAndPalette & 0xff,
            modeAndPalette >> 8, line / _scanlinesRepeat, false, 0);
        int hdots = 8;
        if ((modeAndPalette & 3) == 0) {
            // For -HRES-GRPH need 16 hdots
            hdots = 16;
        }
        for (int x = 0; x < hdots; ++x)
            rgbi[x] = (r >> (x * 4)) & 0x0f;
    }
    int modeAndPaletteFromConfig(int config)
    {
        int b = _mode & 0x24;
        if (config < 0x40)
            return (config << 8) | 0x0a | b;
        if (config < 0x50)
            return ((config & 0x0f) << 8) | 0x1a | b;
        if (config == 0x50)
            return 0x08 | b;
        if (config == 0x51)
            return 0x18 | b;
        if (config < 0xc0)
            return ((config & 0x3f) << 8) | 0x0b | b;
        if (config < 0xd0)
            return ((config & 0x0f) << 8) | 0x1b | b;
        if (config == 0xd0)
            return 0x09 | b;
        return 0x19 | b;
    }

    void setDiffusionHorizontal(double diffusionHorizontal)
    {
        _diffusionHorizontal = static_cast<int>(diffusionHorizontal*256);
    }
    double getDiffusionHorizontal() { return _diffusionHorizontal/256.0; }
    void setDiffusionVertical(double diffusionVertical)
    {
        _diffusionVertical = static_cast<int>(diffusionVertical*256);
    }
    double getDiffusionVertical() { return _diffusionVertical/256.0; }
    void setDiffusionTemporal(double diffusionTemporal)
    {
        _diffusionTemporal = static_cast<int>(diffusionTemporal*256);
    }
    double getDiffusionTemporal() { return _diffusionTemporal/256.0; }
    void setMode(int mode) { _mode = mode; initData(); }
    int getMode() { return _mode; }
    void setPalette(int palette) { _palette = palette; initData(); }
    int getPalette() { return _palette; }
    void setScanlinesPerRow(int v) { _scanlinesPerRow = v; initData(); }
    int getScanlinesPerRow() { return _scanlinesPerRow; }
    void setScanlinesRepeat(int v) { _scanlinesRepeat = v; initData(); }
    int getScanlinesRepeat() { return _scanlinesRepeat; }
    void setPhase(int phase) { _phase = phase; initData(); }
    int getPhase() { return _phase; }
    void setInterlace(int interlace) { _interlace = interlace; initData(); }
    int getInterlace() { return _interlace; }
    void setInterlaceSync(bool interlaceSync)
    {
        _interlaceSync = interlaceSync;
        initData();
    }
    bool getInterlaceSync() { return _interlaceSync; }
    void setInterlacePhase(bool interlacePhase)
    {
        _interlacePhase = interlacePhase;
        initData();
    }
    bool getInterlacePhase() { return _interlacePhase; }
    void setFlicker(bool flicker) { _flicker = flicker; initData(); }
    bool getFlicker() { return _flicker; }
    void setQuality(double quality) { _quality = quality; }
    double getQuality() { return _quality; }
    void setCharacterSet(int characterSet) { _characterSet = characterSet; }
    int getCharacterSet() { return _characterSet; }
    double getHue() { return _hue; }
    void setHue(double hue) { _hue = hue; }
    double getSaturation() { return _saturation; }
    void setSaturation(double saturation) { _saturation = saturation; }
    double getContrast() { return _contrast; }
    void setContrast(double contrast) { _contrast = contrast; }
    double getBrightness() { return _brightness; }
    void setBrightness(double brightness) { _brightness = brightness; }
    void setConnector(int connector) { _connector = connector; }
    void setRollOff(double rollOff) { _rollOff = rollOff; }
    double getRollOff() { return _rollOff; }
    void setChromaBandwidth(double chromaBandwidth)
    {
        _chromaBandwidth = chromaBandwidth;
    }
    double getChromaBandwidth() { return _chromaBandwidth; }
    void setLumaBandwidth(double lumaBandwidth)
    {
        _lumaBandwidth = lumaBandwidth;
    }
    double getLumaBandwidth() { return _lumaBandwidth; }

private:
    void initData()
    {
        if (!_active)
            return;
        Byte cgaRegisters[25] = { 0 };
        _hdotsPerChar = (_mode & 1) != 0 ? 8 : 16;
        _horizontalDisplayed = (_size.x + _hdotsPerChar - 1)/_hdotsPerChar;
        int scanlinesPerRow = _scanlinesPerRow*_scanlinesRepeat;
        int rows = (_size.y + scanlinesPerRow - 1)/scanlinesPerRow;
        _logCharactersPerBank = 0;
        while ((1 << _logCharactersPerBank) < _horizontalDisplayed*rows)
            ++_logCharactersPerBank;
        int horizontalTotal = _horizontalDisplayed + 272/_hdotsPerChar;
        int horizontalSyncPosition = _horizontalDisplayed + 80/_hdotsPerChar;
        int totalScanlines = _size.y + 62;
        int verticalTotal = totalScanlines/scanlinesPerRow;
        int verticalTotalAdjust =
            totalScanlines - verticalTotal*scanlinesPerRow;
        if (verticalTotal > 128 &&
            verticalTotal < (32 - verticalTotalAdjust)/scanlinesPerRow + 128) {
            verticalTotalAdjust += (verticalTotal - 128)*scanlinesPerRow;
            verticalTotal = 128;
        }
        int verticalSyncPosition = rows + 24/scanlinesPerRow;
        int hdotsPerScanline = horizontalTotal*_hdotsPerChar;
        cgaRegisters[0] = _logCharactersPerBank;
        cgaRegisters[1] = (horizontalTotal - 1) >> 8;
        cgaRegisters[2] = _horizontalDisplayed >> 8;
        cgaRegisters[3] = horizontalSyncPosition >> 8;
        cgaRegisters[4] = (verticalTotal - 1) >> 8;
        cgaRegisters[5] = rows >> 8;
        cgaRegisters[6] = verticalSyncPosition >> 8;
        cgaRegisters[7] = _mode;
        cgaRegisters[8] = _palette;
        cgaRegisters[9] = (horizontalTotal - 1) & 0xff;
        cgaRegisters[10] = _horizontalDisplayed & 0xff;
        cgaRegisters[11] = horizontalSyncPosition & 0xff;
        cgaRegisters[12] = 10;
        cgaRegisters[13] = (verticalTotal - 1) & 0xff;
        cgaRegisters[14] = verticalTotalAdjust;
        cgaRegisters[15] = rows & 0xff;
        cgaRegisters[16] = verticalSyncPosition & 0xff;
        cgaRegisters[17] = 2;
        cgaRegisters[18] = _scanlinesPerRow - 1;
        cgaRegisters[19] = 6;
        cgaRegisters[20] = 7;
        _data->change(0, -25, 25, &cgaRegisters[0]);
        int last = _horizontalDisplayed*rows*2 - 1;
        if ((_mode & 2) != 0)
            last += 2 << _logCharactersPerBank;
        _data->change(0, last, 0);
        _data->setTotals(hdotsPerScanline*totalScanlines, hdotsPerScanline - 2,
            static_cast<int>((hdotsPerScanline - 2)*(totalScanlines + 0.5)));
    }

    bool _active;
    int _phase;
    int _mode;
    int _palette;
    int _scanlinesPerRow;
    int _scanlinesRepeat;
    int _connector;
    Vector _size;
    Bitmap<SRGB> _input;
    CGAComposite _composite;
    NTSCDecoder _decoder;
    Program* _program;
    CGAData* _data;
    CGASequencer* _sequencer;
    Array<SInt16> _patterns;
    Bitmap<SRGB> _input2;
    const Byte* _inputRow;
    Byte* _errorRow;
    int _y;
    Bitmap<SInt16> _ntscInput;
    int _patternCount;
    Bitmap<int> _error;
    Bitmap<int> _testError;
    Vector _block;
    int _diffusionHorizontal;
    int _diffusionVertical;
    int _diffusionTemporal;
    int _interlace;
    bool _interlaceSync;
    bool _interlacePhase;
    bool _flicker;
    double _quality;
    int _characterSet;
    UInt64 _configScore;
    Array<bool> _skip;
    int _horizontalDisplayed;
    int _hdotsPerChar;
    int _logCharactersPerBank;
    Array<Byte> _rowData;

    // a config is a mode/palette combination suitable for auto testing
    // The configs are:
    //   0x00..0x3f = 2bpp (background in low 4 bits)
    //   0x40..0x4f = 1bpp
    //   0x50       = 40-column text
    //   0x51       = 40-column text with 1bpp graphics
    //   0x80..0xbf = high-res 2bpp
    //   0xc0..0xcf = 1bpp odd bits ignored
    //   0xd0       = 80-column text
    //   0xd1       = 80-column text with 1bpp graphics
    Array<int> _configs;
    int _startConfig;
    int _endConfig;
    int _config;
    bool _testConfig;
    int _bestConfig;

    double _hue;
    double _saturation;
    double _contrast;
    double _brightness;
    double _rollOff;
    double _chromaBandwidth;
    double _lumaBandwidth;
};

typedef CGAOldMatcherT<void> CGAOldMatcher;






                if (target.x < -1.0f) {
                    float scale = 1.5f/(0.5f - target.x);
                    target.x = -1.0f;
                    target.y = 0.5f + (target.y - 0.5f)*scale;
                    target.z = 0.5f + (target.z - 0.5f)*scale;
                }
                if (target.x > 2.0f) {
                    float scale = 1.5f/(target.x - 0.5f);
                    target.x = 2.0f;
                    target.y = 0.5f + (target.y - 0.5f)*scale;
                    target.z = 0.5f + (target.z - 0.5f)*scale;
                }
                if (target.y < -1.0f) {
                    float scale = 1.5f/(0.5f - target.y);
                    target.x = 0.5f + (target.x - 0.5f)*scale;
                    target.y = -1.0f;
                    target.z = 0.5f + (target.z - 0.5f)*scale;
                }
                if (target.y > 2.0f) {
                    float scale = 1.5f/(target.y - 0.5f);
                    target.x = 0.5f + (target.x - 0.5f)*scale;
                    target.y = 2.0f;
                    target.z = 0.5f + (target.z - 0.5f)*scale;
                }
                if (target.z < -1.0f) {
                    float scale = 1.5f/(0.5f - target.z);
                    target.x = 0.5f + (target.x - 0.5f)*scale;
                    target.y = 0.5f + (target.y - 0.5f)*scale;
                    target.z = -1.0f;
                }
                if (target.z > 2.0f) {
                    float scale = 1.5f/(target.z - 0.5f);
                    target.x = 0.5f + (target.x - 0.5f)*scale;
                    target.y = 0.5f + (target.y - 0.5f)*scale;
                    target.z = 2.0f;
                }

