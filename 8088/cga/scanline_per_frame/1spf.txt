With hsync width 0, htotal = 0x66, get an active area with:
  hsync position = 0x53  yes
                   0x56  yes
                   0x57  yes
                   0x58  no
  hsync position = 0x5a  no
With hsync width 0xf, htotal = 0x66, get an active area with:
                   0x58  yes
                   0x59  no

if hsync_position + hsync_width > htotal + 1  then we don't get an active area
if the hsync never starts, then this isn't an issue

With horizontal_sync_position = 0x73, horizontal_total = 0x66 (103 characters)
  horizontal_displayed = 0x66  start address latches
  horizontal_displayed = 0x67  start address doesn't latch


So, plan is:
  horizontal_total = 80 and 32 (81 and 33, totalling 114)
  horizontal_displayed = 80  (80 columns in active scanline)
  horizontal_sync_position = 90 and 9 (no hsync in active, hsync at CRT char 90 in inactive)
  horizontal_sync_width = 0 or 15 (doesn't matter)
  vertical_total = 1         (2 rows per CRTC frame)
  vertical_total_adjust = 0  (0 extra scanlines)
  vertical_displayed = 1     (the active scanline forms the active width, the inactive scanline forms the overscan)
  vertical_sync_position = 25  (doesn't matter for now)
  interlace_mode = 0         (non-interlaced)
  max_scan_line_address = 0  (1 scanline per row)

Sequence:
  CRT char  CRTC char  raster             CPU
    0         0        active start
                                          Set horizontal_sync_position to 90
    9         9
                                          Set horizontal_total to 80
   32        32
                                          Set start address
   80        80        inactive start
   81         0        second CRTC frame  Set horizontal_sync_position to 9
   90         9        hsync start
                                          Set horizontal_total to 32
  106        25        hsync end

  114 = 0    33 = 0    active start



Distance from palette change to hsync start = 144 cycles
Palette write is at char 36 == cycle 96
palette write is at cycle 1420, first write at cycle 1299, so first write is at -25, which is 37 cycles too early


Distance from palette change to hsync start = 120 cycles
Palette write is at char 45 == cycle 120


What is the latency of waitForDisplayEnable? Something like 39.25 cycles - too many to be able to avoid cycle counting
  Presumably it takes 39 cycles when there's no refresh

2 scanlines is 1824 hdots
39 cycles is 117 hdots      1824 % 117 == 69  117 % 69 == 48  69 % 48 == 21  48 % 21 == 6  21 % 6 == 3  so gcd(1824, 117) == 3  == 1 CPU cycle
40 cycles is 120 hdots      1824 % 120 == 24  so gcd(1824, 120) == 24  == 8 CPU cycles, this could miss the pulse



Set horizontal_total to 32             0:80 - 1:00    34   a   1301   0  0      1299   0   0
Set horizontal_displayed to 32         0:80 - 1:00    34   b   1329  28 11      1319  20   8
Set horizontal_sync_position to 90     0:90 - 1:09    33   c   1357  56 21      1339  40  15
Set horizontal_displayed to 80         0:00 - 0:32    32   d   1390  89 33      1399 100  38
Set horizontal_total to 80             0:00 - 0:32    80   e   1418 117 44      1419 120  45
Set horizontal_sync_position to 9      0:09 - 0:90    81   f   1451 150 56      1439 140  53
Set start_address_high                                                          1480 181  68
Set start_address_low                                                           1508 209  78


0        10        20        30        40        50        60        70        80        90       100       110   0        10        20        30        40        50        60        70        80        90       100       110
|         |         |         |         |         |         |         |         |         |         |         |   |         |         |         |         |         |         |         |         |         |         |         |
                                                                                          Ssssssssssssssss
                                                                                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                                                                                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
                                                                                bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                                                                                bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
ccccccccc                                                                                 ccccccccccccccccccccccccccccccccc                                                                                 cccccccccccccccccccccccc
dddddddddddddddddddddddddddddddd                                                                                  dddddddddddddddddddddddddddddddd
eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee                                                                                  eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff                                 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                                                                                 a       b      c                      d      e       f              H         L


          x              x        x          x                                   x          x         x           x          x            x        x          x
                                                                                 a          b         c           d          e            f        H          L
                                                                                                     a          b         c           d          e            f        H          L






1301   0
1329  11
1357  21
1395  35
1423  46
1454  58
1482  68
1510  78

In 1spf_intermittent, when it's working, why are there only a few initial phases where it works? There should be about 8.
How sure are we that the CRTC works by counting up and comparing rather than by loading and counting down?
  Pretty sure - counting down would require more transistors and horizontal probably works the same way as vertical
There is something wrong with my model of how the CRTC works. Possible problems:
  Counting down instead of up
    How could we test this?
      Change horizontal displayed etc during active time and see what happens

Plan:
  Display lockstep_visible and see if the CRTC copes with a 1-column screen
    It does, but the column could still be free-running
      Will need to have refresh off

"in al,dx ; stosb" is 21 cycles == 63 hdots
4*8 == 32 hdots
gcd(63, 32) = 1

waitForDisplayEnable == 37 cycles with refresh off


VMX, VSX, -misel



  Figure out why 1spf_intermittent is doing differenet things despite being in lockstep

  Try modifying values slightly to see how it affects number of working nop-counts


With refresh disabled, "readPIT16 0 / stosw" is 83 cycles (20.75 IOs)


Phase 2 - worked with initial=70 (twice) but then not in 1spf_intermittent.bin ?  Did I change something between them? No
  Try 66
  Try 61, 63, 66, 69, 71

Phase 4 - worked with initial=21 then worked in  1spf_intermittent.bin as well   13 NOPs before refresh set
  This doesn't work phase 2



New version (with "initCGA 1" and safeRefresh in place again)
Phase 2, 1spf2_intermittent.bin



In all our experiments, we seem to get overscan and active swapped much more often than correct
  This suggests there is some problem with having a scanline that has active data but no hsync


Plan:
  Try with 1 row of 2 scanlines
    That will put things in overscan though
  Try having vertical_displayed == 2 and setting horizonta_displayed == 1 in the overscan - then both scanlines are active and there's no asymmetry problem
    Then increase htotal for active scanline to push the extra column under the bezel
  Can we make do without moving hsync? That implies having hsync in the long scanline
    Suppose we want 15 characters for hsync (90-105) - then we have 9 characters


Suppose our two horizontal totals are tl and tr, tl+tr == 114, tl>tr. Left scanline is 0 to tl, right scanline is tl to tl+tr
e: Set ht=tl between 0 and tr (width tr)
a: Set ht=tr between tl and tl+tr (width tr)
Suppose our two horizontal displayed values are dl and dr. dl>dr. dl<=tl. dr<=tr. dl=80. Want to minimize dr.
d: Set hd=dl between tl+dr and dr (width (tl+tr+dr)-(tl+dr) == tr)
b: Set hd=dr between dl and tl+dr (width dr+tl-dl). So we can have dr=1 safely
Suppose our two horizontal sync positions are sl and sr. sl > tl to suppress sync. sr < tr-sw  (sw = sync width)
c: Set hs=sl between tl+sr and sr (width (tl+tr+sr)-(tl+sr) == tr)
f: Set hs=sr between sr and tl+sr (width tl)

Worked example:
  active_left(80)  overscan_left(N)  active_right(1)  overscan_right(1)  sync(15)  overscan_final(17-N)
  Want the sync to be at 90, which gives N=8
  tl = 80+N = 88         (program 0x57)
  tr = 1+1+15+17-N = 26  (program 0x19)
  dl = 80
  dr = 1
  sl = 90
  sr = 2
  a width = tr = 26
  b width = dr+tl-dl = 1+88-80 = 9 characters = 72 hdots = 24 cycles = 6 IOs
  c width = tl = 26
  d width = tr = 26
  e width = tr = 26
  f width = tl = 88
0        10        20        30        40        50        60        70        80        90       100       110   0        10        20        30        40        50        60        70        80        90       100       110
|         |         |         |         |         |         |         |         |         |         |         |   |         |         |         |         |         |         |         |         |         |         |         |
                                                                                          Sssssssssssssss
                                                                                        aaaaaaaaaaaaaaaaaaaaaaaaaa                                                                                        aaaaaaaaaaaaaaaaaaaaaaaaaa
                                                                                bbbbbbbbb                                                                                                         bbbbbbbbb
cc                                                                                        cccccccccccccccccccccccccc                                                                                        cccccccccccccccccccccccc
d                                                                                        dddddddddddddddddddddddddd                                                                                        ddddddddddddddddddddddddd
eeeeeeeeeeeeeeeeeeeeeeeee                                                                                         eeeeeeeeeeeeeeeeeeeeeeeee
  fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff                           fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
                                                                                 b          a        d        c           e            f


b  Horizontal Displayed     right 0x0101   1
a  Horizontal Total         right 0x1900  26
d  Horizontal Displayed     left  0x5001  80
c  Horizontal Sync Position left  0x5702  88
e  Horizontal Total         left  0x5700  88
f  Horizontal Sync Position right 0x0202   2


Suppose we have a 34-character wide initial state

So, order is badcefHLPS


45-48
46,48
4: 46,48,49


With 34-character initial state and one "times 6 nop" block:
  phase2: 2, 4, 5
  phase4: 2, 5
Then with 1spf4_single, 2 works with phase2 but not phase4. 2 not reliable?
Same story with 5 - works (phase4) with 1spf4 but not 1spf4_single. Works with both in phase2

With 34-character initial state and two "times 6 nop" blocks, no usable values at all in phase4

With 34-character initial state and three "times 6 nop" blocks:
  phase2: 0, 3
Neither reliable in both phases with 1spf4_single

With 34-character initial state and four "times 6 nop" blocks:
  phase2: 1


With 34-character initial state, one "times 6 nop" block and 15 sync width
  phase4: 2, 4, 5

With 34-character initial state, one "times 6 nop" block and 10 sync width
  phase4: 2, 3, 5

With 34-character initial state, one "times 6 nop" block and 10 sync width, later capture
  phase4: 3

With 34-character initial state, one "times 6 nop" block and 15 sync width, later capture
  phase4: 1, 4
  phase4: 3

With 34-character initial state, one "times 6 nop" block and 15 sync width and lockstep
  phase2: 1, 2, 4
  phase2: 1, 2, 4
  phase2: 1, 2, 4
  phase4: 2, 4, 5
  phase2: 1, 2, 4
  1spf4_single:
    2, 2, 2, 4, 2, 4, 2, 2, 4, 4




None of these are reliable.
  Can we make it reliable with a smaller hsync width?
    If so, try increasing overscan_final so that we can use width 15
  Try increasing one of the 1-character spans to 2



ax = port value
bx = temp
cx = spare
dx = port address
si = sound
di = spare
sp = start addresses
bp = rasters




Phase 0
11111111 00000000 00000000 00000000 11111111 00000000 00000000 00000000 11111111 00000000 00000000 00000000  CRTC
I            I             I            I             I            I             I            I              Phase 0
 I            I             I            I             I            I             I            I              Phase 1
  I            I             I            I             I            I             I            I              Phase 2
   I            I             I            I             I            I             I            I              Phase 3

CGA clock is 16 hdots
PIT clock is 12 hdots
100000000000000010000000000000001000000000000000  CGA

100000000000100000000000100000000000100000000000  Phase 0
010000000000010000000000010000000000010000000000  Phase 1
001000000000001000000000001000000000001000000000  Phase 2
000100000000000100000000000100000000000100000000  Phase 3

100000001000000010000000 HRES CRTC


1sof4 with es and 5702 optimizations:
  phase2: 0-3
  phase4: 0-1
1sof4 with es and 5702 optimizations, 46 steps:
  phase2: 22, 24, 25, 26
  phase4: 20, 22, 23, 24

1spf_unrolled:
  phase2: 2, 3, 4, 5
  phase4: 1, 2, 3, 4, 5


TODO:
  Last scanline is repeated





Fixing up last scanline
  Currently, CRTC-scanline 0 is short and CRTC-scanline 1 is long
  Is this is unavoidable or just a consequence of how it self-synchronizes?
    Does not seem to be unavoidable - it's the other way around on VWytseIj0XwW8P4623.png.raw (1spf4)
    However, changing ES to 5702 (so that no sync pulses are skipped) yields a large chunk of overscan at the top
  Assume CRTC-scanline 0 is short and CRTC-scanline 1 is long:
    Scanline -1:
      Left half is last of the overscan CRTC-scanlines
        Set horizontal total and horizontal sync position as if it's a normal scanline
        Can't set vertical total yet, so set start address for scanline 0
        Could set palette register but the effect would persist for two scanlines
      Right half is CRTC-scanline 0 as normal
    Scanline 0:
      Left half:
        Need to set vertical total. Do this instead of setting the palette

    Scanline 199:
      Left half
        Set vertical total instead of start address
        set horizontal total and horizontal sync position
      Right half:
        CRTC scanline 2
    Scanline 200:
      CRTC scanline 3
    Scanline 261 == -1
      CRTC scanline 64

With last-scanline fix:
  phase2: 28, 29, 30, 31, 32

Plan:
  What to do about DRAM refresh?
    It can be off for about 23 scanlines
    Do we really need to synchronize with it?
      We might have more than a refresh's worth of "slop" in the CPU/CRTC timings, but we need to make sure that the inner loop takes 304 cycles no matter where the refresh falls
        Try stability on my machine with many different amounts of time between setup of PIT channels 0 and 1



Done:

Test 1spf4.bin with new optimizations (es and 5702)
Before the critical loop starts, need to:
  Wait for scanline 0 to start
  Set r0=0x57, r2=0x57, (r6=0x02), r4=0x01, r12=high(1), r13=low(1)
At the end of the critical loop, need to:
  Wait for scanline 199 to start
  Set r0=0x71, r2=0x5a, (r6=0x01), r4=0x40, r12=high(next 0), r13=low(next 0)
  Try a port access to get 304 cycles for start-of-frame in trace
Get 304 cycles in trace for first scanline
Realign loop to scanline edge
Refactor in macro to avoid duplication
Set up data structures to display something
  Animation of rose
    Create table of start address for y position
      Does old restarts have 256 possible y positions?

Set CRTC to normal frame
Align CPU with CRTC top-left to display-enable-polling precision (using display-enable polling)
Align PIT with CRTC by starting it at period 19912
Realign to IO precision by using display-enable polling and a PIT period of 19911
Add adjustment parameter by having one PIT frame longer or shorter than 19912 PIT cycles

