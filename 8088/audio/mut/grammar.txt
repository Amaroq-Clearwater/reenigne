Program := Statement*;
Statement := (Assignment | Expression | IncludeStatement) ";";
IncludeStatement := "include" StringConstant;
Assignment := Identifier "=" Expression;
Expression := VoiceExpression ("|" VoiceExpression)*;
VoiceExpression := AdditiveExpression ("&" AdditiveExpression)*;
AdditiveExpression := MultiplicativeExpression (("+" | "-") MultiplicativeExpression)*;
MultiplicativeExpression := PowerExpression (("*" | "/" | "@") PowerExpression)*;
PowerExpression := SlicedElement ["^" PowerExpression];
SlicedElement := Element ("[" Expression "]")*;
Element := [("{" Program "}")* ("true" | "false" | Number | "load" "(" StringConstant ")" | StringConstant | Identifier | "(" Expression ")") ("{" Program "}")* ];


Types:
  * Number
  * Potential
  * Frequency
    * Hz
  * Time
    * s
  * Sample == function from Number (0..1) to Voltage, conceptually. May be stored as a frequency-domain function.
    * sine
    * square
    * triangle
    * sawtooth
    * whiteNoise
  * Waveform (a Sample at a particular frequency)
    * % == output from previous voice
  * Sequence<Number>
  * Sequence<Frequency>
  * Sequence<Sample>
  * Sequence<Waveform>
  * VoiceSet<Number>
  * VoiceSet<Frequency>
  * VoiceSet<Sample>
  * VoiceSet<Waveform>
  * Table<Number>
  * Table<Frequency>
  * Table<Sample>
  * Table<Waveform>

Operators:
  () parentheses
  {} embedded statement
  ^ convolution, power (RTL)
  - unary negative
  + unary positive
  @ time-scale
  * multiplication
  / division
  + addition
  - subtraction
  & voice
  | sequence
  = assignment


+-*/^@
  .SVT

. .SVT
S SSTT
V VTVT
T TTTT


| .SVT

. SSTT
S SSTT
V TTTT
T TTTT


& .SVT

. VTVT
S TTTT
V VTVT
T TTTT


+-         Number     Frequency  Time    Sample   Waveform
Number     Number     !          !       !        !
Frequency  !          Frequency  !       !        !
Time       !          !          Time    !        !
Sample     !          !          !       Sample   !
Waveform   !          !          !       !        Waveform


*          Number     Frequency  Time    Sample   Waveform
Number     Number     Frequency  Time    Sample   Waveform
Frequency  Frequency  !          Number  !        !
Time       Time       Number     !       !        !
Sample     Sample     !          !       Sample   !
Waveform   Waveform   !          !       !        Waveform

/          Number     Frequency  Time    Sample   Waveform
Number     Number     Frequency  Time    Sample   Waveform
Frequency  Time       Number     !       !        !
Time       Frequency  !          Number  !        !
Sample     Sample     !          !       Sample   !
Waveform   Waveform   !          !       !        Waveform

^          Number     Frequency  Time    Sample   Waveform
Number     Number     ?          ?       Sample   Waveform
Frequency  !          !          !       !        !
Time       !          !          !       !        !
Sample     Sample     !          !       Sample   !
Waveform   Waveform   !          !       !        Waveform

@          Number     Frequency  Time    Sample   Waveform
Number     !          !          !       Sample   Waveform
Frequency  !          !          !       Waveform !
Time       !          !          !       !        Sample
Sample     !          !          !       !        !
Waveform   !          !          !       !        !

|          Number     Frequency  Time    Sample   Waveform
Number     SNumber    !          !       !        !
Frequency  !          SFrequency !       !        !
Time       !          !          STime   !        !
Sample     !          !          !       SSample  !
Waveform   !          !          !       !        SWaveform

&          Number     Frequency  Time    Sample   Waveform
Number     VNumber    !          !       !        !
Frequency  !          VFrequency !       !        !
Time       !          !          VTime   !        !
Sample     !          !          !       VSample  !
Waveform   !          !          !       !        VWaveform





  * Envelope == function from Number to Number
Envelope adsr(Time t) { if (t < at) { return t*ar; } if (t < dt + at) { return t*at- ... } ... }
  Actually implement as a Waveform which is point-multiplied by the Waveform you want to envelope



Waveform @ Number yields Waveform
Waveform @ Frequency yields Sample
Sample @ number yields Sample


All Numbers kept as Rational internally until they get too big, at which point we switch to double.

Have a way of defining variables in a particular voice,

We need @ as well as * because given a Waveform we want to be able to adjust its pitch and amplitude
  Waveform w;
  w*2  // double volume
  w@2  // double frequency
Similarly with a Sample:
  Sample s;
  s*2  // double volume
  s@2  // double frequency

Given "Sample s" and "Frequency f" should s*f be synonymous to s@f?

% is the current output from the previous voice (a Waveform)

. is just a variable (conventially per voice) which is pronounced "default" and is generally used as the sample for that voice.

It would be nice to be able to redefine variables right in the grid:
  {.=sine;} .@C2

Inside {} you can have statements inside an expression (no value, just side effects)

Make Sample*Sample do pointwise multiplication (ring modulation)
Make Waveform*Waveform do pointwise multiplication
Make Sample^Sample do convolution

(a^b)(z) == integral(x=-inf..inf, a(x)*b(z-x))
  So we can convolve a waveform with another waveform

It would be nice to be able to create filters (e.g. low-pass, high-pass, bandpass)
  We could generate filter waveforms directly, but it would be nice to be able to express them in the frequency domain
  If we consider a Sample==Number->Number and Waveform==Time->Number then Filter==Frequency->Number
  So we can make filters by using (e.g.) Sample

Have an FFT operator ~
  Sample and Waveform are conceptually continuous valued and repeating
   Therefore the output of ~ on one of these gives a discrete function of infinite extent
  Since the time-reversal operator is @-1, we could make the Fourier Transform operator @((-1)^(1/2))
   Can also make chirps this way
   Does @2 have a different meaning in the LCT sense than the meaning we're giving it?
     No - time-scaling is a perfectly good LCT
   How can we efficiently do fractional fourier transformations?
     http://www.chronowake.com/frft.pdf suggests we can do it by multiplying by a chirp before and after the FFT (see section 6.5)
     Also see (20) on page 36 of the same PDF? (Or is that a different definition?)
   Should we also use @ instead of ^ for convolution?

Need a shift operator shift(x) which is a delta function at offset x.
  Convolve this with a Sample (or @Hz version for Waveform) to apply a time shift
  Need a data type for a distribution
  Can actually generate this by doing an FFT of a sine

Do all computations internally with complex numbers, just take the real part when outputting
  sine is actually exp(i*x). What are the imaginary parts of square, triangle, sawtooth and whiteNoise?

Syntax for functions:
  major(x) = x + x@5/4 + x@3/2;
  minor(x) = x + x@6/5 + x@3/2;
  If we allow recusion, our language becomes Turing complete

Also want to leave space for a stereo operator, maybe %%
  Sample%%Number or Waveform%%Number puts it on the left channel (-1), right channel (+1), center (0) or somewhere else along the real line

Suppose we have

a = sine;
{ a = square; } &;
output =
  a &;  // The a here means the one in voice 0, i.e. square

a = sine;
{ & { a = triangle; } } &;
output =
  { c = d & { b = a; } ; } c &;  // The a here means the one in voice 0`1, i.e. triangle? Or a new voice, meaning only one level is transferred over {}? - the latter seems hard to understand

Generalized Samples can be finite (repeating) or infinite
  Therefore instead of indexing by 0..1 we should index by 0..extent (where extent may be infinite)

A distribution is a (multiple) derivative of a continuous function
  I think the number of discontinuities in the first derivative must be countable, since if you can't isolate them then the original function won't be continuous
    We should probably be able to get away with enumerated discontinuities
      So it's a continuous function plus a sum of delta functions, each one of which may be differentiated any number of times and scaled. So a discontinuity is:
        int order;  // 1 for delta, N for derivative of N-1
        Complex scale;  // scale factor
        Scalar position;

We want to evaluate waveforms, samples and filters lazily so that we can work out what resolution we need them at
However, we also have functions and | requires knowing the current value of division
  division must be a scalar - we currently don't have any way of getting a number from a waveform so we can evaluate numbers strictly

1: Parse everything into an AST
2: Evaluate numbers and annotate | with extents
3: Lazily evaluate samples and tables

Is division dynamically scoped or lexically scoped? Other variables?
  I think this might want to be dynamically scoped language

Output can be number (dimensionless) - DC, Waveform, Table<DC, s> or Table<Waveform, s> - i.e. something indexed by time


