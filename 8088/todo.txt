How are bytes removed from the prefetch queue?
  Model 1: Bytes are removed as they are decoded
    Cycle 1: Opcode byte removed from prefetch queue
    Cycle 2: ModRM byte removed from prefetch queue
  Model 2: All instruction bytes are removed when execution starts. If the instruction is longer than 4 bytes, further bytes are removed immediately after loading.

PUSHF:
  Model 1: 10 cycles on 8086 and 14 on 8088
  Model 2: 10 cycles when aligned and 14 otherwise

PUSH rmw:
  Model 1: 16+EA cycles on 8086 and 24+EA on 8088
  Model 2: 16+EA cycles when aligned and 24+EA otherwise

PUSH r:
  Model 1: 11 cycles on 8086 and 15 on 8088
  Model 2: 11 cycles when aligned and 15 otherwise

How long does SALC take?

When doing an OUT to CGA, is there a wait state?

When doing CGA memory operations, under what condition do we get a wait state?
  What about other peripherals?

Is the "RETF iw" timing correct? (Surely it shouldn't be less than RETF)

Is the "TEST rmw,iw" timing correct? (Surely it shouldn't be the same as "TEST rmb,ib")

Is the AF ever set after an OR operation?

Sanity check the BCD instructions
  Make sure they do the same thing as documented
  Make sure they are useful for their purpose
  Test them against real hardware
  Try to figure out how the flags are defined

Determine behavior of invalid opcodes:
  6x

stateALURegMemImmCalculate _wait=7 code seems odd - check if the real hardware does this

When setting IP, need to abandon currently pending fetch
  Reset abandon flag

Find out what hardware does with "MOV rmw<->segreg" when modRMReg >= 4

Find out what hardware does with LEA when mod == 3

Make sure that "ES: POP [BX]" doesn't

Check that LDS and LES take the same time (HELPPC says LDS is 16+EA which can't be right)
Find out what hardware does with LES/LDS when mod == 3

Determine semantics of WAIT, LOCK, HLT and escape instructions

Check that "POP AX" etc really are 8 instructions

The RET timings seem suspect

Timings for "AAD 0"

Find timings for "JMP cp"

Check timings for "TEST rm,imm" - probably not same for byte and word

Check timings for MUL
  Memory shouldn't be faster than registers, surely?
  Determine if additional cycles are given by 1 bits or 0 bits in source or destination
  Are there 8 or 9 possible cycle counts for byte multiplication? If 8, is *0 the same length as *1 or *0xff the same as *0x7f?
    Similarly with word multiplication
  Timings for IMUL: Penalties for negative inputs? Negative output?

Check that the semantics of x86 remainder is (destination - product)*(negative ? -1 : 1) always

Check the timings for "DEC mw" - HELPPC says 15+EA but I think 23+EA (same as "INC mw") is more likely.

Figure out what "CALL mp" and "JMP mp" do with a register argument
Figure out what opcode FE does with modRMReg() > 1
Figure out what opcodes FE and FF do with modRMReg() == 7