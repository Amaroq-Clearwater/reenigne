Cycles per ccycle            4/3    =   1.3333
Frames per buffer            1      =   1
Pixels per cycle             4      =   4
Fields per buffer            1      =   1
Pixels per ccycle            3      =   3
Cycles per line            228      = 228
CCycles per line           304      = 304
Pixels per line            912      = 912
Lines per second       3281250/209  =  15.6998 K
Cycles per second     39375000/11   =   3.5795 M
CCycles per second    52500000/11   =   4.7727 M
Pixels per second    157500000/11   =  14.3182 M



TCycles per second    13125000/11   =   1.1932 M
CCycles per tCycle           4      =   4
Pixels per tCycle           12      =  12
TCycles per line            76      =  76
Samples per block          256      = 256
Blocks per segment       16384      =  16.384  K


TCycles per sample  Samples per second         CCycles per sample  blocks per second             Seconds per segment
        1           13125000/11  =   1.1932 M          4           1640625/352    =   4.6609 K   5750784/1640625 =   3.5052
        2            6562500/11  = 596.5909 K          8           1640625/704    =   2.3304 K  11501748/1640625 =   7.0106
        4            3281250/11  = 298.2955 K         16           1640625/1408   =   1.1652 K  23003496/1640625 =  14.0212
        8            1640625/11  = 149.1477 K         32           1640625/2816   = 582.6083    46006992/1640625 =  28.0424
       16            1640625/22  =  74.5739 K         64           1640625/5632   = 291.3042    92013984/1640625 =  56.0847
       18            2187500/33  =  66.2879 K         72           1640625/6336   = 258.9370   103514112/1640625 =  63.0943  (1m 3s)
       32            1640625/44  =  37.2869 K        128           1640625/11264  = 145.6521   184027968/1640625 = 112.1694  (1m 52s)
       36            1093750/33  =  33.1439 K        144           1640625/12672  = 129.4685   207028224/1640625 = 126.1886  (2m 6s)   <= 1 voice   505.7364 mHz - 16.5720 KHz
       54            2187500/99  =  22.0960 K        216                                                                               <= 2 voices  337.1576 mHz - 11.0480 KHz
       64            1640625/88  =  18.6435 K        256           1640625/22528  =  72.8260   368055936/1640625 = 224.3389  (3m 44s)
       72             546875/33  =  16.5720 K        288           1640625/25344  =  64.7343   414056448/1640625 = 252.3773  (4m 12s)  <= 3 voices  252.8682 mHz -  8.2860 KHz
       76            3281250/209 =  15.6998 K        304           1640625/26752  =  61.3272   438304768/1640625 = 267.1572  (4m 27s)
       90             437500/33  =  13.2576 K        360           1640625/31680  =  51.7874   517570560/1640625 = 315.4716  (5m 15s)  <= 4 voices
      108            1093750/99  =  11.0480 K        432                                                                               <= 5 voices
      126             312500/33  =   9.4697 K        504                                                                               <= 6 voices
      128            1640625/176 =   9.3217 K        512           1640625/45056  =  36.4130   736111872/1640625 = 448.6777  (7m 28s)
      256            1640625/352 =   4.6609 K       1024           1640625/90112  =  18.2065  1472223744/1640625 = 897.3554 (14m 57s)


Data block:
  0 = counter1 low
  1 = counter1 high
  2 = counter2 low
  3 = counter2 high
  4 = counter3 low
  5 = counter3 high
  6 = counter4 low
  7 = counter4 high

Implementation 1:
  Positions at [0]
  add w[si], imm
  68 cycles per channel sample

CX = sample counter
DX = speaker port
BX = waveform table pointer (BL = 0)
AX = (AH = sample accumulator), (AL = temporary)
SI = data block pointer (data block is at address DS:0)
DI = command address
BP = command data
SP = song pointer
CS = code segment
DS = data segment - same as code address
SS = song
ES = screen segment



Instruction                  Bytes  IO-bytes  BIU-cycles  EU-cycles

looptop:
  mov [di],bp                  2       2          16          18
  es: mov [di],bp              3       2          20          20
  nop                          1       0           4           3
  nop                          1       0           4           3
tempo:
  sub cx,9999                  4       0          16           4

waveform1:
  mov bh,99                    2       0           8           4
velocity1:
  add w[si],9999               4       4          32          30
  inc si                       1       0           4           2
  lodsb                        1       1           8          12
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

waveform2:
  mov bh,99                    2       0           8           4
velocity2:
  add w[si],9999               4       4          32          30
  inc si                       1       0           4           2
  lodsb                        1       1           8          12
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

waveform3:
  mov bh,99                    2       0           8           4
velocity3:
  add w[si],9999               4       4          32          30
  inc si                       1       0           4           2
  lodsb                        1       1           8          12
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

waveform4:
  mov bh,99                    2       0           8           4
velocity4:
  add w[si],9999               4       4          32          30
  inc si                       1       0           4           2
  lodsb                        1       1           8          12
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

  xor si,si                    2       0           8           3
  loop looptop                 2       2          16/8        17/5 (2 IOs to repopulate prefetch queue)

  pop di                       1       2          12          12
  pop bp                       1       2          12          12
;  stosw                        1       2          12          15

end:
  jmp waveform1                2       2          16          15  (2 IOs to repopulate prefetch queue)

; total 60 bytes

; TODO:
;   Can we get better cx behaviour by using jcxz instead of loop and moving nextCommand immediately before waveform1?
;   Put in an "and cl,???" as well?
;   Determine the number of possible tempos
;   Can we get screen writes as well?
;     Problem: wait states. What are they? Present even in 80-column text mode?


; 1 byte at a time
screenWrite:
  mov ax,ac00                  3       0          12           4
  mov es,ax                    2       0           8           2
  mov al,99                    2       0           8           4
  mov b[di],al                 2       1          12          14
  mov ax,cs                    2       0           8           2
  mov es,ax                    2       0           8           2
  nop                          1       0           4           3
  nop                          1       0           4           3
  nop                          1       0           4           3

; 2 bytes at a time
screenWrite:
  mov ax,ac00                  3       0          12           4
  mov es,ax                    2       0           8           2
  mov ax,9999                  3       0          12           4
  mov w[di],ax                 2       2          16          18
  mov ax,cs                    2       0           8           2
  mov es,ax                    2       0           8           2
  nop                          1       0           4           3

Screen memory is b8000 to bbfff
If we use page ac00 then screen memory will be c000-ffff



  mov si,9999                  3       2          20           4
  lodsb                        1       1           8          12
  mov [cccc],si                4       2          24          19
  nop                          1       0           4           3
  nop                          1       0           4           3
  nop                          1       0           4           3
  nop                          1       0           4           3



Commands:
  tempo+2     xx xx  - change how often new song doublewords are read
  waveform1   xx B7  - change volume and timbre of voice 1
  velocity1+2 xx xx  - change pitch of voice 1
  waveform2   xx B7  - change volume and timbre of voice 2
              88 F8  - use ring modulation
  velocity2+2 xx xx  - change pitch of voice 2
  waveform3   xx B7  - change volume and timbre of voice 3
  velocity3+2 xx xx  - change pitch of voice 3
  waveform4   xx B7  - change volume and timbre of voice 4
  velocity4+2 xx xx  - change pitch of voice 4
  end         EB xx  - end of song


Waveform patterns - we can fit in 255
  Waveforms 1, 2 and 3:
    Silence (9)
    18 volume levels for each of:
      Square
      Sine
      Sawtooth
      Triangle
      Noise
      Major
      Minor
  Waveform 4:
    36 volume levels for each of:


Implementation 2:
  Positions at [0]
  lodsw / add ax,imm / stosw
  68 cycles per channel sample

CX = sample counter
DX = speaker port
BX = waveform table pointer
AX = (AH = sample accumulator), (AL = temporary)
SI = data block pointer (data block is at address DS:0)
DI = data block pointer (data block is at address DS:0)
SP = song pointer
BP =

looptop:
  lodsw                        1       2          12          16
velocity1:
  add ax,9999                  3       0          12           4
  stosw                        1       2          12          15
  mov bl,ah                    2       0           8           2
waveform1:
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

  lodsw                        1       2          12          16
velocity2:
  add ax,9999                  3       0          12           4
  stosw                        1       2          12          15
  mov bl,ah                    2       0           8           2
waveform2:
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

  lodsw                        1       2          12          16
velocity3:
  add ax,9999                  3       0          12           4
  stosw                        1       2          12          15
  mov bl,ah                    2       0           8           2
waveform3:
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

  lodsw                        1       2          12          16
velocity4:
  add ax,9999                  3       0          12           4
  stosw                        1       2          12          15
  mov bl,ah                    2       0           8           2
waveform4:
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

  xor si,si                    2       0           8           3
  xor di,di                    2       0           8           3
  loop looptop                 2       2          12/8        17/5 (1 IO to repopulate prefetch queue)

  sub ch,ch                    2       0           8           3
  loop looptop                 2       1          12          17  (1 IO to repopualte prefetch queue)

total:                        57                 308









Implementation 3:
  Positions in cx, si, di and bp
  add r,imm
  56 cycles per channel sample

AX = various
BX = table pointer (BL = 0)
CX = channel 1 velocity
DX = speaker port (0x0042)
SI = channel 2 velocity
DI = channel 3 velocity
BP = channel 4 velocity

velocity1:
  add cx,9999                  4       0          16           4
  mov al,ch                    2       0           8           2
waveform1:
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8
  nop                          1       0           4           3
  nop                          1       0           4           3
  nop                          1       0           4           3

velocity2:
  add si,9999                  4       0          16           4
  mov ax,si                    2       0           8           2
  mov al,ah                    2       0           8           2
waveform2:
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8
  nop                          1       0           4           3
  nop                          1       0           4           3
  nop                          1       0           4           3

velocity3:
  add di,9999                  4       0          16           4
  mov ax,di                    2       0           8           2
  mov al,ah                    2       0           8           2
waveform3:
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8
  nop                          1       0           4           3
  nop                          1       0           4           3
  nop                          1       0           4           3

velocity4:
  add bp,9999                  4       0          16           4
  mov ax,bp                    2       0           8           2
  mov al,ah                    2       0           8           2
waveform4:
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8

;  nop                          1       0           4           3
;  nop                          1       0           4           3
;  nop                          1       0           4           3
;  nop                          1       0           4           3
;  nop                          1       0           4           3
  dec w[counter]               4       4          32          29
  jnz looptop                  2       0                       4/16




  out dx,al                    1       1           8           8
  out 042,al                   2       1          12          10


  xlatb                        1       1           8          11
  mov al,b[bx]                 2       1          12          13






Implementation 4:
  Positions in CS
  Separate high and low bytes
  72 cycles per channel sample
  No registers


                      +---- position high
                      |  +- waveform
                      v  v
  mov al,[9988]  ; A0 88 99


  add b[di+1], 99              4       2          24          23
  adc b[di+9], 99              4       2          24          23
  mov al,b[sample]             3       1          16          10
  out dx,al                    1       1           8           8





Implementation 5:
  Positions in bl, bh, cl, ch, ah
  Separate high and low bytes
  60 cycles per channel sample


  add ah,99                    3       0          12           4
  adc b[di+9], 99              4       2          24          23
  mov al,b[sample]             3       1          16          10
  out dx,al                    1       1           8           8




Implementation 6:
  Positions in cl, ch, ah
  Separate high and low bytes
  Double lookup for volume tables
  80 cycles per channel sample


  add ah,99                    3       0          12           4
  adc b[di+9], 99              4       2          24          23
  mov bl,b[sample]             4       1          20          14
  mov bh,99                    2       0           8           4
  xlatb                        1       1           8          11
  out dx,al                    1       1           8           8



4mat-menu11.mod








22KHz is ~217 CPU cycles per sample or ~54 cycles per voice sample or about 14 IOs (~13 with DRAM refresh)

With volume-dependent samples, 12 IOs:
  add bl,bh
  adc si,bp
  lodsb
  es: add [di], al
  inc di

With frequency-dependent samples, 10 IOs:
  lodsb
  xlatb
  es: add [di], al
  inc di

For first voice, 7 IOs (3 :
  add bl,bh
  adc si,bp
  movsb

Total, 43 IOs out of 54 - 80%

Optimizations needed:
  Pre-adjusting samples for volume
  Computing in advance how many iterations needed, taking into account:
    buffer length
    sample length
    length to change of frequency/volume
  Unrolling loop bodies to maximum length, and starting loop by jumping into appropriate location.
  Using separate loop body for first voice



With original samples and volume tables in DS, 14 IOs:
  add cl,ch
  adc si,bp
  lodsb
  xlatb
  es: add [di], al
  inc di

For first voice, 10 IOs:
  add cl,ch
  adc si,bp
  lodsb
  xlatb
  stosb

Total 52 IOs, 55.06 with refresh = 21.7KHz @100%




PC speaker versions:

1: 66 cycles = 17.1KHz
  mov bh,99       2 0
  add w[si],9999  4 2
  inc si          1 0
  lodsb           1 1
  xlatb           1 1
  out dx,al       1 1
  mov bh,99       2 0
  add w[si],9999  4 2
  inc si          1 0
  lodsb           1 1
  xlatb           1 1
  out dx,al       1 1
  mov bh,99       2 0
  add w[si],9999  4 2
  inc si          1 0
  lodsb           1 1
  xlatb           1 1
  out dx,al       1 1
  mov bh,99       2 0
  add w[si],9999  4 2
  inc si          1 0
  lodsb           1 1
  xlatb           1 1
  out dx,al       1 1
  xor si,si       2 0
  loop loopTop    2 2

2: 72 cycles
  lodsw           1 1
  add ax,9999     4 0
  stosw           1 1
  mov bl,ah       2 0
  mov bh,99       2 0
  xlatb           1 1
  out dx,al       1 1
  lodsw           1 1
  add ax,9999     4 0
  stosw           1 1
  mov bl,ah       2 0
  mov bh,99       2 0
  xlatb           1 1
  out dx,al       1 1
  lodsw           1 1
  add ax,9999     4 0
  stosw           1 1
  mov bl,ah       2 0
  mov bh,99       2 0
  xlatb           1 1
  out dx,al       1 1
  lodsw           1 1
  add ax,9999     4 0
  stosw           1 1
  mov bl,ah       2 0
  mov bh,99       2 0
  xlatb           1 1
  out dx,al       1 1
  xor si,si       2 0
  xor di,di       2 0
  loop looptop    2 2

3: 59 cycles
  add cx,9999     4 0
  mov al,ch       2 0
  mov bh,99       2 0
  xlatb           1 1
  out dx,al       1 1
  add si,9999     4 0
  mov ax,si       2 0
  mov al,ah       2 0
  mov bh,99       2 0
  xlatb           1 1
  out dx,al       1 1
  add di,9999     4 0
  mov ax,di       2 0
  mov al,ah       2 0
  mov bh,99       2 0
  xlatb           1 1
  out dx,al       1 1
  add sp,9999     4 0
  mov ax,sp       2 0
  mov al,ah       2 0
  mov bh,99       2 0
  xlatb           1 1
  out dx,al       1 1
  dec bp          1 0
  jnz looptop     2 2

4: 61 cycles = 18.5KHz (might need to permute this a bit)
  add ah,99       3 0
  adc [di],99     3 2
  mov al,[9988]   3 1
  add bl,99       3 0
  adc [di+11],99  4 2
  add al,[9988]   4 1
  add bh,99       3 0
  adc [di+22],99  4 2
  add al,[9988]   4 1
  add dl,99       3 0
  adc [di+33],99  4 2
  add al,[9988]   4 1
  out 042,al      2 1
  loop loopTop    2 2

5: 57 cycles
  add cx,9999     4 0
  mov bl,ch       2 0
  mov bh,99       2 0
  mov al,[bx]     2 1
  add si,9999     4 0
  mov bx,si       2 0
  xchg bl,bh      2 0
  mov bh,99       2 0
  add al,[bx]     2 1
  add di,9999     4 0
  mov bx,di       2 0
  xchg bl,bh      2 0
  mov bh,99       2 0
  add al,[bx]     2 1
  add sp,9999     4 0
  mov bx,sp       2 0
  xchg bl,bh      2 0
  mov bh,99       2 0
  add al,[bx]     2 1
  out dx,al       1 1
  dec bp          1 0
  jnz looptop     2 2

6: 53 cycles = 21.3KHz
  add cx,9999     4 0
  mov bh,ch       2 0
  mov al,[bx+49]  3 1
  add si,9999     4 0
  mov dx,si       2 0
  mov bh,dh       2 0
  add al,[bx+49]  3 1
  add di,9999     4 0
  mov dx,di       2 0
  mov bh,dh       2 0
  add al,[bx+49]  3 1
  add sp,9999     4 0
  mov dx,sp       2 0
  mov bh,dh       2 0
  add al,[bx+49]  3 1
  out dx,al       1 1
  dec bp          1 0
  jnz looptop     2 2

7: 50 cycles = 22.5KHz
  add cx,9999     4 0
  mov bh,ch       2 0
  mov al,[bx+49]  3 1
  add si,9999     4 0
  mov bx,si       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  add di,9999     4 0
  mov bx,di       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  add sp,9999     4 0
  mov bx,sp       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  out dx,al       1 1
  dec bp          1 0
  jnz looptop     2 2

7a: 50 cycles = 22.5KHz
  add bp,9999     4 0
  mov bx,bp       2 0
  mov bl,99       2 0
  mov al,[bx]     2 1
  add si,9999     4 0
  mov bx,si       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  add di,9999     4 0
  mov bx,di       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  add sp,9999     4 0
  mov bx,sp       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  out dx,al       1 1
  loop looptop    2 2

8: 48 cycles = 23.5KHz - unrolled, 35 bytes = 1872 iterations = 12.5Hz minimum update speed - can't easily update waveforms though
  add cx,[bp]     2 2
  mov bh,ch       2 0
  mov al,[bx+49]  3 1
  add si,[bp+2]   3 2
  mov bx,si       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  add di,[bp+4]   3 2
  mov bx,di       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  add sp,[bp+6]   3 2
  mov bx,sp       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  out dx,al       1 1

9: 52 cycles = 21.6KHz - unrolled, 38 bytes = 1724 iterations = 12.6Hz minimum update speed
  add cx,[bp]     2 2
  mov bx,cx       2 0
  mov bl,[bp+8]   3 1
  mov al,[bx]     2 1
  add si,[bp+2]   3 2
  mov bx,si       2 0
  mov bl,dl       2 0
  add al,[bx]     2 1
  add di,[bp+4]   3 2
  mov bx,di       2 0
  mov bl,dh       2 0
  add al,[bx]     2 1
  add sp,[bp+6]   3 2
  mov bx,sp       2 0
  mov bl,ah       2 0
  add al,[bx]     2 1
  out 042,al      2 1


X: volume table version of 7a: 70 cycles = 16.1KHz
  add bp,9999     4 0
  mov bx,bp       2 0
  mov bl,99       2 0
  mov bh,[bx]     2 1
  mov bl,98       2 0
  mov al,[bx]     2 1
  add si,9999     4 0
  mov bx,si       2 0
  mov bl,99       2 0
  mov bh,[bx]     2 1
  mov bl,98       2 0
  add al,[bx]     2 1
  add di,9999     4 0
  mov bx,di       2 0
  mov bl,99       2 0
  mov bh,[bx]     2 1
  mov bl,98       2 0
  add al,[bx]     2 1
  add sp,9999     4 0
  mov bx,sp       2 0
  mov bl,99       2 0
  mov bh,[bx]     2 1
  mov bl,98       2 0
  add al,[bx]     2 1
  out dx,al       1 1
  loop looptop    2 2

Y: 70 cycles
  add bp,9999     4 0
  mov bx,bp       2 0
  mov bl,0        2 0
  mov bh,[bx+49]  3 1
  mov al,[bx+48]  3 1
  add si,9999     4 0
  mov bx,si       2 0
  mov bl,0        2 0
  mov bh,[bx+49]  3 1
  add al,[bx+48]  3 1
  add di,9999     4 0
  mov bx,di       2 0
  mov bl,0        2 0
  mov bh,[bx+49]  3 1
  add al,[bx+48]  4 1
  add sp,9999     4 0
  mov bx,sp       2 0
  mov bl,0        2 0
  mov bh,[bx+49]  3 1
  add al,[bx+48]  3 1
  out dx,al       1 1
  loop looptop    2 2


Unrollable with volume tables: 77 cycles (theoretical maximum 14.1KHz)
  add cx,[bp]     2 2  ; velocity
  mov bx,cx       2 0
  mov bl,[bp+8]   3 1  ; waveform
  mov bh,[bx]     2 1
  mov bl,[bp+9]   3 1  ; volume
  mov al,[bx]     2 1

  add si,[bp+2]   3 2
  mov bx,si       2 0
  mov bl,dl       2 0
  mov bh,[bx]     2 1
  mov bl,[bp+10]  3 1
  add al,[bx]     2 1

  add di,[bp+4]   3 2
  mov bx,di       2 0
  mov bl,dh       2 0
  mov bh,[bx]     2 1
  mov bl,[bp+11]  3 1
  add al,[bx]     2 1

  add sp,[bp+6]   3 2
  mov bx,sp       2 0
  mov bl,ah       2 0
  mov bx,[bx]     2 1
  mov bl,[bp+12]  3 1
  add al,[bx]     2 1





; MOD player:
; DS = sample pointer
; BP = 0
; SI = temp position
; DI = channel 0 position bits 8..23
; BX = temp sample (BH = 0)
; AL = sample accumulator
; AH = channel 3 position bits 0..7
; CX = channel 1 position bits 8..23
; DX = channel 2 position bits 8..23
; SP = data pointer
; SS = data pointer:
;   0 = channel 0 position bits 0..7
;   1 = channel 1 position bits 0..7
;   2 = channel 2 position bits 0..7
;
;   4 = channel 0 sample
;   6 = channel 0 volume
;   8 = channel 1 sample
;  10 = channel 1 volume
;  12 = channel 2 sample
;  14 = channel 2 volume
;  16 = channel 3 position bits 8..23
;  18 = channel 3 sample
;  20 = channel 3 volume
;  22 = count

loopTop:
  add b[bp],99     3 2
  adc di,9999      4 0
  jnc noOverflow   2 3
  mov di,9999
noOverflow0:
  pop ds           1 2
  mov bl,[di]      2 1
  pop ds           1 2
  mov al,[bx]      2 1        26

  add b[bp+1],99   4 2
  adc cx,9999      4 0
  jnc noOverflow   2 3
  mov cx,9999
noOverflow1:
  mov si,cx        2 0
  pop ds           1 2
  mov bl,[si]      2 1
  pop ds           1 2
  add al,[bx]      2 1        29

  add b[bp+2],99   4 2
  adc dx,9999      4 0
  jnc noOverflow   2 3
  mov dx,9999
noOverflow2:
  mov si,dx        2 0
  pop ds           1 2
  mov bl,[si]      2 1
  pop ds           1 2
  add al,[bx]      2 1        29

  add ah,99        3 0
  pop si           1 2
  adc si,9999      4 0
  jnc noOverflow   2 3
  mov si,9999
noOverflow3:
  mov [bp+16],si   3 2
  pop ds           1 2
  mov bl,[si]      2 1
  pop ds           1 2
  add al,[bx]      2 1        32

  sub sp,18        3 0

  out 042,al       2 1
  dec b[bp+22]     3 2
  jnz loopTop      2 3        16


; total = 132 cycles = 8.5KHz



; Without volume tables:

loopTop:
  add b[bp],99     3 2
  adc di,9999      4 0
  jnc noOverflow   2 3
  mov di,9999
noOverflow0:
  pop ds           1 2
  mov al,[di]      2 1        20

  add b[bp+1],99   4 2
  adc cx,9999      4 0
  jnc noOverflow   2 3
  mov cx,9999
noOverflow1:
  mov si,cx        2 0
  pop ds           1 2
  add al,[si]      2 1        23

  add b[bp+2],99   4 2
  adc dx,9999      4 0
  jnc noOverflow   2 3
  mov dx,9999
noOverflow2:
  mov si,dx        2 0
  pop ds           1 2
  add al,[si]      2 1        23

  add ah,99        3 0
  pop ds           1 2
  pop si           1 2
  adc si,9999      4 0
  jnc noOverflow   2 3
  mov si,9999
noOverflow3:
  push si          1 2
  add al,[si]      2 1        24

  sub sp,8         3 0

  out 042,al       2 1
  dec b[bp+12]     3 2
  jnz loopTop      2 3        16

; total = 106 cycles = 10.6KHz



; Without overflow checking:

loopTop:
  add b[bp],99     3 2
  adc di,0         3 0
  pop ds           1 2
  mov al,[di]      2 1        14

  add b[bp+1],99   4 2
  adc cx,0         3 0
  mov si,cx        2 0
  pop ds           1 2
  add al,[si]      2 1        17

  add b[bp+2],99   4 2
  adc dx,0         3 0
  mov si,dx        2 0
  pop ds           1 2
  add al,[si]      2 1        17

  add ah,99        3 0
  pop ds           1 2
  pop si           1 2
  adc si,0         3 0
  push si          1 2
  add al,[si]      2 1        18

  sub sp,8         3 0

  out 042,al       2 1
  dec b[bp+12]     3 2
  jnz loopTop      2 3        16

; total = 82 cycles = 13.7KHz



; 64kB of samples:

loopTop:
  add b[bp],99     3 2
  adc di,0         3 0
  mov al,[di]      2 1        11

  add b[bp+1],99   4 2
  adc cx,0         3 0
  mov si,cx        2 0
  add al,[si]      2 1        14

  add b[bp+2],99   4 2
  adc dx,0         3 0
  mov si,dx        2 0
  add al,[si]      2 1        14

  add ah,99        3 0
  pop si           1 2
  adc si,0         3 0
  push si          1 2
  add al,[si]      2 1        15

  sub sp,8         3 0

  out 042,al       2 1
  dec b[bp+12]     3 2
  jnz loopTop      2 3        16

; total = 70 cycles = 16.1KHz





; Refinement and patching:

loopTop2:
  times 16 nop
loopTop:
  add dl,99        3 0
  adc si,-1        3 0
  lodsb            1 1         8

  add dh,99        3 0
  adc bp,0         3 0
  add al,[ds:bp]   4 1        11

  add ch,99        3 0
  adc di,0         3 0
  add al,[di]      2 1         9

  add byte[t],99   5 2
  adc bx,0         3 0
  add al,[bx]      2 1        13

  out 0x42,al      2 1
  dec cl           2 0
  jnz loopTop      2 3        10

  xchg ax,bx       1 0
  pop bx           1 2
  pop word[cs:bx]  3 4
  xchg ax,bx       1 0
  mov cl,1         2 0
  jmp loopTop2     2 3

; total = 300 cycles = 15.9kHz
; With refresh period = 19 we get 304 cycles (4 refreshes)



; More refinement and synchronization:

loopTop2:
  times 16 nop
loopTop:
  nop

  add dl,99        3 0
  adc si,-1        3 0
  lodsb            1 1         8

  add dh,99        3 0
  adc bp,0         3 0
  add al,[ds:bp]   4 1        11

  add ch,99        3 0
  adc di,0         3 0
  add al,[di]      2 1         9

  add cl,99        3 0
  adc bx,0         3 0
  add al,[bx]      2 1        13

  out 0x42,al      2 1
  dec ah           2 0
  jnz loopTop      2 3        10

  xchg ax,bx       1 0
  pop bx           1 2
  pop word[cs:bx]  3 4
  xchg ax.bx       1 0
  mov ah,1         2 0
  jmp loopTop2     2 3

; total = 288 cycles


  push dx        1 2
  mov dx,0x3d4   3 0
  mov al,0x0c    2 0
  out dx,al      1 1
  pop dx         1 2




loopTop:
  process ax       0 3 2 1
  xchg ax,tempA
  process ax       1 0 3 2
  xchg ax,tempB
  process ax       2 1 0 3
  xchg ax,tempC
  process ax       3 2 1 0
  loop loopTop


; CL = position bits 0..7
; CH = velocity bits 0..7
; SI = position bits 8..15
; DI = velocity bits 8..15
; AL = sample accumulator
; DX = sample segment
; SP = sample start (-length)
; BX = volume table pointer
; BP = temporaries pointer

loopTop:
  add cl,ch         2 0
  adc si,di         2 0
  jnc noOverflow0   2 2
  mov si,sp
noOverflow0:
  mov ds,dx         2 0
  lodsb             1 1
  ss: xlatb         2 1      15

  xchg cx,[bp]      2 4
  xchg si,[bp+2]    3 4
  xchg di,[bp+4]    3 4
  xchg dx,[bp+6]    3 4
  xchg sp,[bp+8]    3 4
  xchg bx,[bp+10]   3 4      41

loopTop:
  add cl,ch         2 0
  adc si,di         2 0
  jnc noOverflow0   2 2
  mov si,sp
noOverflow0:
  mov ds,dx         2 0
  lodsb             1 1
  ss: xlatb         2 1      15

  xchg cx,[bp+12]   3 4
  xchg si,[bp+14]   3 4
  xchg di,[bp+16]   3 4
  xchg dx,[bp+18]   3 4
  xchg sp,[bp+20]   3 4
  xchg bx,[bp+22]   3 4      42

loopTop:
  add cl,ch         2 0
  adc si,di         2 0
  jnc noOverflow0   2 2
  mov si,sp
noOverflow0:
  mov ds,dx         2 0
  lodsb             1 1
  ss: xlatb         2 1      15

  xchg cx,[bp+24]   3 4
  xchg si,[bp+26]   3 4
  xchg di,[bp+28]   3 4
  xchg dx,[bp+30]   3 4
  xchg sp,[bp+32]   3 4
  xchg bx,[bp+34]   3 4      42

loopTop:
  add cl,ch         2 0
  adc si,di         2 0
  jnc noOverflow0   2 2
  mov si,sp
noOverflow0:
  mov ds,dx         2 0
  lodsb             1 1
  ss: xlatb         2 1      15

  dec b[bp+36]      3 2
  jnz loopTop       2 2       9

; total = 194 cycles



7a with song data: 12.7KHz
looptop:
  db 39 dup 0x90
realLooptop:
  add bp,9999     4 0
  mov bx,bp       2 0
  mov bl,99       2 0
  mov al,[bx]     2 1
  add si,9999     4 0
  mov bx,si       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  add di,9999     4 0
  mov bx,di       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  add sp,9999     4 0
  mov bx,sp       2 0
  mov bl,99       2 0
  add al,[bx]     2 1
  out dx,al       1 1
  loop looptop    2 1

songPointer:
  mov bx,9999                 3 0
  add bx,4                    3 0
  cs: mov [songPointer+1],bx  5 2

  ss: mov ax,[bx]             3 2
  ss: mov bx,[bx+2]           4 2
  cs: mov [bx],ax             3 2
  es: mov [bx],ax             3 2
  mov cx,9999                 3 0
  jmp realLooptop             2 0

; Can we fill up a buffer and empty it while we're updating to avoid slack time?
;   Only with loop unrolling
;   Let's say 5 sample lookups per output



7a with song data attempt 2
looptop:
  times 15 nop
realLooptop:
  add bp,9999     4 0
  mov bx,bp       2 0
  mov bl,99       2 0
  mov al,[bx]     2 1   ; 11
  add si,9999     4 0
  mov bx,si       2 0
  mov bl,99       2 0
  add al,[bx]     2 1   ; 11
  add di,9999     4 0
  mov bx,di       2 0
  mov bl,99       2 0
  add al,[bx]     2 1   ; 11
  add dx,9999     4 0
  mov bx,dx       2 0
  mov bl,99       2 0
  add al,[bx]     2 1   ; 11
  inc ax
  out 042,al      2 1
  loop looptop    2 1   ; 6

  pop bx          1 2
  pop ax          1 2
  mov [bx],ax     2 2
  mov cx,9999     3 0
  jmp realLoopTop 2 0   ; 15

Need to figure out sequences for:
  Updating ss
  Outputting to screen
  Modifying CRTC registers
These can all be done by modifying the nops at looptop

es: mov [xxxx],xxxx  ; 7 2 ~2.9

Set cx = 1
Update looptop code
  If cx == 1 the looptop code won't run



Could also do:
  mov [bx],al
  mov cl,ah
but this doesn't seem to be any faster with refresh 18! (Also less space-efficient)

Can we have "gosub" and "return" looptop codes?
  Gosub:
    [vsp] = sp
    vsp -= 2
    sp = new_sp
  Return:
    vsp += 2
    sp = [vsp]
These v-instructions need to be executed only once, so the actual instruction stream needed is:
  cx=1
  Write gosub bytes
  cx=2
And the first instruction of a new subroutine or after a gosub is cx=1
Gpsub code:
  mov bx,[vsp]
  mov [bx],sp
  inc bh
  mov [vsp],bx   ; 18 IOs - too long
Instead of having a stack, just have each function look in a specific place for its return address
  No recursion, but that's probably ok
Examples of h-instructions:
  Goto immediate
    mov sp,xxxx       ; 3 0
  Goto indirect
    mov sp,[cs:xxxx]  ; 5 2
    add sp,xx         ; 3 0
  Save sp
    mov [cs:xxxx],sp  ; 5 2
  Move variable, immediate word or modify self
    mov [cs:xxxx],xxxx ; 7 2
  Move variable, variable
    mov ax,[cs:xxxx]  ; 5 2
    mov [cs:xxxx],ax  ; 5 2
  Dereference variable:
    mov bx,[cs:xxxx]  ; 5 2
    mov ax,[es:bx]    ; 3 2
    mov [cs:xxxx],ax  ; 5 2  - 19 IOs - too slow!
  Dereference variable attempt 2:
    mov bx,xxxx                                   3 0
    mov ax,[cs:bx]   ; ax = [xxxx]                3 2
    xchg ax,bx       ; ax = xxxx, bx = [xxxx]     1 0
    mov bx,[es:bx]   ; bx = [es:[xxxx]]           3 2
    xchg ax,bx       ; bx = xxxx, ax = [[xxxx]]   1 0
    mov [cs:bx],ax   ; [xxxx] = [es:[xxxx]]       3 2 - 20 IOs - even worse
  Dereference variable attempt 3 part 1:
    mov bx,[cs:xxxx]  ; 5 2
    mov es,[es:bx]    ; 3 2
  Dereference variable attempt 3 part 2:
    mov [cs:xxxx],es
  CRTC update:
    mov bx,dx        2 0
    mov dx,0x3d4     3 0
    mov ax,0xVVRR    3 0
    out dx,ax        1 2
    mov dx,bx        2 0 - 13 IOs



  ALU operations
    mov ax,es         ; 2 0
    alu [cs:xxxx],ax  ; 5 4

A compressed music update h-routine
  mov ax,[es:xxxx]


We have to be careful with memory accesses because they'll make the looptop code take longer
  We can move the loop destination if necessary
With 512kB of data:
  Peak data rate (i.e. cl==1) is 15.8 seconds
  Slowest data rate (i.e. cl==255) is 67 minutes
  Standard data rate (i.e. update 12 bytes 50 times per second) is 7.3 minutes - cl~=27
  Frame rate of 50Hz gives us 331 v-instructions until we need to do 12 updates (so 319 spare)
    This is about 24 h-instructions
Each (delta-) v-instruction byte costs 1 word (and takes 1 sample)
Each v-instruction also costs an additional 2 words and 3 samples
So if a typical instruction is 10 bytes, we're looking at ~1000 v-instructions per second
We'd like to be able to write v-code which plays music and does some other things at the same time
  Can we write a v-code kernel which loads music data from a separate address and doesn't take up too much space itself?
    It won't update very quickly unless we use native v-code




7a with song data attempt 2 variant 1
looptop:
  times 15 nop
realLooptop:
  add bp,9999     4 0
  mov bx,bp       2 0
  mov bl,99       2 0
  mov al,[bx]     2 1   ; 11
  add si,9999     4 0
  mov bx,si       2 0
  mov bl,99       2 0
  add al,[bx]     2 1   ; 11
  add di,9999     4 0
  mov bx,di       2 0
  mov bl,99       2 0
  add al,[bx]     2 1   ; 11
  add dx,9999     4 0
  mov bx,dx       2 0
  mov bl,99       2 0
  add al,[bx]     2 1   ; 11
  inc ax          1 0
  out 042,al      2 1
  loop looptop    2 0   ; 6

  pop bx          1 2
  mov al,bh       2 0
  mov bh,0        2 0
  mov [cs:bx],al  3 1
  mov cl,1        2 0
  jmp realLoopTop 2 0   ; 15




CX = voice 0 position
SI = voice 1 position
DI = voice 2 position
SP = voice 3 position
BX = temporary sample pointer
AL = buffered sample
AH = sample accumulator
DL = voice 1 waveform
DH = voice 2 waveform
SS:BP = data:
  0 = voice 0 velocity
  2 = voice 1 velocity
  4 = voice 2 velocity
  6 = voice 3 velocity
  8 = voice 0 waveform
  9 = voice 1 waveform
  10 = 0b800
  12 = song segment
  14 = waveform segment
CS = code segment
DS = waveforms segment
ES = song segment

fakeLooptop:
  ~11 nops

  mov bx,[bp-xx]     3 2 <- arrange for bp-xx to point at doUpdate+5
  mov ds,[bp+12]     3 2
  mov dx,[bx]        2 2
  mov bx,[bx+2]      3 2
  mov ds,[bp+10]     3 2
  mov [bx],dx        2 2
  mov ds,[bp+14]     3 2
  mov dx,[bp-xx]     3 2 <- arrange for bp-xx to point at waveforms12+1

loopTop:                 -3
  out 042,al      2 1     0
  add cx,[bp]     2 2     4
  mov bx,cx       2 0     6
  mov bl,[bp+8]   3 1    10
  mov al,[bx]     2 1    14
  add si,[bp+2]   3 2    19
  mov bx,si       2 0    21
  mov bl,dl       2 0    23
  add al,[bx]     2 1    26
  add di,[bp+4]   3 2    31
  mov bx,di       2 0    33
  mov bl,dh       2 0    35
  add al,[bx]     2 1    38
  add sp,[bp+6]   3 2    43
  mov bx,sp       2 0    45
  mov bl,[bp+9]   3 1    49
  add al,[bx]     2 1    52

  add cx,[bp]     2 2    56
  mov bx,cx       2 0    58
  mov bl,[bp+8]   3 1    62
  mov ah,[bx]     2 1    65
  out 042,al      2 1    68
  add si,[bp+2]   3 2    73
  mov bx,si       2 0    75
  mov bl,dl       2 0    77
  add ah,[bx]     2 1    80
  add di,[bp+4]   3 2    85
  mov bx,di       2 0    87
  mov bl,dh       2 0    89
  add ah,[bx]     2 1    92
  add sp,[bp+6]   3 2    97
  mov bx,sp       2 0    99
  mov bl,[bp+9]   3 1   103
  add ah,[bx]     2 1   106
  mov al,ah       2 0   108

  add cx,[bp]     2 2   112
  mov bx,cx       2 0   114
  mov bl,[bp+8]   3 1   118
  mov ah,[bx]     2 1   121
  add si,[bp+2]   3 2   126
  mov bx,si       2 0   128
  mov bl,dl       2 0   130
  add ah,[bx]     2 1   133
  out 042,al      2 1   136
  add di,[bp+4]   3 2   141
  mov bx,di       2 0   143
  mov bl,dh       2 0   145
  add ah,[bx]     2 1   148
  add sp,[bp+6]   3 2   153
  mov bx,sp       2 0   155
  mov bl,[bp+9]   3 1   159
  add ah,[bx]     2 1   162
  mov al,ah       2 0   164

  add cx,[bp]     2 2   168
  mov bx,cx       2 0   170
  mov bl,[bp+8]   3 1   174
  mov ah,[bx]     2 1   177
  add si,[bp+2]   3 2   182
  mov bx,si       2 0   184
  mov bl,dl       2 0   186
  add ah,[bx]     2 1   189
  add di,[bp+4]   3 2   194
  mov bx,di       2 0   196
  mov bl,dh       2 0   198
  add ah,[bx]     2 1   201
  out 042,al      2 1   204
  add sp,[bp+6]   3 2   209
  mov bx,sp       2 0   211
  mov bl,[bp+9]   3 1   215
  add ah,[bx]     2 1   218
  mov al,ah       2 0   220

  add cx,[bp]     2 2   224
  mov bx,cx       2 0   226
  mov bl,[bp+8]   3 1   230
  mov ah,[bx]     2 1   233
  add si,[bp+2]   3 2   238
  mov bx,si       2 0   240
  mov bl,dl       2 0   242
  add ah,[bx]     2 1   245
  add di,[bp+4]   3 2   250
  mov bx,di       2 0   252
  mov bl,dh       2 0   254
  add ah,[bx]     2 1   257
  add sp,[bp+6]   3 2   262
  mov bx,sp       2 0   264
  mov bl,[bp+9]   3 1   268
  add ah,[bx]     2 1   271
  out 042,al      2 1   274 (2 too late)
  mov al,ah       2 0   276

counter:
  mov bx,0099        3 0
  dec bx             1 0
  jnc doUpdate       2 1
  mov [bp-xx],bl           3 1 <- arrange for bp-xx to point at counter+1
  jmp fakeLooptop          2 1
doUpdate:
  mov [bp-xx],99     4 1 <- arrange for bp-xx to point at counter+1 - 99 = new counter value
  mov bx,9999        3 2
  add bx,4           3 0
  mov [bp-xx],bx     3 2 <- arrange for bp-xx to point at doUpdate+5
  mov es,[bp+12]     3 2
  es: mov dx,[bx]    3 2
  es: mov bx,[bx+2]  4 2
  ss: mov [bx],dx    3 2
waveforms12:
  mov dx,9999        3 0
  ~12 nops
  jmp loopTop        2 1

; Locate SS:BP data here.



We output to 8253 every 68 cycles = 16.6KHz
The outer loop takes 68*5 = 340 cycles (360 with refresh) giving a tempo resolution of 3.3KHz (300us)
Each time through the outer loop we burn 4 bytes of song
640Kb lasts between 49.4s and 3.5 hours
If we want to update all velocities and waveforms (6 words) 50 times per second (count = 66/6 = 11) that gives us 9 minutes of music
  If the waveform/velocity changes being staggered are annoying, we can unroll:

  mov bx,[bp-xx]     3 2 <- arrange for bp-xx to point at doUpdate+5
  mov ds,[bp+12]     3 2
  mov dx,[bx]        2 2
  mov [bp],dx        2 2
  mov dx,[bp+2]      3 2
  mov [bp+2],dx      3 2
  mov dx,[bx+4]      3 2
  mov [bp+4],dx      3 2
  mov dx,[bx+6]      3 2
  mov [bp+6],dx      3 2
  mov dx,[bx+8]      3 2
  mov [bp-xx],dx     3 2 <- arrange for bp-xx to point at waveforms12+1
  mov ds,[bp+14]     3 2

and update [bp+8] (or others) in the normal way. We can also change the tempo before and after every change, but that's more wasteful of song space.

Unrolled:
  count = 33 (50.2 changes per second)  14 bytes per change = 932 seconds = 15.5 minutes (12.4 with 2x64Kb for OS/player/samples)

With tempo changes: extra 8 bytes after every 24 = 6.8 minutes (5.4 in 512Kb)



  lodsw            ; 1 2  ax = position
  xchg ax,bx       ; 1 0  bx = position
  lodsw            ; 1 2  ax = velocity
  add ax,bx        ; 2 0  ax = position + velocity
  mov [si-4],ax    ; 3 2  position += velocity
  lodsb            ; 1 1  ax = (position & 0xff00) | waveform
  xchg bx,ax       ; 1 0  bx = (position & 0xff00) | waveform
  es: mov ah,[bx]  ; 3 1  ah = sample
  lodsb            ; 1 1  ax = (sample << 8) | volume
  xchg bx,ax       ; 1 0  si = (sample << 8) | volume; ax = dataPointer
  es: mov cl,[bx]  ; 3 1  si = volumeTable[sample];
; 28 cycles

  pop bx           ; 1 2  bx = position
  pop ax           ; 1 2  ax = velocity
  add ax,bx        ; 2 0  ax = position + velocity
  mov [bp-4],ax    ; 2 2  position += velocity
  lodsb            ; 1 1  ax = (position & 0xff00) | waveform



50Hz = 22538 cycles

Theoretical maximum of current routine with 55 cycles is 20.1KHz



; Pre-compute offsets for ~20 samples per channel
; Use 8.8 addressing and a 64Kb sideways sample table
; Store these offsets at SS:SP
; Samples in ES:
; Low 8 bits of SI = waveform number
; High 8 bits of SI = sample within waveform
; High 8 bits of BP = offset sample within waveform
; Low 8 bits of BP = 0
; High 8 bits of BX = volume
; Low 8 bits of BX = volume from sample
; Volume table in DS (not sideways)
; With volume table: 10 cycles (theoretical maximum 28.2KHz)

  pop bp              1 2
  es: mov bl,[si+bp]  3 1
  mov al,[bx]         2 1

; Without volume table: 7 cycles (theoretical maximum 40.2KHz)

  pop bp              1 2
  es: mov al,[si+bp]  3 1


; Do the samples in time-major order or voice-major order?
;   Time-major order means we have to keep switching SI
;   Voice-major order means we have to mix into a buffer

; Voice-major, no volume table: 41 cycles excluding output
  pop bp              1 2
  es: mov al,[si+bp]  3 1
  pop bp              1 2
  es: mov ah,[si+bp]  3 1
  mov [di+2],ax       3 2

  pop bp              1 2
  es: mov al,[si+bp]  3 1
  pop bp              1 2
  es: mov ah,[si+bp]  3 1
  add [di+2],ax       3 4

  pop bp              1 2
  es: mov al,[si+bp]  3 1
  pop bp              1 2
  es: mov ah,[si+bp]  3 1
  add [di+2],ax       3 4

  pop bp              1 2
  es: mov al,[si+bp]  3 1
  pop bp              1 2
  es: mov ah,[si+bp]  3 1
  add [di+2],ax       3 4

; With buffer in ES and samples in DS: 39 cycles

  pop bx              1 2
  mov al,[si+bx]      2 1
  pop bx              1 2
  mov ah,[si+bx]      2 1
  es: mov [di+2],ax   4 2

; With



; Time-major, no volume table: 36 cycles excluding output
  mov si,bp           2 0
  pop bx              1 2
  mov al,[si+bx]      2 1
  mov si,cx           2 0
  pop bx              1 2
  add al,[si+bx]      2 1
  mov si,dx           2 0
  pop bp              1 2
  add al,[si+bx]      2 1
  mov si,di           2 0
  pop bp              1 2
  add al,[si+bx]      2 1  36 x 20 = 720 cycles

  pop bp              1 2
  pop si              1 2
  add [bp],si         2 4
  pop si              1 2
  adc bx,si           2 0
  pop si              1 2
  add [bp+2],si       3 4
  pop si              1 2
  adc cx,si           2 0
  pop si              1 2
  add [bp+4],si       3 4
  pop si              1 2
  adc dx,si           2 0
  pop si              1 2
  add [bp+6],si       3 4
  pop si              1 2
  adc di,si           2 0
  sub sp,178          4 0    66 cycles


  add bx,si       ; 2 0
  mov [bp+9],bh   ; 3 1  6 x 20 = 120 cycles    x 4 = 480 cycles


(22538 cycles - 480)/786 = 28 iterations = 560 samples in 20ms = 28KHz

Output: 5 cycles per sample = 2800 cycles

(22538 cycles - 480 - 2800)/786 = 24 iterations = 480 samples in 20ms = 24KHz



Need to run some experiments generating code for various run lengths and sample rates

50 times a second, change:
  Voice 0 velocity        2
  Voice 0 waveform        1
  Voice 1 velocity        2
  Voice 1 waveform        1
  Voice 2 velocity        2
  Voice 2 waveform        1
  Voice 3 velocity        2
  Voice 3 waveform        1
  Screen update position  2
  Screen update value     1  total 15  750 bytes/sec  11.6 minutes in 512Kb.








Some useful v-instructions:
Jump: mov sp,xxxx
Jump: mov sp,es
Jump: mov sp,[cs:xxxx]
Far jump: mov sp,xxxx  mov ax,yyyy  mov ss,ax
Immediate load: mov [cs:xxxx],yyyy
Immediate load: mov ax,xxxx  mov es,ax
Save current position: mov [cs:xxxx],sp
Save current position: mov es,sp
Load: mov es,[cs:xxxx]
Indirect load: mov bx,es  mov es,[cs:bx]
Store: mov [cs:xxxx],es
Indirect store immediate: mov bx,es  mov [cs:bx],xxxx
Modify waveform table: mov [xxxx],es
Modify waveform table: mov [xxxx],yyyy
Modify waveform table: mov es,bx  mov [bx],xxxx
Modify v-instruction program: mov [ss:xxxx],es
Modify v-instruction program: mov [ss:xxxx],yyyy
Modify v-instruction program: mov es,bx  mov [ss:bx],xxxx
Setup for video memory write: mov ax,0xb800  mov es,ax
Video memory write: mov [es:xxxx],yyyy
Copy from one location to another: mov ax,[cs:xxxx]  mov [cs:yyyy],ax
Write CRTC register: mov bx,dx  mov dx,0x3d4  mov ax,xxxx  out dx,ax  mov dx,bx
ALU operations (add, sub, and, or, xor): mov ax,es  alu [es:xxxx],ax
More complicated things (e.g. a store of computed data to video memory) can be done by self-modification of the v-instruction program. Conditional jumps would be very tricky to implement directly (since both code paths need to take the same number of cycles) but could be done via indirect jumps.




Commands:
  1: Set CRTC start address
  2: Set write pointer
  3: Write word and increment write pointer











As promised, here's the writeup of the MOD player thingy I've been tinkering
with.

In order to be able to play a single waveform at a variety of different
frequencies we need a "phase" or "position" variable which points to the
current byte of the waveform and a "frequency" or "velocity" variable. For
each sample that we output we need to add the frequency to the phase, look
up the sample value at that position in the waveform and then add the result
to a running total to mix the channels together.

Suppose we have a 16kHz output rate. If we limit ourselves to waveforms
which are 256 bytes in length and use 8.8-bit fixed point for phase and
frequency we get a range of frequencies between 0 and 8kHz (the Nyquist
limit) with a resolution of 0.25Hz which should be quite acceptable for
musical purposes (off by less than 1/20 of a semitone for frequencies above
86Hz).

The fastest per-channel, per-iteration code that I've come up with to
implement that is:
  add si,9999
  mov bx,si
  mov bl,99
  add al,[bx]

Here, the si register holds the current phase for the channel, the "9999" is
the current frequency value for the channel (stored as an immediate word in
the code itself) and the "99" is the current waveform number for this
channel. The "mov bl,99" line overwrites the fractional bits of the phase,
so the waveform table (which takes up the entire 64kB data segment) must be
organized so that the low byte of the address corresponds to the waveform
number and the high byte of the address corresponds to the sample within
that waveform (i.e. "sideways" to what you might expect).

If we store the frequencies and waveform numbers in the code itself, then in
order to update them we have to actually patch the player code as it's
running. Fortunately the 8088 doesn't have an instruction cache (just a
4-byte queue which is emptied on a jump).

The output sample rate this routine is limited by the maximum amount of
stuff it has to do for each iteration: mixing 4 channels, outputting the
result to the speaker and doing the absolute minimum amount of patching to
be able to play more than a single chord. The fastest "minimal patching"
code I've come up with abuses the stack (which happily can be made to not
overlap the waveform table) to be a sequence of patching locations and
values, and looks like this:
  pop bx
  pop ax
  mov [bx],ax
However, we don't want to do that for every output sample, or we'll burn
through our entire 64kB stack in less than a second. Hence there's one more
thing we need to do each iteration: decrement a counter and when it reaches
0 do the patch and reload the counter. So the full routine looks like this:

l1:
  times 15 nop
l2:
  add bp,9999  mov bx,bp  mov bl,99  mov al,[bx]
  add si,9999  mov bx,si  mov bl,99  add al,[bx]
  add di,9999  mov bx,di  mov bl,99  add al,[bx]
  add dx,9999  mov bx,dx  mov bl,99  add al,[bx]
  out 0x42,al  ; Output total to speaker
  loop l1
  pop bx  pop ax  mov [cs:bx],ax
  mov cx,9999  ; Count until next patch
  jmp l2

So the phases are stored in the bp, si, di and dx registers. Note the use of "mov al,[bx]" instead of "add al,[bx]" to zero the total when processing the first channel. I've timed this piece of code and it takes 288 CPU cycles to execute with the default DRAM refresh rate of 18, yielding an output sample rate of just under 16.6kHz. I'm using the term v-cycle to describe the time from one output sample to the next, for reasons which will become obvious later.

The 15 NOPs at the start are there to make sure that the two cases (patch
and don't patch) take the same amount of time - they're skipped (via "jmp
l2") in the patch case and not skipped (via "loop l1") in the non-patch
case. So the "inner loop" is partially outside the "outer loop"!

This has some nice properties. As well as updating the frequencies and
waveform numbers, by patching the right address we can update:
* The count-until-next-patch value ("mov cx,9999") so that we can patch more
often in more complicated parts of the song. We can also update all the
frequencies and waveform numbers in a "burst" at a rate of 50 times a second
or so if we like rather than distributing all the patches evenly in time.
* The "jmp l2" (with NOPs) so that we have a way of ending the song when
it's over.
* One of the "mov bl,99"s with "mov bl,al" to create (with suitable waveform
table data) a "ring modulation" effect like the SID has (i.e. multiply the
output of the first and second channels).

One other thing we need to be able to do is update the stack segment in
order to be able to access more than 64kB of song data (which would only
last about 40 seconds if we update all frequencies and waveform numbers 50
times per second). However, we're running out of things that we can patch.
We can't patch the mixing/output code without having an audible effect and
we can't patch the patching code without breaking it.

What's left? Those NOPs at the start! We can put anything we like there as long as it takes the right amount of time. With cx==1 (i.e. "mov cx,1" as the set-count-until-next-patch instruction) it won't even get executed until we're ready. I'm using the term v-instruction (virtual machine instruction) for a chunk of code that replaces the NOPs, because we can think of the patch sequence as being a kind of bytecode or instruction sequence in its own right. We do have to be a bit careful with the timing, but we can accommodate longer-running v-instructions (in particular those that access memory or IO ports and have bus cycles other than instruction fetches) by adjusting the target of the "loop l1" instruction. Often I think we'll just be able to leave cx==2 and run one v-instruction every other v-cycle - i.e. at a blistering 8.3kHz!

As well as updating the stack segment, what other things can we do with v-instructions? Some things I'd like to do:
* Some kind of animation (e.g. changing the CRTC start address and modifying
video RAM).
* Compression - each v-instruction takes a least 4 bytes in the song data stream so it's a very sparse encoding. It would be nice if the song was at least encoded with implied patch addresses so that we can have a 10 minutes of music in 512kB instead of 5.

Most registers are used (or at least stomped) by the main part of the routine so variables have to be kept in memory. Probably in the code segment to avoid using up waveform slots. The one exception is ES which isn't a general register, but can be loaded from or stored to memory or other registers.

One downside to the system of v-instructions is that they take up a lot of space (4-24 bytes per v-instruction) so it might be nice to have some form of compression for the v-instructions themselves (at least for stretches where there is complex logic but the speed isn't too critical) as well as for the song data. This can be done by having a third level of instructions above CPU instructions and v-instructions, which I'm calling h-instructions (high level instructions). The idea is that you have an array of h-instructions, an h-instruction pointer pointing into this array, and a small v-instruction program which increments the pointer, dereferences it and dispatches to one of several small v-instruction sequences before looping back to the beginning of the v-instruction program.

Here's an example of a possible v-instruction program, which decompresses song data and also executes h-instructions for animation. Each 16-byte block contains 12 bytes of song data (4 bytes for waveform numbers and 8 bytes for freuencies) plus one two-byte h-instruction and a two byte associated operand. Each line has one v-instruction or other patch. After the semicolon I've made a rough count of the number of v-cycles required for that v-instruction:
  start: inc word[cs:compressedDataPointer]  ; 7 (cx=1, 3 words v-insn, loop, cx=2, v)
  mov es,[cs:compressedDataPointer]  ; 5 (cx=1, 1 word v-insn, loop, cx=2, v)
  mov ax,[es:0x0]  mov [ss:f0+2],ax  ; 9 (cx=1, 5 words v-insn, loop, cx=2, v)
  mov ax,[es:0x2]  mov [ss:f1+2],ax  ; 4 (1 word v-insn, v, 1 word v-insn, v)
  mov ax,[es:0x4]  mov [ss:f2+2],ax  ; 4 (1 word v-insn, v, 1 word v-insn, v)
  mov ax,[es:0x6]  mov [ss:f3+2],ax  ; 4 (1 word v-insn, v, 1 word v-insn, v)
  mov ax,[es:0x8]  mov [ss:w0+3],al  ; 6 (cx=1, 2 words v-insn, loop, cx=2, v)
  mov ax,[es:0x9]  mov [ss:w1+3],al  ; 4 (1 word v-insn, v, 1 word v-insn, v)
  mov ax,[es:0xa]  mov [ss:w2+3],al  ; 4 (1 word v-insn, v, 1 word v-insn, v)
  mov ax,[es:0xb]  mov [ss:w3+3],al  ; 4 (1 word v-insn, v, 1 word v-insn, v)
  f0: frequency0 = xxxx  ; 2 (cx=1, p)
  f1: frequency1 = xxxx  ; 1 (p)
  f2: frequency2 = xxxx  ; 1 (p)
  f3: frequency3 = xxxx  ; 1 (p)
  w0: waveform0 = xxxx  ; 1 (p)
  w1: waveform1 = xxxx  ; 1 (p)
  w2: waveform2 = xxxx  ; 1 (p)
  w3: waveform3 = xxxx  ; 1 (p)
  mov sp,[es:0xc]  ; 6 (3 words v-insn, loop, cx=2, v)

Depending on the value of [es:0xc], v-execution then moves on to one of several subroutines:

Set CRTC start address:
  mov ax,[es:0xe]  mov [ss:sa1+7],al  ; 9 (cx=1, 5 words v-insn, loop, cx=2, v)
  mov ax,[es:0xf]  mov [ss:sa2+7],al  ; 4 (1 word v-insn, v, 1 word v-insn, v)
  sa1: mov bx,dx  mov dx,0x3d4  mov ax,0xXX0c  out dx,ax  mov dx,bx  ; 10 (cx=1, 6 words v-insn, loop, cx=2, v)
  sa2: mov bx,dx  mov dx,0x3d4  mov ax,0xXX0d  out dx,ax  mov dx,bx  ; 2 (1 word v-insn, v)
  mov sp,start  ; 6 (cx=1, 2 words v-insn, loop, cx=2, v)

Output data to screen:
  inc word[cs:screenUpdate+3]  ; 7 (cx=1, 3 words v-insn, loop, cx=3, v)
  inc word[cs:screenUpdate+3]  ; 1 (v)
  mov ax,[es:0xe]  mov [ss:screenUpdate+5],ax  ; 9 (cx=1, 5 words v-insn, loop, cx=2, v)
  mov ax,0xb800  mov es,ax  ; 7 (cx=1, 3 words v-insn, loop, cx=2, v)
  screenUpdate: mov [es:xxxx],yyyy  ; 8 (cx=1, 4 words v-insn, loop, cx=2, v)
  mov sp,start  ; 6 (cx=1, 2 words v-insn, loop, cx=2, v)

Change screen update pointer:
  mov ax,[es:0xe]  mov [ss:screenUpdate+3],ax  ; 9 (cx=1, 5 words v-insn, loop, cx=2, v)
  mov sp,start  ; 6 (cx=1, 2 words v-insn, loop, cx=2, v)

Finish:
  "jmp l2" = "nop nop"  ; 2 (p, v)
