World coordinates: 8.8   -128 <= model.x < 128
Matrix elements: 8.8     -128 <= _xx < 128
r.x and r.y: 16.16       -32768 <= r.x < 32768
r.z: 0 8.16              -128 <= r.z < 128

In current span, the s vector is 338, 282, 0.566
So the matrix elements won't fit in 8.8
  This just means that the model and screen need to be larger by at least a factor of 3
    Making the screen 4x3 in world units is quite nice!

The transformed (screen) coordinates should be accurate to 1/256 of pixel width
However, we want to allow for vertex positions which are a long way offscreen (e.g. above player)
Therefore, pre-clipping we want screen positions in 24.8 format
  Or 12.4?

Suppose transformed coordinates are in 16.16 format.

To compute 16.16 / 16.16, need to shift quotient rep left by x bits and divisor right by 16-x bits
  So could be a 48/32 division or a 32/16
  Latter would be much faster!
  This is x/(z >> 16) - i.e. drop fractional part of z
  However, we only want 8 fractional bits for fillTriangle, so we need a >>8
    So we could compute:
      (x >> 8)/(z >> 16) - 32/16 (really 24/16)
      x/(z >> 8) - 32/24 (can compute as 32/16 if -128 <= r.z < 128)
  We do need the transform output to be 16.8 or 24.8 in order to do clipping properly
    So use 32/16->32, which is two 32/16->16 operations
      xor dx,dx
      mov cx,[rz + 1]
      mov ax,[rx + 2]
      idiv cx          ; dx = remainder, ax = quotient
      mov [sx + 2],ax
      mov ax,[rx]
      idiv cx
      mov [sx],ax




For fillTriangle, we want a 24.8 result - i.e. vR = rR*2^-8

We have vX = rX*2^-16 and vZ = rZ*2^-16

vR = vX/vZ

rR*2^-8 = rX / rZ
rR = rX*2^8 / rZ

Suppose we want to compute this with a 32/16 divide



Suppose we have rX in DX:AX and rZ in BX:CX

mov ch,bl
mov cl,ch
idiv cx


(6*100*s/5) * 5 = 128  s = 0.21333  2/s = size of screen vertically in world coords = 9.375
size of screen horizontally = 10
this is with distance = 5 which is a very wide field of vision
  For a PC game, a 90 degree FoV is normal, i.e. distance = 128 pixels



Express FoV as distance in units of screen width (d/sx)
  FoV of 90 degrees is d/sx = 0.5 = ds    d = ds*sx     sx = d/ds

sx/sy = (5/6)*(256/200) = 1.06666     sx = 1.06666*sy   sy = 0.9375*sx
1/zs = sy/2      zs = 2/sy   sy = 2/zs
ys = 100*zs      zs = ys/100
xs = 6*ys/5      5*xs/6 = ys
xs*d = 128       xs = 128/d


sy = 2/zs = 2/(ys/100) = 200/ys     = pixels per world-unit vertically
sy = 200/(5*xs/6) = 200/(5*(128/d)/6) = 200/(5*(128/(ds*sx))/6) = 200/(5*(128/(ds*(1.06666*sy)))/6)

1/2 = ds


maximum matrix value = xs*d = 6*ys*d/5 = 6*100*(2/sy)*d/5  = 6*100*(2/(0.9375*(d/ds)))*d/5 = 256*ds

Want zs = 1 so sy = 2 and sx = 2.13333333
ys = 100
xs = 120
d = 1.06666


Modify distance to satisfy xs*d = 128

d = 128/xs = 128/(6*ys/5) = 128/(6*(100*zs)/5) = 128/(6*(100*(d/sqrt((d*d + 1)*3)))/5)

d*d = 1.066666666*sqrt((d*d + 1)*3)

d^4 = 1.066666^2 * (d*d + 1)*3

d = 128/(6*(100*(d/sqrt((d*d + 1)*3)))/5)

d = (4/5)*sqrt((8/3) + sqrt(139)/3) = 2.0547091212166765333819588893295

With ys = 99.5*zs, d = 2.06338



cos(a)*cos(b) = (cos(a + b) + cos(a - b))/2
sin(a)*sin(b) = (cos(a - b) - cos(a + b))/2
sin(a)*cos(b) = (sin(a + b) + sin(a - b))/2
cos(a)*sin(b) = (sin(a + b) - sin(a - b))/2


d = 8/15

r = (8/15)/sqrt(3*(1 + 8*8/(15*15)))


sin(u) = 1/256, u ~= 1/256    2048 entries, 2560 with cosines



MUL with byte arguments: 69 cycles plus 1 for each set bit in AL plus 1 if the high byte of the result is 0
MUL with word arguments: 123 cycles plus 1 for each set bit in AX plus 1 if the high word of the result is 0
IMUL with byte arguments: >= 80 cycles
IMUL with word arguments: >= 134 cycles

MUL rb                  69-78
IMUL rb                 80-98
DIV rb                  80-90
IDIV rb                101-112
MUL rw                 118-133
IMUL rw                128-154    141
DIV rw                 144-162
IDIV rw                165-184    175

1 vertex = 8 IMULs and 4 IDIVs = 1828 cycles
20 vertices = 36560 cycles = 120 scanlines
1 triangle = 3 IMULs and 3 IDIVs = 948 cycles
18 triangles = 17064 cycles = 56 scanlines

The


As sine table values are essentially 8 bits plus a sign bit, can we use table-of-squares to do the multiply?

(0x100*a + b)*c = (b*c) + 0x100*(a*c)

Assume value in sine table is in range 0..0xff
  mov si,[sineTable + di]                      ; 4 2
  mov bl,[modelCoord]                          ; 4 1
  mov bh,0                                     ; 2
  add bx,bx                                    ; 2
  mov ax,[si+bx]                               ; 2 2
  neg bx                                       ; 2
  sub ax,[si+bx]                               ; 2 2
  mov bl,[modelCoord + 1]                      ; 4 1
  mov bh,0                                     ; 2
  add bx,bx                                    ; 2
  mov cx,[si+bx]                               ; 2 2
  neg bx                                       ; 2
  sub cx,[si+bx]                               ; 2 2
  mov dl,ch                                    ; 2
  mov dh,0                                     ; 2
  mov ch,cl                                    ; 2
  mov cl,0                                     ; 2
  add ax,cx                                    ; 2
  adc dx,0                                     ; 3      228
No advantage in using half-square tables for full-range 16x8 bit multiplies



  mov ax,[modelCoord]                          ; 20
  imul word[sineTable + ...]                   ; result in dx:ax     134


Is it better to include the world-to-pixel scaling factors into the transformation matrix or apply them separately afterwards?
  Applying them separately doesn't seem to buy us anything, unless we can do crazy optimizations to eliminate the first mul (store separate sine table for each possible world position)
    world (8.8) * rotation (1.8) >> 8 -> rotated (8.8)            imul
    rotated (8.8) <<8 / z (8.8) -> transformed (24.8)          idiv idiv    need 32 bits of precision after perspective applied
    transformed (24.8) * scale (8.8) -> scaled (16.16)            imul

  Applying them together:
    world (8.8) * matrix (8.8) -> worldpix (16.16)   imul
    scaled (16.16) / z (8.8) -> screen (24.8)        idiv idiv


What if a triangle crosses z=0 and is partially visible?
  Need to draw an external triangle (figure 3 in https://www.cs.unc.edu/~olano/papers/2dh-tri/)



New span covers only one old span
  If co != cn
    xlo == xln, xro == xrn - New span covers old span exactly  - no shuffle
    xlo == xln, xro > xrn  - New span covers left of old span  - shuffle right 1
    xlo < xln,  xro == xrn - New span covers right of old span - shuffle right 1
    xlo < xln, xro > xrn   - New span within old span          - shuffle right 2
  else nothing to do
New span covers two old spans

1111111222222222333333333
AaaaaaaBbbbbbbbbCcccccccc




rep stosb to cga = 4 IOs per byte       (28 IOs for 7 bytes)
rep stosw to cga = 3.4285 IOs per byte  (24 IOs for 7 bytes)

mov ah,al
shr cx,1

	movb	%al,	%ah
	shrw	$1,	%cx
	rep	stosw
	adcw	%cx,	%cx
	rep	stosb

~14 bytes needed for longer version to be better




0x000000ea  y == 0x21

old: 00 00 2d 55 af 00 ff
new: 00 00 2d 55 8d 00 ff

Previous:

0x001ADDFC  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x001ADE0C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x001ADE1C  55 55 55 55 55 55 55 55 55 55 55 54 00 00 00 00  UUUUUUUUUUUT....
0x001ADE2C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0 (incorrect):

0x0044DCB4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0044DCC4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0044DCD4  55 55 55 00 00 00 00 00 00 00 00 54 00 00 00 00  UUU........T....
0x0044DCE4  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2 (correct):

0x004473D4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004473E4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004473F4  55 55 55 40 00 00 00 00 00 00 00 00 00 00 00 00  UUU@............
0x00447404  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

Iteration:

x = 0x00, xRo = 0x2d, xRn = 0x2d, co = 0x00, cn = 0x00
queuedSkips = 0x0b

x = 0x2d, xRo = 0x2d, xRn = 0x8d, co = 0x00, cn = 0x55
queuedStores = 0x00

x = 0x2d, xRo = 0xaf, xRn = 0x8d, co = 0x55, cn = 0x55
queuedSkips = 0x23

Need to create the partial byte 0x40 in here somehow

x = 0x8d, xRo = 0xaf, xRn = 0xff, co = 0x55, cn = 0x00
queuedStores = 0x08
vram = 0x23, queuedSkips = 0x00

x = 0xaf, xRo = 0xff, xRn = 0xff, co = 0x00, cn = 0x00
queuedSkips = 0x14                                      we're skipping
memset(offset = 0x23, value = 0x00, count = 0x08), queuedStores = 0










0x000000ea  y == 0x21

old: 00 00 2d 55 af 00 ff
new: 00 00 2d 55 8d 00 ff

Previous:

0x0018E14C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0018E15C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0018E16C  55 55 55 55 55 55 55 55 55 55 55 54 00 00 00 00  UUUUUUUUUUUT....
0x0018E17C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0 (incorrect):

0x0018E14C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0018E15C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0018E16C  55 55 55 40 00 00 00 00 00 00 00 54 00 00 00 00  UUU@.......T....
0x0018E17C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2 (correct):

0x0018786C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0018787C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0018788C  55 55 55 40 00 00 00 00 00 00 00 00 00 00 00 00  UUU@............
0x0018789C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

x = 0x00, xRo = 0x2d, xRn = 0x2d, co = 0x00, cn = 0x00
queuedSkips = 0x0b

x = 0x2d, xRo = 0xaf, xRn = 0x8d, co = 0x55, cn = 0x55
queuedSkips = 0x23

x = 0x8d, xRo = 0xaf, xRn = 0xff, co = 0x55, cn = 0x00
vram = 0x23, queuedSkips = 0
*vram = 0x40, vram = 0x24, x = 0x90
queuedStores = 7

x = 0xaf, xRo = 0xff, xRn = 0xff, co = 0x00, cn = 0x00




0x0000013a  y == 0x70

old: 00 00 2d 55 d1 00 ff
new: 00 00 2d 55 d0 00 ff

Previous:

0x004CECE4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004CECF4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004CED04  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004CED14  55 55 55 55 40 00 00 00 00 00 00 00 00 00 00 00  UUUU@...........

vram0 (incorrect):

0x004CECE4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004CECF4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004CED04  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004CED14  55 55 55 55 40 00 00 00 00 00 00 00 00 00 00 00  UUUU@...........

vram2 (correct):

0x004C7784  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004C7794  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004C77A4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004C77B4  55 55 55 55 00 00 00 00 00 00 00 00 00 00 00 00  UUUU............

x = 0x00, xRo = 0x2d, xRn = 0x2d, co = 0x00, cn = 0x00
queuedSkips = 0x0b

x = 0x2d, xRo = 0xd1, xRn = 0xd0, co = 0x55, cn = 0x55
queuedSkips = 0x33 (should be 34? - need to keep "start of skip" as a pixel rather than queuedSkips as a byte)

x = 0xd0, xRo = 0xd1, xRn = 0xff, co = 0x55, cn = 0x00
queuedStores = 0
partial = 0, havePartial = true

x = 0xd1, xRo = 0xff, xRn = 0xff, co = 0x00, cn = 0x00
queuedSkips = 0x3e (but we should have dealt with that partial before doing that)
*vram = 0x00 (writes at vram = 0)






                //if (xRo < xRn) {
                //    if (co == cn) {
                //        queuedSkips += (xRo - x) >> 2;
                //        if (queuedSkips > 0 && queuedStores > 0) {
                //            memset(vram, cn, queuedStores);
                //            vram += queuedStores;
                //            queuedStores = 0;
                //        }
                //    }
                //    else {
                //        if ((x & 3) != 0) {
                //            if (havePartial) {
                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                //                    if (queuedSkips > 0) {
                //                        vram += queuedSkips;
                //                        queuedSkips = 0;
                //                    }
                //                    *vram = partial | (cn & mask[x & 3]);
                //                    ++vram;
                //                    x = (x + 3) & 0xfc;
                //                    havePartial = false;
                //                }
                //                else {
                //                    partial |= cn &
                //                        mask[x & 3] & ~mask[xRn & 3];
                //                }
                //            }
                //            else {
                //                if (queuedSkips > 0) {
                //                    vram += queuedSkips;
                //                    queuedSkips = 0;
                //                }
                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                //                    *vram = (*vram & ~mask[x & 3]) |
                //                        (cn & mask[x & 3]);
                //                    ++vram;
                //                    x = (x + 3) & 0xfc;
                //                }
                //                else {
                //                    partial = (*vram & ~mask[x & 3]) |
                //                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                //                    havePartial = true;
                //                }
                //            }
                //        }
                //        queuedStores += (xRo - x) >> 2;
                //        if (queuedStores > 0 && queuedSkips > 0) {
                //            vram += queuedSkips;
                //            queuedSkips = 0;
                //        }
                //        if ((xRn & 3) != 0) {
                //            if ((xRn & 0xfc) > (x & 0xfc))
                //                partial = cn & ~mask[xRn & 3];
                //            else {
                //                partial = (*vram & ~mask[x & 3]) |
                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                //            }
                //            havePartial = true;
                //        }
                //    }
                //    x = xRo;
                //    co = so->_c;
                //    ++so;
                //    xRo = so->_x;
                //}
                //else {
                //    if (co == cn) {
                //        queuedSkips += (xRn - x) >> 2;
                //        if (queuedSkips > 0 && queuedStores > 0) {
                //            memset(vram, cn, queuedStores);
                //            vram += queuedStores;
                //            queuedStores = 0;
                //        }
                //    }
                //    else {
                //        if ((x & 3) != 0) {
                //            if (havePartial) {
                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                //                    if (queuedSkips > 0) {
                //                        vram += queuedSkips;
                //                        queuedSkips = 0;
                //                    }
                //                    *vram = partial | (cn & mask[x & 3]);
                //                    ++vram;
                //                    x = (x + 3) & 0xfc;
                //                    havePartial = false;
                //                }
                //                else {
                //                    partial |= cn &
                //                        mask[x & 3] & ~mask[xRn & 3];
                //                }
                //            }
                //            else {
                //                if (queuedSkips > 0) {
                //                    vram += queuedSkips;
                //                    queuedSkips = 0;
                //                }
                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                //                    *vram = (*vram & ~mask[x & 3]) |
                //                        (cn & mask[x & 3]);
                //                    ++vram;
                //                    x = (x + 3) & 0xfc;
                //                }
                //                else {
                //                    partial = (*vram & ~mask[x & 3]) |
                //                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                //                    havePartial = true;
                //                }
                //            }
                //        }
                //        queuedStores += (xRn - x) >> 2;
                //        if (queuedStores > 0 && queuedSkips > 0) {
                //            vram += queuedSkips;
                //            queuedSkips = 0;
                //        }
                //        if ((xRn & 3) != 0) {
                //            if ((xRn & 0xfc) > (x & 0xfc))
                //                partial = cn & ~mask[xRn & 3];
                //            else {
                //                partial = (*vram & ~mask[x & 3]) |
                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                //            }
                //            havePartial = true;
                //        }
                //    }
                //    // Done with this colour - flush queued stores.
                //    if (queuedStores > 0) {
                //        memset(vram, cn, queuedStores);
                //        vram += queuedStores;
                //        queuedStores = 0;
                //    }

                //    x = xRn;
                //    cn = sn->_c;
                //    ++sn;
                //    xRn = sn->_x;
                //    if (x == xRo) {
                //        co = so->_c;
                //        ++so;
                //        xRo = so->_x;
                //    }

                //}




            int storeStart = 0;
            int mode = 0;  // 0 = skip, 1 = store, 2 = partial
            Byte byte = 0;
            int startByte;
            do {
                if (xRo < xRn) {
                    if (co == cn) {
                        switch (mode) {
                            case 1:
                                if ((xRo & 0xfc) > x) {
                                    // End store
                                    startByte = storeStart >> 2;
                                    memset(vram + startByte, byte, (x >> 2) - startByte);
                                    mode = 0;
                                }
                                break;
                            case 2:
                                if ((xRo & 0xfc) > x) {
                                    // End partial
                                    vram[x >> 2] = byte | (cn & mask[x & 3]);
                                    mode = 0;
                                }
                                else {
                                    // Continue partial
                                    byte |= (cn & mask[x & 3] & ~mask[xRo & 3]);
                                }
                                break;
                        }
                    }
                    else {
                        switch (mode) {
                            case 0:
                                if ((x & 3) != 0) {
                                    if ((xRn & 0xfc) > (x & 0xfc)) {
                                        Byte* p = vram + (x >> 2);
                                        *p = (*p & ~mask[x & 3]) | (cn & mask[x & 3]);
                                        x = (x + 3) & 0xfc;
                                        storeStart = x;
                                        byte = cn;
                                        mode = 1;
                                    }
                                    else {
                                        byte = (vram[x >> 2] & ~mask[x & 3]) | (cn & mask[x & 3] & ~mask[xRn & 3]);
                                        mode = 2;
                                    }
                                }
                                else {
                                    storeStart = x;
                                    mode = 1;
                                }
                                //if ((xRn & 3) != 0) {
                                //    if ((xRn & 0xfc) > (x & 0xfc))
                                //        partial = cn & ~mask[xRn & 3];
                                //    else {
                                //        partial = (*vram & ~mask[x & 3]) |
                                //            (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //    }
                                //    havePartial = true;
                                //}
                                break;
                            case 1:
                                if ((x & 3) != 0) {
                                    if ((xRn & 0xfc) > (x & 0xfc)) {
                                        Byte* p = vram + (x >> 2);
                                        *p = (*p & ~mask[x & 3]) | (cn & mask[x & 3]);
                                        x = (x + 3) & 0xfc;
                                        storeStart = x;
                                        byte = cn;
                                        mode = 1;
                                    }
                                    else {
                                        byte = (vram[x >> 2] & ~mask[x & 3]) | (cn & mask[x & 3] & ~mask[xRn & 3]);
                                        mode = 2;
                                    }
                                }
                                queuedStores += (xRo - x) >> 2;
                                if (queuedStores > 0 && queuedSkips > 0) {
                                    vram += queuedSkips;
                                    queuedSkips = 0;
                                }
                                if ((xRn & 3) != 0) {
                                    if ((xRn & 0xfc) > (x & 0xfc))
                                        partial = cn & ~mask[xRn & 3];
                                    else {
                                        partial = (*vram & ~mask[x & 3]) |
                                            (cn & mask[x & 3] & ~mask[xRn & 3]);
                                    }
                                    havePartial = true;
                                }
                                break;
                            case 2:
                                //        if ((x & 3) != 0) {
                                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                                //                    if (queuedSkips > 0) {
                                //                        vram += queuedSkips;
                                //                        queuedSkips = 0;
                                //                    }
                                //                    *vram = partial | (cn & mask[x & 3]);
                                //                    ++vram;
                                //                    x = (x + 3) & 0xfc;
                                //                    havePartial = false;
                                //                }
                                //                else {
                                //                    partial |= cn &
                                //                        mask[x & 3] & ~mask[xRn & 3];
                                //                }
                                //        }
                                //        queuedStores += (xRo - x) >> 2;
                                //        if (queuedStores > 0 && queuedSkips > 0) {
                                //            vram += queuedSkips;
                                //            queuedSkips = 0;
                                //        }
                                //        if ((xRn & 3) != 0) {
                                //            if ((xRn & 0xfc) > (x & 0xfc))
                                //                partial = cn & ~mask[xRn & 3];
                                //            else {
                                //                partial = (*vram & ~mask[x & 3]) |
                                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //            }
                                //            havePartial = true;
                                //        }
                                break;
                        }
                    }
                    x = xRo;
                    co = so->_c;
                    ++so;
                    xRo = so->_x;
                }
                else {
                    if (co == cn) {
                        switch (mode) {
                            case 0:  
                                // Nothing to do - end of skip moved
                                break;
                            case 1:
                                if ((xRn & 0xfc) > x) {
                                    // End store
                                    int startByte = storeStart >> 2;
                                    memset(vram + startByte, byte,
                                        (x >> 2) - startByte);
                                    mode = 0;
                                }
                                break;
                            case 2:
                                if ((xRn & 0xfc) > x) {
                                    // End partial
                                    vram[x >> 2] = byte | (cn & mask[x & 3]);
                                    mode = 0;
                                }
                                else {
                                    // Continue partial
                                    byte |=
                                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                                }
                                break;
                        }
                    }
                    else {
                        switch (mode) {
                            case 0:
                                //        if ((x & 3) != 0) {
                                //                if (queuedSkips > 0) {
                                //                    vram += queuedSkips;
                                //                    queuedSkips = 0;
                                //                }
                                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                                //                    *vram = (*vram & ~mask[x & 3]) |
                                //                        (cn & mask[x & 3]);
                                //                    ++vram;
                                //                    x = (x + 3) & 0xfc;
                                //                }
                                //                else {
                                //                    partial = (*vram & ~mask[x & 3]) |
                                //                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //                    havePartial = true;
                                //                }
                                //        }
                                //        queuedStores += (xRn - x) >> 2;
                                //        if (queuedStores > 0 && queuedSkips > 0) {
                                //            vram += queuedSkips;
                                //            queuedSkips = 0;
                                //        }
                                //        if ((xRn & 3) != 0) {
                                //            if ((xRn & 0xfc) > (x & 0xfc))
                                //                partial = cn & ~mask[xRn & 3];
                                //            else {
                                //                partial = (*vram & ~mask[x & 3]) |
                                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //            }
                                //            havePartial = true;
                                //        }
                                break;
                            case 1:
                                //        if ((x & 3) != 0) {
                                //                if (queuedSkips > 0) {
                                //                    vram += queuedSkips;
                                //                    queuedSkips = 0;
                                //                }
                                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                                //                    *vram = (*vram & ~mask[x & 3]) |
                                //                        (cn & mask[x & 3]);
                                //                    ++vram;
                                //                    x = (x + 3) & 0xfc;
                                //                }
                                //                else {
                                //                    partial = (*vram & ~mask[x & 3]) |
                                //                        (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //                    havePartial = true;
                                //                }
                                //        }
                                //        queuedStores += (xRn - x) >> 2;
                                //        if (queuedStores > 0 && queuedSkips > 0) {
                                //            vram += queuedSkips;
                                //            queuedSkips = 0;
                                //        }
                                //        if ((xRn & 3) != 0) {
                                //            if ((xRn & 0xfc) > (x & 0xfc))
                                //                partial = cn & ~mask[xRn & 3];
                                //            else {
                                //                partial = (*vram & ~mask[x & 3]) |
                                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //            }
                                //            havePartial = true;
                                //        }
                                break;
                            case 2:
                                //        if ((x & 3) != 0) {
                                //                if ((xRn & 0xfc) > (x & 0xfc)) {
                                //                    if (queuedSkips > 0) {
                                //                        vram += queuedSkips;
                                //                        queuedSkips = 0;
                                //                    }
                                //                    *vram = partial | (cn & mask[x & 3]);
                                //                    ++vram;
                                //                    x = (x + 3) & 0xfc;
                                //                    havePartial = false;
                                //                }
                                //                else {
                                //                    partial |= cn &
                                //                        mask[x & 3] & ~mask[xRn & 3];
                                //                }
                                //        }
                                //        queuedStores += (xRn - x) >> 2;
                                //        if (queuedStores > 0 && queuedSkips > 0) {
                                //            vram += queuedSkips;
                                //            queuedSkips = 0;
                                //        }
                                //        if ((xRn & 3) != 0) {
                                //            if ((xRn & 0xfc) > (x & 0xfc))
                                //                partial = cn & ~mask[xRn & 3];
                                //            else {
                                //                partial = (*vram & ~mask[x & 3]) |
                                //                    (cn & mask[x & 3] & ~mask[xRn & 3]);
                                //            }
                                //            havePartial = true;
                                //        }
                                break;
                        }
                    }
                    //    // Done with this colour - flush queued stores.
                    //    if (queuedStores > 0) {
                    //        memset(vram, cn, queuedStores);
                    //        vram += queuedStores;
                    //        queuedStores = 0;
                    //    }
                    x = xRn;
                    cn = sn->_c;
                    ++sn;
                    xRn = sn->_x;
                    if (x == xRo) {
                        co = so->_c;
                        ++so;
                        xRo = so->_x;
                    }
                }
            } while (x < 0xff);
            switch (mode) {
                case 1:
                    startByte = storeStart >> 2;
                    memset(vram + startByte, byte, 0x3f - startByte);
                    break;
                case 2:
                    vram[0x3f] = byte;
            }





        void renderDeltas(Byte* vram, const Line* o) const
        {
            static const Byte mask[4] = {0xff, 0x3f, 0x0f, 0x03};

            const Span* sn = _s;
            const Span* so = o->_s;
            int x = 0;
            int cn = sn->_c;
            ++sn;
            int xRn = sn->_x;
            int co = so->_c;
            ++so;
            int xRo = so->_x;

            bool havePartial = false;
            Byte c = cn;
            bool transparent = true;
            int storeL = 0;
            int storeR = 0;

            do {
                if (co == cn) {
                    if (!transparent) {
                        storeR = x;
                        transparent = true;
                    }
                }
                else {
                    if (transparent) {
                        // Determine whether to combine this store with the previous store
                        if (c != cn || (x & 0xfc) > (storeR & 0xfc) + 4) {
                            int byteL = storeL >> 2;
                            memset(vram + byteL, c, (storeR >> 2) - byteL);
                            storeL = x;
                            c = cn;
                        }
                        transparent = false;
                    }
                    else {
                        if (cn != c) {
                            int byteL = storeL >> 2;
                            memset(vram + byteL, c, (storeR >> 2) - byteL);
                            storeL = x;
                            c = cn;
                        }
                    }
                }
                if (xRo < xRn) {
                    x = xRo;
                    co = so->_c;
                    ++so;
                    xRo = so->_x;
                }
                else {
                    x = xRn;
                    cn = sn->_c;
                    ++sn;
                    xRn = sn->_x;
                    if (x == xRo) {
                        co = so->_c;
                        ++so;
                        xRo = so->_x;
                    }
                }
            } while (x < 0xff);
            if (!transparent)









0x00000021  y == 0x20

old: 00 00 2d 55 af 00 ff
new: 00 00 2d 55 8d 00 ff

Previous:
            00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x002EE14C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x002EE15C  55 55 55 55 55 55 55 55 55 55 55 54 00 00 00 00  UUUUUUUUUUUT....
0x002EE16C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0:
0x0030E08C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0030E09C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0030E0AC  55 55 55 40 00 00 00 00 00 00 00 54 00 00 00 00  UUU@.......T....
0x0030E0BC  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2:
0x00307770  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x00307780  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x00307790  55 55 55 40 00 00 00 00 00 00 00 00 00 00 00 00  UUU@............
0x003077A0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

xLn = 0x00, cn = 0x00, xRn = 0x2d
  xLo = 0x00, co = 0x00, xRo = 0x2d - no actions
xLn = 0x2d, cn = 0x55, xRn = 0x8d
  xLn = 0x30
  xLo = 0x30, co = 0x55, xRo = 0xaf - no actions
xLn = 0x8d, cn = 0x00, xRn = 0xff
  partial = 0x40, set to vram
  xLn = 0x90
  xLo = 0x90, co = 0x55, xRo = 0xaf - no actions
  xLo = 0xaf, co = 0x00, xRo = 0xff
  store 0x90 - 0xaf


