World coordinates: 8.8   -128 <= model.x < 128
Matrix elements: 8.8     -128 <= _xx < 128
r.x and r.y: 16.16       -32768 <= r.x < 32768
r.z: 0 8.16              -128 <= r.z < 128

In current span, the s vector is 338, 282, 0.566
So the matrix elements won't fit in 8.8
  This just means that the model and screen need to be larger by at least a factor of 3
    Making the screen 4x3 in world units is quite nice!

The transformed (screen) coordinates should be accurate to 1/256 of pixel width
However, we want to allow for vertex positions which are a long way offscreen (e.g. above player)
Therefore, pre-clipping we want screen positions in 24.8 format
  Or 12.4?

Suppose transformed coordinates are in 16.16 format.

To compute 16.16 / 16.16, need to shift quotient rep left by x bits and divisor right by 16-x bits
  So could be a 48/32 division or a 32/16
  Latter would be much faster!
  This is x/(z >> 16) - i.e. drop fractional part of z
  However, we only want 8 fractional bits for fillTriangle, so we need a >>8
    So we could compute:
      (x >> 8)/(z >> 16) - 32/16 (really 24/16)
      x/(z >> 8) - 32/24 (can compute as 32/16 if -128 <= r.z < 128)
  We do need the transform output to be 16.8 or 24.8 in order to do clipping properly
    So use 32/16->32, which is two 32/16->16 operations
      xor dx,dx
      mov cx,[rz + 1]
      mov ax,[rx + 2]
      idiv cx          ; dx = remainder, ax = quotient
      mov [sx + 2],ax
      mov ax,[rx]
      idiv cx
      mov [sx],ax




For fillTriangle, we want a 24.8 result - i.e. vR = rR*2^-8

We have vX = rX*2^-16 and vZ = rZ*2^-16

vR = vX/vZ

rR*2^-8 = rX / rZ
rR = rX*2^8 / rZ

Suppose we want to compute this with a 32/16 divide



Suppose we have rX in DX:AX and rZ in BX:CX

mov ch,bl
mov cl,ch
idiv cx


(6*100*s/5) * 5 = 128  s = 0.21333  2/s = size of screen vertically in world coords = 9.375
size of screen horizontally = 10
this is with distance = 5 which is a very wide field of vision
  For a PC game, a 90 degree FoV is normal, i.e. distance = 128 pixels



Express FoV as distance in units of screen width (d/sx)
  FoV of 90 degrees is d/sx = 0.5 = ds    d = ds*sx     sx = d/ds

sx/sy = (5/6)*(256/200) = 1.06666     sx = 1.06666*sy   sy = 0.9375*sx
1/zs = sy/2      zs = 2/sy   sy = 2/zs
ys = 100*zs      zs = ys/100
xs = 6*ys/5      5*xs/6 = ys
xs*d = 128       xs = 128/d


sy = 2/zs = 2/(ys/100) = 200/ys     = pixels per world-unit vertically
sy = 200/(5*xs/6) = 200/(5*(128/d)/6) = 200/(5*(128/(ds*sx))/6) = 200/(5*(128/(ds*(1.06666*sy)))/6)

1/2 = ds


maximum matrix value = xs*d = 6*ys*d/5 = 6*100*(2/sy)*d/5  = 6*100*(2/(0.9375*(d/ds)))*d/5 = 256*ds

Want zs = 1 so sy = 2 and sx = 2.13333333
ys = 100
xs = 120
d = 1.06666


Modify distance to satisfy xs*d = 128

d = 128/xs = 128/(6*ys/5) = 128/(6*(100*zs)/5) = 128/(6*(100*(d/sqrt((d*d + 1)*3)))/5)

d*d = 1.066666666*sqrt((d*d + 1)*3)

d^4 = 1.066666^2 * (d*d + 1)*3

d = 128/(6*(100*(d/sqrt((d*d + 1)*3)))/5)

d = (4/5)*sqrt((8/3) + sqrt(139)/3) = 2.0547091212166765333819588893295

With ys = 99.5*zs, d = 2.06338



cos(a)*cos(b) = (cos(a + b) + cos(a - b))/2
sin(a)*sin(b) = (cos(a - b) - cos(a + b))/2
sin(a)*cos(b) = (sin(a + b) + sin(a - b))/2
cos(a)*sin(b) = (sin(a + b) - sin(a - b))/2


d = 8/15

r = (8/15)/sqrt(3*(1 + 8*8/(15*15)))


sin(u) = 1/256, u ~= 1/256    2048 entries, 2560 with cosines



MUL with byte arguments: 69 cycles plus 1 for each set bit in AL plus 1 if the high byte of the result is 0
MUL with word arguments: 123 cycles plus 1 for each set bit in AX plus 1 if the high word of the result is 0
IMUL with byte arguments: >= 80 cycles
IMUL with word arguments: >= 134 cycles

MUL rb                  69-78
IMUL rb                 80-98
DIV rb                  80-90
IDIV rb                101-112
MUL rw                 118-133
IMUL rw                128-154    141
DIV rw                 144-162
IDIV rw                165-184    175

1 vertex = 8 IMULs and 4 IDIVs = 1828 cycles
20 vertices = 36560 cycles = 120 scanlines
1 triangle = 3 IMULs and 3 IDIVs = 948 cycles
18 triangles = 17064 cycles = 56 scanlines

The


As sine table values are essentially 8 bits plus a sign bit, can we use table-of-squares to do the multiply?

(0x100*a + b)*c = (b*c) + 0x100*(a*c)

Assume value in sine table is in range 0..0xff
  mov si,[sineTable + di]                      ; 4 2
  mov bl,[modelCoord]                          ; 4 1
  mov bh,0                                     ; 2
  add bx,bx                                    ; 2
  mov ax,[si+bx]                               ; 2 2
  neg bx                                       ; 2
  sub ax,[si+bx]                               ; 2 2
  mov bl,[modelCoord + 1]                      ; 4 1
  mov bh,0                                     ; 2
  add bx,bx                                    ; 2
  mov cx,[si+bx]                               ; 2 2
  neg bx                                       ; 2
  sub cx,[si+bx]                               ; 2 2
  mov dl,ch                                    ; 2
  mov dh,0                                     ; 2
  mov ch,cl                                    ; 2
  mov cl,0                                     ; 2
  add ax,cx                                    ; 2
  adc dx,0                                     ; 3      228
No advantage in using half-square tables for full-range 16x8 bit multiplies



  mov ax,[modelCoord]                          ; 20
  imul word[sineTable + ...]                   ; result in dx:ax     134


Is it better to include the world-to-pixel scaling factors into the transformation matrix or apply them separately afterwards?
  Applying them separately doesn't seem to buy us anything, unless we can do crazy optimizations to eliminate the first mul (store separate sine table for each possible world position)
    world (8.8) * rotation (1.8) >> 8 -> rotated (8.8)            imul
    rotated (8.8) <<8 / z (8.8) -> transformed (24.8)          idiv idiv    need 32 bits of precision after perspective applied
    transformed (24.8) * scale (8.8) -> scaled (16.16)            imul

  Applying them together:
    world (8.8) * matrix (8.8) -> worldpix (16.16)   imul
    scaled (16.16) / z (8.8) -> screen (24.8)        idiv idiv


What if a triangle crosses z=0 and is partially visible?
  Need to draw an external triangle (figure 3 in https://www.cs.unc.edu/~olano/papers/2dh-tri/)



New span covers only one old span
  If co != cn
    xlo == xln, xro == xrn - New span covers old span exactly  - no shuffle
    xlo == xln, xro > xrn  - New span covers left of old span  - shuffle right 1
    xlo < xln,  xro == xrn - New span covers right of old span - shuffle right 1
    xlo < xln, xro > xrn   - New span within old span          - shuffle right 2
  else nothing to do
New span covers two old spans

1111111222222222333333333
AaaaaaaBbbbbbbbbCcccccccc




rep stosb to cga = 4 IOs per byte       (28 IOs for 7 bytes)
rep stosw to cga = 3.4285 IOs per byte  (24 IOs for 7 bytes)

mov ah,al
shr cx,1

	movb	%al,	%ah
	shrw	$1,	%cx
	rep	stosw
	adcw	%cx,	%cx
	rep	stosb

~14 bytes needed for longer version to be better




0x000000ea  y == 0x21

old: 00 00 2d 55 af 00 ff
new: 00 00 2d 55 8d 00 ff

Previous:

0x001ADDFC  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x001ADE0C  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x001ADE1C  55 55 55 55 55 55 55 55 55 55 55 54 00 00 00 00  UUUUUUUUUUUT....
0x001ADE2C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0 (incorrect):

0x0044DCB4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0044DCC4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x0044DCD4  55 55 55 00 00 00 00 00 00 00 00 54 00 00 00 00  UUU........T....
0x0044DCE4  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2 (correct):

0x004473D4  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x004473E4  55 55 55 55 55 55 55 55 55 55 55 55 55 55 55 55  UUUUUUUUUUUUUUUU
0x004473F4  55 55 55 40 00 00 00 00 00 00 00 00 00 00 00 00  UUU@............
0x00447404  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

Iteration:

x = 0x00, xRo = 0x2d, xRn = 0x2d, co = 0x00, cn = 0x00
queuedSkips = 0x0b

x = 0x2d, xRo = 0x2d, xRn = 0x8d, co = 0x00, cn = 0x55
queuedStores = 0x00

x = 0x2d, xRo = 0xaf, xRn = 0x8d, co = 0x55, cn = 0x55
queuedSkips = 0x23

Need to create the partial byte 0x40 in here somehow

x = 0x8d, xRo = 0xaf, xRn = 0xff, co = 0x55, cn = 0x00
queuedStores = 0x08
vram = 0x23, queuedSkips = 0x00

x = 0xaf, xRo = 0xff, xRn = 0xff, co = 0x00, cn = 0x00
queuedSkips = 0x14                                      we're skipping
memset(offset = 0x23, value = 0x00, count = 0x08), queuedStores = 0





e9   y == 0x20

old: 00 00 2d 55 49 00 ff
new: 00 00 2d 55 50 00 ff

Previous:

0x003CBC0C  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x003CBC1C  55 55 40 00 00 00 00 00 00 00 00 00 00 00 00 00  UU@.............
0x003CBC2C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x003CBC3C  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram0:

0x0032BB04  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x0032BB14  55 55 40 15 00 00 00 00 00 00 00 00 00 00 00 00  UU@.............
0x0032BB24  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x0032BB34  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

vram2:

0x00327224  00 00 00 00 00 00 00 00 00 00 00 15 55 55 55 55  ............UUUU
0x00327234  55 55 55 55 00 00 00 00 00 00 00 00 00 00 00 00  UUUU............
0x00327244  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x00327254  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

x = 0x00, xRo = 0x2d, xRn = 0x2d, co = 0x00, cn = 0x00
queuedSkips = 0x0b

x = 0x2d, xRo = 0x2d, xRn = 0x50, co = 0x00, cn = 0x55
vram = 0x0b,

