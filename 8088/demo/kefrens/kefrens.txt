The Kefrens bars effect depends on being able to write a pattern of pixels in different positions horizontally and have it be identifiably the same
  Suppose each bar is 16 hdots, then we have 4 effective positions within that bar

Want to use a 2bpp mode so that we can do raster bars separate from the kefrens bars
  0x3d8 = 0x0a, 0x3d9 = 0x3X

Colours
 0 = (depends on palette low nybble)
 1 = (depends on palette low nybble)
 2 = (depends on palette low nybble)
 3 = (depends on palette low nybble)
 4 = (depends on palette low nybble)
 5 = slightly bluish green
 6 = middle blue
 7 = aqua
 8 = (depends on palette low nybble)
 9 = light blue
10 = magenta
11 = purple
12 = (depends on palette low nybble)
13 = olive
14 = light red
15 = white

Initially lets try colours 5, 7, 9, 11
MSbit of each byte is on left so we want
  0xB975

Plotting an even bar at DI (75->[DI], B9->[DI+2])
  mov ax,0xb975
  stosw

Plotting an odd bar at DI (5X->[DI], 97->[DI+2], XB->[DI+4])
  mov al,[es:di]
  and ax,0x000F
  or ax,0x9750
  stosw
  mov al,[es:di]
  and al,0xF0
  or al,0x0B
  stosb

  mov di,[bx]        ; 2 2
  mov al,[es:di]     ; 3 1 +WS
  and ax,[bx+2]      ; 3 2
  or ax,[bx+4]       ; 3 2
  stosw              ; 1 2 +WS +WS
  mov al,[es:di]     ; 3 1 +WS
  and al,[bx+6]      ; 3 2
  or al,[bx+7]       ; 3 2
  stosb              ; 1 1 +WS    ; Est = 37/44.5, NoWS = 40, Actual = 48,

  lodsw              ; 1 2
  xchg ax,di         ; 1 0
  mov bl,[es:di]     ; 3 1 +WS
  lodsw              ; 1 2
  and bx,ax          ; 2 0
  lodsw              ; 1 2
  or bx,ax           ; 2 0
  xchg ax,bx         ; 1 0
  stosw              ; 2 2 +WS +WS
  mov bl,[es:di]     ; 3 1 +WS
  lodsw              ; 1 2
  and bl,al          ; 2 0
  or bl,ah           ; 2 0
  xchg ax,bx         ; 1 0
  stosb              ; 1 1 +WS    ; Est = 37/44.5, NoWS = 38.5, Actual = 46+2/3                 <=

  lodsw              ; 1 2
  xchg ax,di         ; 1 0
  mov cl,[di]        ; 2 1
  lodsw              ; 1 2
  and cx,ax          ; 2 0
  lodsw              ; 1 2
  or cx,ax           ; 2 0
  xchg ax,cx         ; 1 0
  mov [di],ax        ; 2 2
  stosw              ; 2 2 +WS +WS
  mov cl,[di]        ; 2 1
  lodsw              ; 1 2
  and cl,al          ; 2 0
  or cl,ah           ; 2 0
  xchg ax,cx         ; 1 0
  mov [di],al        ; 2 1
  stosb              ; 1 1 +WS     ; Est = 42/46.5, NoWS = 45.75, Actual = 49+1/3

160*8 = 1280 byte LUT




Plotting an odd bar:

Raster bars:
  838 * 200 * 8 / 4 = 83800 bytes with nybble packing

Our budget is 32kB uncompressed, 16kB compressed






Plan:
  Resurrent raster bars stuff in make_table




  Loop is unrolled vertically
  Put t in bp (and bx initially)

  160 possible positions 0..159 so N=80
  At steepest point, sin(x) ~= x so  N * sin(x/N) ~= x  so d/dx (N * sin(x/N)) ~= 1
  Therefore if we want a sine table that doesn't skip any values we need 0 <= x/N < tau  so  0 <= x < tau*N
  We want a period of maybe 3 or 4 cycles in 200 pixels
  Maybe table length = 256 entries, period 256/5 (/4 would be repetitive)
    table[x] = 80 + 80*sin(5*tau*x/256)
    d/dx (table) = 80*5*tau/256 = 10 entries - that's a bit steep - our bars won't overlap!
      That might not matter since the farthest ones are at the back - let's try it and see

  Sine table: 256 entries of 1 byte each (range 0..159)
  Multiplication table: 200 y positions times 160 sine positions times 1 byte per entry = 32000 bytes
    Generate at runtime?


  inc bx
  xor bh,bh
  mov ax,bx
  mov bl,[bx+sineTable]
  mov bl,[bx+mulTable]  ; mulTable is a different 160-element table per scanline
  mov si,bx
  shl si,1
  shl si,1
  shl si,1
  xchg ax,bx

0x0000 - 0x00FF = sine table  - returns half of index into mulTa



Problem:
  Can't do one scanline per row and one row per frame
  Possible solutions:
    1: CRTC trickery - doesn't seem to be time for this
    2: 2 scanlines per row (scanline 0 at 0, scanline 1 at 0x2050)
    3: 2 rows              (scanline 0 at 0, scanline 1 at 0x0050)
  2 and 3 are the same - essentially we get two interleaved Kefrens images

  1 requires 6 CRTC changes per scanline
    Main scanline: horizontal total = 41, horizontal displayed = 40, horizontal sync = 42
    Sync scanline: horizontal total = 16, horizontal displayed = 1, horizontal sync = whatever
  Or maybe 2:
    Main/sync scanline: almost normal
    Sync scanline: horizontal total = small
  Each CRTC change is 6 IOs, plus we need "mov dl,0xd4" and "mov dl,0xd9" (4 IOs) so 16 IOs minimum
    Need to take our routine down to 240 cycles to even stand a chance
      The one way this might be possible is having different routines for odd and even Kefrens pixels and dispatching to them

Plan:
  1: Try interleaved Kefrens bars first
  2: See what the 1-line-restart CRTC trick looks like at minimum
  3: If (2) looks plausible, try odd/even dispatch

We probably want to try an odd/even dispatch anyway because it'll be faster

  inc bx
  xor bh,bh
  mov ax,bx
  mov bl,[bx]
  shl bx,1
  mov di,[bx+0x4567]  ; mulTable is a different 160-element table per scanline
  xchg ax,bx

  test di,0x4000
  jz even

  mov al,[es:di]     ; 3 1 +WS
  and ax,0x000F
  or ax,0x9750
  stosw
  mov al,[es:di]
  and al,0xF0
  or al,0x0B
  stosb

  jmp done
even:

  mov ax,0xb975
  stosw

done:
  mov al,[bp]
  inc bp
  out dx,al

  ss lodsb
  out 0xe0,al


Kefrens5A:

  mov bx,[cs:bp+127]     ; offset into sineTable
  mov sp,[ss:bx+0x4567]  ; mulTable is a different 157-element table per scanline

  pop di
  mov al,[es:di]     ; 3 1 +WS
  pop bx
  and ax,bx          ; 2 0
  pop bx
  or ax,bx           ; 2 0
  stosw              ; 2 2 +WS +WS
  mov al,[es:di]     ; 3 1 +WS
  pop bx
  and al,bl
  or al,bh
  stosb              ; 1 1 +WS

  mov ax,0x4567            ; segment for rasterBars table (one segment per scanline)
  mov ds,ax
  mov al,[bp]
  out dx,al
  mov ds,cx

  lodsb
  out 0xe0,al


Even scanlines: palette 3, colours 5, 7, 9, 11
Odd scanlines: palette 1, colours 5, 15, 11, 10

Let's go with Kefrens5 for now as it's more flexible, even if the dispatch variants are slightly faster

Each of the 320 possible SP values has 4 woeds associated with it:                 odd/3  even/3 odd/1   even/1
  First is DI, the lowest of the addresses in video memory we'll be writing to     0..79  0..79  80..159 80..159
  Second is the AND mask for the first two bytes:                                  0x000F 0x0000 0x000F 0x0000
  Third is the OR mask for the first two bytes:                                    0x9750 0xB975 0xBF50 0xABF5
  Fourth is the AND mask (low) and OR mask (high) for the final byte:              0x0BF0 0x00FF 0x0AF0 0x00FF

Register usage for 5A:
  CS = code
          sineTable.  Size = (838 + 199)*2 =  2074  SS, CS or DS. 1 access. SS is good here since frame number is bp
  ES = CGA and rasterTable
  DS = audio
  SS =
          pixelTable. Size = 157*2*4*2     =  2512  This must be in SS for pops
          mulTable.   Size = 200*2*157     = 62800  SS, CS or DS. 1 access. DS is natural
  AX = various
  BX = various
  CX = DS
  DX = 0x03d9
  SI = audio sample pointer
  DI = various (pointer into CGA RAM)
  BP = frame number (0..837)
  SP = various (pointer into pixelTable)

The raster bars need to move at at least 1 pixel per frame in the fastest parts of their phases
  If amplitude is 100, need 100*tau = 628 frames max => 125600 byte table
Raster bars table stored in y-major order with a different segment for each y coordinate


CS:
  0000 = PSP           0x0100
  0100 = code          ?
         sineTable     2074
         unrolledCode  header+43*200+footer
SS:
  0000 = pixelTable    2512
  09D0 = mulTable      62800
  FF20 = DS start
DS:
         rasterBars    169600
         samples       65536
         song          35954


17977 frames total = 5 minutes + 696 hdots

0 = even/3
1 = odd/3
...
156 = even/3
157 = even/1
158 = odd/1
...
313 = even/3
